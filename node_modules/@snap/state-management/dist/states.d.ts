import { OperatorFunction } from 'rxjs';
import { IfEmpty, Named } from './types';
export type StateCreatorMap<T extends readonly State[]> = {
    [Name in T[number]['name']]: StateCreator<Named<T[number], Name>>;
};
export type StateCreators<States extends readonly State[]> = {
    [K in keyof States]: StateCreator<States[K]>;
};
export interface State<Name extends string = string, Data = any> {
    name: Name;
    data: Data;
}
export type StateCreator<S extends State> = IfEmpty<S['data'], {
    (): S;
    name: S['name'];
}, {
    (data: S['data']): S;
    name: S['name'];
}>;
/**
 * Define a State by providing a name and (optionally) the type of data the State carries. Returns a function which
 * creates states of that type.
 *
 * @param name The state's name, should be unique among all states used by a single state machine.
 * @returns The function returned is used to specify the type of data the State carries â€“ it must be called to return
 * the actual state creator, which is then strongly typed.
 */
export declare const defineState: <Name extends string>(name: Name) => <Data = undefined>() => IfEmpty<Data, {
    (): State<Name, Data>;
    name: Name;
}, {
    (data: Data): State<Name, Data>;
    name: Name;
}>;
/**
 * Create an object from state creators, where each property is the name of the state.
 *
 * @param states Pass one or more states as arguments, using [[defineState]] to create each state.
 * @returns
 */
export declare const defineStates: <States extends readonly State<string, any>[]>(...states: StateCreators<States>) => StateCreatorMap<States>;
/**
 * Filter an `Observable<[Action, State]>` to only emit when the state matches one of the state names given as
 * arguments.
 * ```ts
 * myStateMachine.pipe(
 *   inStates('myFirstState', 'mySecondState'),
 * ).subscribe(doSomethingIfInEitherState)
 * ```
 *
 * @param states Pass one or more state names as arguments, used to filter an `Observable<[Action, State]>`
 * @returns An Observable which only emits when in one of the given states.
 */
export declare function inStates<S extends State, Names extends S['name'][], A>(...states: Names): OperatorFunction<[A, S], [A, Named<S, Names[number]>]>;
/**
 * Determine if a given state is of a specific type, given by an state name. This narrows the type of the state.
 *
 * @param state A state with a broad type (e.g. a union of many states)
 * @param name The name of a specific state.
 * @returns Narrows the type of the state argument to that state which has the given name.
 */
export declare function isState<S extends State, Name extends S['name']>(state: S, name: Name): state is Named<S, Name>;
