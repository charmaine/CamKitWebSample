import { OperatorFunction } from 'rxjs';
import { IfEmpty, Named } from './types';
type ActionCreators<Actions extends readonly Action[]> = {
    readonly [K in keyof Actions]: ActionCreator<Actions[K]>;
};
export type ActionCreatorMap<T extends readonly Action[]> = {
    [Name in T[number]['name']]: ActionCreator<Named<T[number], Name>>;
};
export interface Action<Name extends string = string, Data = any> {
    name: Name;
    data: Data;
}
export type ActionCreator<A extends Action> = IfEmpty<A['data'], {
    (): A;
    name: A['name'];
}, {
    (data: A['data']): A;
    name: A['name'];
}>;
/**
 * Define an Action by providing a name and (optionally) the type of data the Action carries. Returns a function which
 * creates actions of that type.
 *
 * @param name The action's name, should be unique among all actions used by a single state machine.
 * @returns The function returned is used to specify the type of data the Action carries â€“ it must be called to return
 * the actual action creator, which is then strongly typed.
 */
export declare const defineAction: <Name extends string>(name: Name) => <Data = undefined>() => IfEmpty<Data, {
    (): Action<Name, Data>;
    name: Name;
}, {
    (data: Data): Action<Name, Data>;
    name: Name;
}>;
/**
 * Create an object from action creators, where each property is the name of the action.
 *
 * @param actions Pass one or more actions as arguments, using [[defineAction]] to create each action.
 * @returns
 */
export declare const defineActions: <Actions extends readonly Action<string, any>[]>(...actions: ActionCreators<Actions>) => ActionCreatorMap<Actions>;
/**
 * Filter an `Observable<[Action, State]>` to only emit when the action matches one of the action names given as
 * arguments.
 * ```ts
 * myStateMachine.pipe(
 *   forActions('myFirstAction', 'mySecondAction'),
 * ).subscribe(doSomethingOnEitherAction)
 * ```
 *
 * @param actions Pass one or more action names as arguments, used to filter an `Observable<[Action, State]>`
 * @returns
 */
export declare function forActions<A extends Action, Names extends A['name'][], S>(...actions: Names): OperatorFunction<[A, S], [Named<A, Names[number]>, S]>;
/**
 * Determine if a given action is of a specific type, given by an action name. This narrows the type of the action.
 *
 * @param action An action with a broad type (e.g. a union of many actions)
 * @param name The name of a specific action.
 * @returns Narrows the type of the action argument to that action which has the given name.
 */
export declare function isAction<A extends Action, Name extends A['name']>(action: A, name: Name): action is Named<A, Name>;
export {};
