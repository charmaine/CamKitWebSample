import { __awaiter } from "tslib";
import { isValidKey } from "./Persistence";
function wrapRequest(request) {
    const p = new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
    p.request = request;
    return p;
}
/**
 * IndexedDB cursor requests are unique, in that their `onsuccess` handler may be called multiple times. To support
 * this, and allow for an easier-to-use Promise-based API, we wrap the cursor request to support usage like:
 * ```ts
 * let request = await wrapCursorRequest(store.openCursor())
 * while (request.cursor) {
 *   console.log(request.cursor.key, request.cursor.value)
 *   request = await request.continue()
 * }
 * ```
 */
function wrapCursorRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => {
            const cursor = request.result;
            if (!cursor)
                resolve({ cursor: null, continue: () => Promise.reject() });
            else
                resolve({
                    cursor,
                    continue: () => {
                        cursor.continue();
                        return wrapCursorRequest(request);
                    },
                });
        };
        request.onerror = () => reject(request.error);
    });
}
/**
 * A simple key/value persistence using an IndexedDB storage backend.
 *
 * See [Using IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB) for an
 * introduction to how IndexedDB works, its APIs, and how to use it.
 *
 * Note: Currently there is no support for database upgrades. Each instance of this class uses a single IDBObjectStore
 * object set at instantiation time, and there are no hooks for performing migrations between versions. This may be
 * added in the future if such functionality is needed.
 */
export class IndexedDBPersistence {
    /**
     * Construct an {@link IndexedDBPersistence} instance corresponding to a given IndexedDB database version.
     *
     * Throws `ConstraintError` if the version number is invalid (e.g. NaN, or less than 1).
     */
    constructor(options) {
        var _a;
        // We'll namespace our DB names to A) avoid collisions with host applications and B) be transparent about who
        // is using persistence.
        this.databaseName = `Snap.CameraKit.${options.databaseName}`;
        this.databaseVersion = options.databaseVersion;
        this.objectStore = (_a = options.objectStore) !== null && _a !== void 0 ? _a : options.databaseName;
        // `open()` will throw if the version is invalid -- this is desirable vs. rejecting the `db` promise, since then
        // the error is only reported when callers try to perform some operation. Instead, we want the instantiating
        // code to see the error.
        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
        this.size = 0;
    }
    retrieve(key) {
        return this.simpleTransaction("readonly", (store) => store.get(key));
    }
    retrieveAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const { store, done } = yield this.transaction("readonly");
            let request = yield wrapCursorRequest(store.openCursor());
            while (request.cursor) {
                results.push([request.cursor.primaryKey, request.cursor.value]);
                request = yield request.continue();
            }
            yield done;
            return results;
        });
    }
    remove(key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.simpleTransaction("readwrite", (store) => store.delete(key));
            this.size--;
        });
    }
    removeAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const { store, done } = yield this.transaction("readwrite");
            let request = yield wrapCursorRequest(store.openCursor());
            const deleteRequests = [];
            while (request.cursor) {
                results.push(request.cursor.value);
                // If any of the deletes fail (e.g. if the user deletes the object store during the transaction), it will
                // fail the whole transaction. Since the primary expected cause of this failure mode is that the entire
                // object store no longer exists, it's unlikely this will result in unbounded DB growth. That said, callers
                // may want to attempt to retry the removal, or raise an alarm if the persistence size grows unexpectedly.
                deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));
                request = yield request.continue();
            }
            yield Promise.all(deleteRequests.concat(done));
            this.size = 0;
            return results;
        });
    }
    store(keyOrValue, maybeValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const [key, value] = maybeValue === undefined ? [undefined, keyOrValue] : [keyOrValue, maybeValue];
            // The key must be ValidKey | undefined.
            if (!isValidKey(key) && typeof key !== "undefined")
                throw new TypeError(`IndexedDBPersistence failed to ` + `store a value. Invalid key type: ${typeof key}`);
            const storedKey = yield this.simpleTransaction("readwrite", (store) => store.put(value, key));
            this.size++;
            // Type safety: we already assert any given key is valid, and if the key is undefined IndexedDB will generate
            // a numeric key (https://w3c.github.io/IndexedDB/#key-generator).
            return storedKey;
        });
    }
    openDatabase(request) {
        return __awaiter(this, void 0, void 0, function* () {
            // The `open()` call will throw if databaseVersion is invalid (e.g. < 1).
            const dbPromise = wrapRequest(request);
            dbPromise.request.onupgradeneeded = () => {
                try {
                    // The following DOMExceptions may be thrown by `createObjectStore()` – they should all be logically
                    // impossible. We handle the one recoverable exception which could occur below.
                    //
                    // TransactionInactiveError: the database does not exist.
                    // InvalidStateError: `createObjectStore` was called outside a `versionchange` transaction.
                    // InvalidAccessError: `autoIncrement` is true and `keyPath` contains an empty string.
                    dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });
                }
                catch (error) {
                    // ConstraintError is thrown if the object store already exists. Could happen if multiple tabs to the
                    // same domain are opened and race to create the object store. In this case we can safely ignore the
                    // error and continue.
                    if (error instanceof DOMException && error.name === "ConstraintError")
                        return;
                    throw error;
                }
            };
            const db = yield dbPromise;
            db.onclose = () => {
                // The 'close` event fires when the DB is unexpectedly closed (e.g. user clears application data). We'll
                // attempt to re-open it (which may fail, in which case no further attempts will be made, and all future
                // transactions will fail).
                this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
            };
            return db;
        });
    }
    simpleTransaction(mode, operation) {
        return __awaiter(this, void 0, void 0, function* () {
            const { store, done } = yield this.transaction(mode);
            const [result] = yield Promise.all([wrapRequest(operation(store)), done]);
            return result;
        });
    }
    transaction(mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const db = yield this.db;
            // The following DOMExceptions may be thrown – they should all be logically impossible, or could be
            // triggered by the user deleting or modifying the database (e.g. via DevTools) at the right time. We won't
            // attempt to recover from them now, but may decide to do so in the future (if we see them in the wild).
            //
            // InvalidStateError: `close()` has previously been called on the IDBDatabase
            // NotFoundError: the object store does not exist.
            // TypeError: the `mode` parameter is invalid.
            // InvalidAccessError: the function was called with an empty list of object stores.
            const tx = db.transaction(this.objectStore, mode);
            // Similarly, the following DOMExceptions may be thrown by `objectStore()`:
            //
            // InvalidStateError: the transaction has already completed.
            // NotFoundError: the object store is not in the transaction's scope.
            const store = tx.objectStore(this.objectStore);
            const done = new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(new DOMException("The transaction was aborted", "AbortError"));
            });
            return { tx, store, done };
        });
    }
}
//# sourceMappingURL=IndexedDBPersistence.js.map