{"version":3,"file":"IndexedDBPersistence.js","sourceRoot":"","sources":["../../src/persistence/IndexedDBPersistence.ts"],"names":[],"mappings":"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","sourcesContent":["import { isValidKey, Persistence, ValidKey } from \"./Persistence\";\n\ntype IDBRequestPromise<T = any> = Promise<T> & { request: IDBRequest<T> };\n\ninterface EnhancedIDBTransaction {\n    tx: IDBTransaction;\n    store: IDBObjectStore;\n    done: Promise<void>;\n}\n\ninterface EnhancedIDBCursor<T> {\n    cursor: (IDBCursor & { readonly value: T }) | null;\n    continue: () => Promise<EnhancedIDBCursor<T>>;\n}\n\n/**\n * The IndexedDB API makes use of event callbacks that can be cumbersome to use. This method wraps an IDBRequest in a\n * Promise, making it easier to use.\n */\nfunction wrapRequest(request: IDBOpenDBRequest): Promise<IDBDatabase> & { request: IDBOpenDBRequest };\nfunction wrapRequest<T>(request: IDBRequest<T>): IDBRequestPromise<T>;\nfunction wrapRequest(request: IDBRequest): IDBRequestPromise {\n    const p = new Promise((resolve, reject) => {\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(request.error);\n    });\n    (p as IDBRequestPromise).request = request;\n    return p as IDBRequestPromise;\n}\n\n/**\n * IndexedDB cursor requests are unique, in that their `onsuccess` handler may be called multiple times. To support\n * this, and allow for an easier-to-use Promise-based API, we wrap the cursor request to support usage like:\n * ```ts\n * let request = await wrapCursorRequest(store.openCursor())\n * while (request.cursor) {\n *   console.log(request.cursor.key, request.cursor.value)\n *   request = await request.continue()\n * }\n * ```\n */\nfunction wrapCursorRequest<T>(request: IDBRequest<IDBCursorWithValue | null>): Promise<EnhancedIDBCursor<T>> {\n    return new Promise((resolve, reject) => {\n        request.onsuccess = () => {\n            const cursor = request.result;\n            if (!cursor) resolve({ cursor: null, continue: () => Promise.reject() });\n            else\n                resolve({\n                    cursor,\n                    continue: () => {\n                        cursor.continue();\n                        return wrapCursorRequest<T>(request);\n                    },\n                });\n        };\n        request.onerror = () => reject(request.error);\n    });\n}\n\n/**\n * Specify a database name for this {@link IndexedDBPersistence} instance to use.\n * This will be prefixed by `Snap.CameraKit`.\n *\n * A databaseVersion and objectStore may also be specified. Keep in mind the following limitations:\n * - IndexedDBPersistence currently does nothing to migrate data between versions.\n * - If two different IndexedDBPersistence instances use the same databaseName, they must also use the same objectStore.\n * Otherwise a race condition will occur which prevents the creation of all but one objectStore per database.\n */\nexport interface IndexedDBPersistenceOptions {\n    databaseName: string;\n    databaseVersion?: number;\n    objectStore?: string;\n}\n\n/**\n * A simple key/value persistence using an IndexedDB storage backend.\n *\n * See [Using IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB) for an\n * introduction to how IndexedDB works, its APIs, and how to use it.\n *\n * Note: Currently there is no support for database upgrades. Each instance of this class uses a single IDBObjectStore\n * object set at instantiation time, and there are no hooks for performing migrations between versions. This may be\n * added in the future if such functionality is needed.\n */\nexport class IndexedDBPersistence<T> implements Persistence<T> {\n    size: number;\n\n    private db: Promise<IDBDatabase>;\n    private readonly databaseName: string;\n    private readonly databaseVersion?: number;\n    private readonly objectStore: string;\n\n    /**\n     * Construct an {@link IndexedDBPersistence} instance corresponding to a given IndexedDB database version.\n     *\n     * Throws `ConstraintError` if the version number is invalid (e.g. NaN, or less than 1).\n     */\n    constructor(options: IndexedDBPersistenceOptions) {\n        // We'll namespace our DB names to A) avoid collisions with host applications and B) be transparent about who\n        // is using persistence.\n        this.databaseName = `Snap.CameraKit.${options.databaseName}`;\n        this.databaseVersion = options.databaseVersion;\n        this.objectStore = options.objectStore ?? options.databaseName;\n\n        // `open()` will throw if the version is invalid -- this is desirable vs. rejecting the `db` promise, since then\n        // the error is only reported when callers try to perform some operation. Instead, we want the instantiating\n        // code to see the error.\n        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));\n        this.size = 0;\n    }\n\n    retrieve(key: ValidKey): Promise<T | undefined> {\n        return this.simpleTransaction(\"readonly\", (store) => store.get(key));\n    }\n\n    async retrieveAll(): Promise<Array<[ValidKey, T]>> {\n        const results: Array<[ValidKey, T]> = [];\n        const { store, done } = await this.transaction(\"readonly\");\n        let request = await wrapCursorRequest<T>(store.openCursor());\n\n        while (request.cursor) {\n            results.push([request.cursor.primaryKey as ValidKey, request.cursor.value]);\n            request = await request.continue();\n        }\n\n        await done;\n        return results;\n    }\n\n    async remove(key: ValidKey): Promise<void> {\n        await this.simpleTransaction(\"readwrite\", (store) => store.delete(key));\n        this.size--;\n    }\n\n    async removeAll(): Promise<T[]> {\n        const results: T[] = [];\n        const { store, done } = await this.transaction(\"readwrite\");\n        let request = await wrapCursorRequest<T>(store.openCursor());\n        const deleteRequests: Promise<any>[] = [];\n        while (request.cursor) {\n            results.push(request.cursor.value);\n            // If any of the deletes fail (e.g. if the user deletes the object store during the transaction), it will\n            // fail the whole transaction. Since the primary expected cause of this failure mode is that the entire\n            // object store no longer exists, it's unlikely this will result in unbounded DB growth. That said, callers\n            // may want to attempt to retry the removal, or raise an alarm if the persistence size grows unexpectedly.\n            deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));\n            request = await request.continue();\n        }\n        await Promise.all(deleteRequests.concat(done));\n        this.size = 0;\n        return results;\n    }\n\n    async store(value: T): Promise<ValidKey>;\n    async store(key: ValidKey, value: T): Promise<ValidKey>;\n    async store(keyOrValue: T | ValidKey, maybeValue?: T): Promise<ValidKey> {\n        const [key, value] = maybeValue === undefined ? [undefined, keyOrValue] : [keyOrValue, maybeValue];\n\n        // The key must be ValidKey | undefined.\n        if (!isValidKey(key) && typeof key !== \"undefined\")\n            throw new TypeError(`IndexedDBPersistence failed to ` + `store a value. Invalid key type: ${typeof key}`);\n\n        const storedKey = await this.simpleTransaction(\"readwrite\", (store) => store.put(value, key));\n        this.size++;\n\n        // Type safety: we already assert any given key is valid, and if the key is undefined IndexedDB will generate\n        // a numeric key (https://w3c.github.io/IndexedDB/#key-generator).\n        return storedKey as ValidKey;\n    }\n\n    private async openDatabase(request: IDBOpenDBRequest): Promise<IDBDatabase> {\n        // The `open()` call will throw if databaseVersion is invalid (e.g. < 1).\n        const dbPromise = wrapRequest(request);\n        dbPromise.request.onupgradeneeded = () => {\n            try {\n                // The following DOMExceptions may be thrown by `createObjectStore()` – they should all be logically\n                // impossible. We handle the one recoverable exception which could occur below.\n                //\n                // TransactionInactiveError: the database does not exist.\n                // InvalidStateError: `createObjectStore` was called outside a `versionchange` transaction.\n                // InvalidAccessError: `autoIncrement` is true and `keyPath` contains an empty string.\n                dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });\n            } catch (error) {\n                // ConstraintError is thrown if the object store already exists. Could happen if multiple tabs to the\n                // same domain are opened and race to create the object store. In this case we can safely ignore the\n                // error and continue.\n                if (error instanceof DOMException && error.name === \"ConstraintError\") return;\n                throw error;\n            }\n        };\n        const db = await dbPromise;\n        db.onclose = () => {\n            // The 'close` event fires when the DB is unexpectedly closed (e.g. user clears application data). We'll\n            // attempt to re-open it (which may fail, in which case no further attempts will be made, and all future\n            // transactions will fail).\n            this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));\n        };\n        return db;\n    }\n\n    private async simpleTransaction<R>(\n        mode: IDBTransactionMode,\n        operation: (tx: IDBObjectStore) => IDBRequest<R>\n    ): Promise<R> {\n        const { store, done } = await this.transaction(mode);\n        const [result] = await Promise.all([wrapRequest(operation(store)), done]);\n        return result;\n    }\n\n    private async transaction(mode: IDBTransactionMode): Promise<EnhancedIDBTransaction> {\n        const db = await this.db;\n        // The following DOMExceptions may be thrown – they should all be logically impossible, or could be\n        // triggered by the user deleting or modifying the database (e.g. via DevTools) at the right time. We won't\n        // attempt to recover from them now, but may decide to do so in the future (if we see them in the wild).\n        //\n        // InvalidStateError: `close()` has previously been called on the IDBDatabase\n        // NotFoundError: the object store does not exist.\n        // TypeError: the `mode` parameter is invalid.\n        // InvalidAccessError: the function was called with an empty list of object stores.\n        const tx = db.transaction(this.objectStore, mode);\n\n        // Similarly, the following DOMExceptions may be thrown by `objectStore()`:\n        //\n        // InvalidStateError: the transaction has already completed.\n        // NotFoundError: the object store is not in the transaction's scope.\n        const store = tx.objectStore(this.objectStore);\n        const done = new Promise<void>((resolve, reject) => {\n            tx.oncomplete = () => resolve();\n            tx.onerror = () => reject(tx.error);\n            tx.onabort = () => reject(new DOMException(\"The transaction was aborted\", \"AbortError\"));\n        });\n        return { tx, store, done };\n    }\n}\n"]}