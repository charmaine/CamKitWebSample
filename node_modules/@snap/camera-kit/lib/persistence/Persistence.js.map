{"version":3,"file":"Persistence.js","sourceRoot":"","sources":["../../src/persistence/Persistence.ts"],"names":[],"mappings":"AAMA,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,GAAY,EAAmB,EAAE,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;AAEhH;;;;;GAKG;AACH,MAAM,OAAgB,WAAW;CAiBhC","sourcesContent":["/**\n * Different persistence mechanisms (e.g. localStorage, IndexedDB) may support different key types. This type should be\n * a valid key across all concrete Persistence implementations.\n */\nexport type ValidKey = string | number;\n\nexport const isValidKey = (key: unknown): key is ValidKey => typeof key === \"string\" || typeof key === \"number\";\n\n/**\n * The abstract Persistence class defines an async interface for interacting with persistent client-side storage. This\n * is modeled as a simple key/value store.\n *\n * Subclasses may be implemented to support a variety of persistence mechanisms â€“ e.g. localStorage, IndexedDB, etc.\n */\nexport abstract class Persistence<T> {\n    abstract size: number;\n\n    abstract retrieve(key: ValidKey): Promise<T | undefined>;\n\n    abstract retrieveAll(): Promise<Array<[ValidKey, T]>>;\n\n    abstract remove(key: ValidKey): Promise<void>;\n\n    abstract removeAll(): Promise<T[]>;\n\n    /**\n     * Persistence implementations must be capable of generating unique keys, or accepting a unique key from the\n     * caller.\n     */\n    abstract store(value: T): Promise<ValidKey>;\n    abstract store(key: ValidKey, value: T): Promise<ValidKey>;\n}\n"]}