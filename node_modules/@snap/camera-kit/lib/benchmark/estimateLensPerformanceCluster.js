import { __awaiter } from "tslib";
import { benchmarkError } from "../namedErrors";
import { gflopsClusterCenters, benchmarkGflops } from "./benchmarkGflops";
const findNearest = (n, arr) => arr.reduce((a, b) => (Math.abs(a - n) <= Math.abs(b - n) ? a : b));
const webglContextAttributes = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: false,
    powerPreference: "high-performance",
};
/**
 * Run benchmarks which attempt to predict expected lens performance, and assign a cluster (i.e. a performance rating)
 * which the CameraKit SDK can use to optimize certain lenses.
 *
 * @returns A rating from 1-6, indicating expected Lens performance.
 *
 * @category Bootstrapping and Configuration
 */
export function estimateLensPerformance() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Prepare performance measurement.
        const canvas = document.createElement("canvas");
        const gl = canvas.getContext("webgl2", webglContextAttributes);
        if (!gl)
            throw benchmarkError("WebGL2 is required to compute performance, but it is not supported.");
        const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
        const webglRendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
        // Measure performance (just GFLOPS for now, but could add more benchmarks in the future).
        const gflops = yield benchmarkGflops(gl);
        // Combine performance results and compute a performance rating. Right now we just run a single benchmark, so this
        // is pretty trivial.
        const nearestGflopsClusterCenter = findNearest(gflops.value, Array.from(gflopsClusterCenters.keys()));
        // This should always find a value, but just in case something strange happens inside `findNearest`, we'll default
        // to zero (instead of asserting .get() will always be defined).
        const gflopsCluster = (_a = gflopsClusterCenters.get(nearestGflopsClusterCenter)) !== null && _a !== void 0 ? _a : 0;
        return {
            cluster: gflopsCluster,
            benchmarks: [gflops],
            webglRendererInfo,
        };
    });
}
//# sourceMappingURL=estimateLensPerformanceCluster.js.map