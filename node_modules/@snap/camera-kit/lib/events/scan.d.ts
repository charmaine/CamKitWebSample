import { EventOfType, TypedCustomEvent } from "./TypedCustomEvent";
import { EventsFromTarget, TypedEventTarget } from "./TypedEventTarget";
/**
 * Each time an event is emitted, call a given accumulator function with two arguments: some state of type S and the
 * event. The accumulator returns a new state. `scan` returns a new event emitter which emits an event each time a new
 * state is produced by the accumulator.
 *
 * This can be used to implement a Redux-style state management architecture.
 *
 * @param seedState Some initial state, passed to the accumulator when the first event is emitted.
 * @returns A function which takes a source {@link TypedEventTarget}, a list of event types emitted by that target to
 * which to listen, and the accumulator function. The accumulator is called each time an event of the given type(s) is
 * emitted on the source. It is passed the current state and the event, and must return a new state.
 */
export declare const scan: <S>(seedState: S) => <Target extends TypedEventTarget<TypedCustomEvent<string, any>>, Events extends EventsFromTarget<Target>, EventType extends Events["type"]>(source: Target, eventTypes: EventType[], accumulator: (state: S, event: EventOfType<EventType, Events>) => S) => TypedEventTarget<TypedCustomEvent<"state", S>>;
