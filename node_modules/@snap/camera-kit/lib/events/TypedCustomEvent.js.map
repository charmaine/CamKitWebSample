{"version":3,"file":"TypedCustomEvent.js","sourceRoot":"","sources":["../../src/events/TypedCustomEvent.ts"],"names":[],"mappings":"AAEA;;;;GAIG;AACH,MAAM,OAAO,gBAAqD,SAAQ,WAAc;IAMpF,YAAY,IAAO,EAAE,MAAS,EAAE,gBAAoD,EAAE;QAClF,KAAK,CAAC,IAAI,kCAAO,aAAa,KAAE,MAAM,IAAG,CAAC;IAC9C,CAAC;CACJ","sourcesContent":["export type EventOfType<K extends string, Event extends TypedCustomEvent> = Extract<Event, TypedCustomEvent<K, any>>;\n\n/**\n * This wrapper around CustomEvent provides more descriptive type information. By using this class, the `type` property\n * of the CustomEvent will be typed as a string literal – this allows [TypedEventTarget] to provide more useful type\n * checking of events.\n */\nexport class TypedCustomEvent<N extends string = string, T = any> extends CustomEvent<T> {\n    // @ts-ignore: The compiler complains that this property \"has no initializer and is not definitely set in the\n    // constructor\" – we must rely on the superclass constructor to set this, because CustomEvent only implements a\n    // getter for type, so if we try to do `this.type = type` we get a runtime error. We do need to re-define type,\n    // though, so we can give it the specific type N instead of the less-useful string type defined by the superclass.\n    readonly type: N;\n    constructor(type: N, detail: T, eventInitDict: Omit<CustomEventInit<T>, \"detail\"> = {}) {\n        super(type, { ...eventInitDict, detail });\n    }\n}\n"]}