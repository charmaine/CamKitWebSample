{"version":3,"file":"scan.js","sourceRoot":"","sources":["../../src/events/scan.ts"],"names":[],"mappings":"AAAA,OAAO,EAAe,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACnE,OAAO,EAAoB,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAExE;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,MAAM,IAAI,GACb,CAAI,SAAY,EAAE,EAAE,CACpB,CACI,MAAc,EACd,UAAuB,EACvB,WAAmE,EACrB,EAAE;IAChD,IAAI,KAAK,GAAG,SAAS,CAAC;IACtB,MAAM,IAAI,GAAG,IAAI,gBAAgB,EAAgC,CAAC;IAClE,MAAM,QAAQ,GAAG,CAAC,KAAuB,EAAE,EAAE;QACzC,KAAK,GAAG,WAAW,CAAC,KAAK,EAAE,KAAuC,CAAC,CAAC;QACpE,IAAI,CAAC,aAAa,CAAC,IAAI,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;IAC7D,CAAC,CAAC;IAEF,iGAAiG;IACjG,6FAA6F;IAC7F,8DAA8D;IAC9D,EAAE;IACF,uEAAuE;IACvE,IAAI,WAAW,GAAG,KAAK,CAAC;IACxB,IAAI,CAAC,gBAAgB,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,gBAAgB,EAAE;QACrD,KAAK,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,IAAmD,EAAE,EAAE;YAC5E,IAAI,WAAW;gBACX,MAAM,IAAI,KAAK,CACX,gFAAgF;oBAC5E,6DAA6D,CACpE,CAAC;YACN,WAAW,GAAG,IAAI,CAAC;YACnB,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;YAChF,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAChC,CAAC;KACJ,CAAC,CAAC;IACH,IAAI,CAAC,mBAAmB,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,mBAAmB,EAAE;QAC3D,KAAK,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,IAAsD,EAAE,EAAE;YAC/E,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,MAAM,CAAC,mBAAmB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;YACnF,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAChC,CAAC;KACJ,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC;AAChB,CAAC,CAAC","sourcesContent":["import { EventOfType, TypedCustomEvent } from \"./TypedCustomEvent\";\nimport { EventsFromTarget, TypedEventTarget } from \"./TypedEventTarget\";\n\n/**\n * Each time an event is emitted, call a given accumulator function with two arguments: some state of type S and the\n * event. The accumulator returns a new state. `scan` returns a new event emitter which emits an event each time a new\n * state is produced by the accumulator.\n *\n * This can be used to implement a Redux-style state management architecture.\n *\n * @param seedState Some initial state, passed to the accumulator when the first event is emitted.\n * @returns A function which takes a source {@link TypedEventTarget}, a list of event types emitted by that target to\n * which to listen, and the accumulator function. The accumulator is called each time an event of the given type(s) is\n * emitted on the source. It is passed the current state and the event, and must return a new state.\n */\nexport const scan =\n    <S>(seedState: S) =>\n    <Target extends TypedEventTarget, Events extends EventsFromTarget<Target>, EventType extends Events[\"type\"]>(\n        source: Target,\n        eventTypes: EventType[],\n        accumulator: (state: S, event: EventOfType<EventType, Events>) => S\n    ): TypedEventTarget<TypedCustomEvent<\"state\", S>> => {\n        let state = seedState;\n        const sink = new TypedEventTarget<TypedCustomEvent<\"state\", S>>();\n        const listener = (event: TypedCustomEvent) => {\n            state = accumulator(state, event as EventOfType<EventType, Events>);\n            sink.dispatchEvent(new TypedCustomEvent(\"state\", state));\n        };\n\n        // We'll use Proxies to make sure that event listeners are added/removed at the appropriate time.\n        // Callers can then control when to clean up the listeners we add here in a transparent way â€“\n        // by just removing the listener on the returned event target.\n        //\n        // We also prevent multiple listeners on the sink, as a simplification.\n        let hasListener = false;\n        sink.addEventListener = new Proxy(sink.addEventListener, {\n            apply: (target, thisArg, args: Parameters<(typeof sink)[\"addEventListener\"]>) => {\n                if (hasListener)\n                    throw new Error(\n                        \"Cannot add another event listener. The TypedEventTarget returned by scan only \" +\n                            \"supports a single listener, and one has already been added.\"\n                    );\n                hasListener = true;\n                eventTypes.forEach((eventType) => source.addEventListener(eventType, listener));\n                target.apply(thisArg, args);\n            },\n        });\n        sink.removeEventListener = new Proxy(sink.removeEventListener, {\n            apply: (target, thisArg, args: Parameters<(typeof sink)[\"removeEventListener\"]>) => {\n                eventTypes.forEach((eventType) => source.removeEventListener(eventType, listener));\n                target.apply(thisArg, args);\n            },\n        });\n\n        return sink;\n    };\n"]}