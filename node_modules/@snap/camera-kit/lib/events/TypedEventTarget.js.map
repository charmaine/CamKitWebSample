{"version":3,"file":"TypedEventTarget.js","sourceRoot":"","sources":["../../src/events/TypedEventTarget.ts"],"names":[],"mappings":"AAeA;;;;;;;GAOG;AACH,MAAM,OAAO,gBAAgB;IAIzB;QACI,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,gBAAgB,CACZ,IAAO,EACP,QAAoD,EACpD,OAAmC;;QAEnC,+GAA+G;QAC/G,2GAA2G;QAC3G,8GAA8G;QAC9G,sCAAsC;QACtC,MAAM,QAAQ,GAAG,QAAgD,CAAC;QAClE,MAAM,SAAS,GAAG,MAAA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,mCAAI,EAAE,CAAC;QACjD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QACnD,IAAI,OAAO;YAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IACrD,CAAC;IAED,aAAa,CAAC,KAAa;QACvB,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACjD,IAAI,CAAC,SAAS;YAAE,OAAO,IAAI,CAAC;QAE5B,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;;YAC3B,MAAM,OAAO,GAAG,MAAA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,mCAAI,EAAE,CAAC;YACjD,IAAI;gBACA,QAAQ,CAAC,KAAK,CAAC,CAAC;aACnB;YAAC,OAAO,KAAK,EAAE;gBACZ,sGAAsG;gBACtG,wGAAwG;gBACxG,iEAAiE;gBACjE,IAAI,MAAM;oBAAE,MAAM,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;aACjF;YACD,IAAI,OAAO,CAAC,IAAI;gBAAE,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,mBAAmB,CAA2B,IAAO,EAAE,QAAoD;QACvG,MAAM,QAAQ,GAAG,QAAgD,CAAC;QAClE,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,SAAS;YAAE,OAAO;QACvB,IAAI,CAAC,SAAS,CAAC,GAAG,CACd,IAAI,EACJ,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,QAAQ,CAAC,CAC1C,CAAC;QACF,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAClC,CAAC;CACJ","sourcesContent":["import { EventOfType, TypedCustomEvent } from \"./TypedCustomEvent\";\n\nexport type TypedEventListener<Event extends TypedCustomEvent> = (evt: Event) => void;\n\nexport interface TypedEventListenerOptions {\n    once?: boolean;\n}\n\n/**\n * Extract the generic Events type (which must extend {@link TypedCustomEvent}) from a {@link TypedEventTarget}\n */\nexport type EventsFromTarget<Target extends TypedEventTarget> = Target extends TypedEventTarget<infer Events>\n    ? Events\n    : never;\n\n/**\n * This wrapper around EventTarget provides more descriptive type information. By using this class, calls to EventTarget\n * methods are correctly type checked to ensure only allowed event types are used, and that events and their type\n * strings are correctly associated.\n *\n * For example, when calling TypedEventTarget::addEventListener, the event passed to the callback will have the correct\n * type corresponding to the type of event for which the listener has been added.\n */\nexport class TypedEventTarget<Events extends TypedCustomEvent = TypedCustomEvent> {\n    private readonly listeners: Map<string, TypedEventListener<TypedCustomEvent>[]>;\n    private readonly options: Map<TypedEventListener<TypedCustomEvent>, TypedEventListenerOptions>;\n\n    constructor() {\n        this.listeners = new Map();\n        this.options = new Map();\n    }\n\n    addEventListener<K extends Events[\"type\"]>(\n        type: K,\n        callback: TypedEventListener<EventOfType<K, Events>>,\n        options?: TypedEventListenerOptions\n    ): void {\n        // Safety: the type in the method signature ensures the callback handles events of type K, and we use that type\n        // as the key when storing the callback – we only ever invoke callbacks obtained by mapping from that event\n        // type to the callback, so even though we store the callback with a wider type, we only ever call it with the\n        // specific event type specified by K.\n        const listener = callback as TypedEventListener<TypedCustomEvent>;\n        const listeners = this.listeners.get(type) ?? [];\n        this.listeners.set(type, [...listeners, listener]);\n        if (options) this.options.set(listener, options);\n    }\n\n    dispatchEvent(event: Events): true {\n        const listeners = this.listeners.get(event.type);\n        if (!listeners) return true;\n\n        listeners.forEach((listener) => {\n            const options = this.options.get(listener) ?? {};\n            try {\n                listener(event);\n            } catch (error) {\n                // We'll do our best to immitate native behavior, where if a listener throws an error it is caught and\n                // emitted as an error event on the window – this might be slightly different from native behavior since\n                // we have to use a CustomEvent, but it's as close as we can get.\n                if (window) window.dispatchEvent(new CustomEvent(\"error\", { detail: error }));\n            }\n            if (options.once) this.removeEventListener(event.type, listener);\n        });\n\n        return true;\n    }\n\n    removeEventListener<K extends Events[\"type\"]>(type: K, callback: TypedEventListener<EventOfType<K, Events>>): void {\n        const listener = callback as TypedEventListener<TypedCustomEvent>;\n        const listeners = this.listeners.get(type);\n        if (!listeners) return;\n        this.listeners.set(\n            type,\n            listeners.filter((l) => l !== listener)\n        );\n        this.options.delete(listener);\n    }\n}\n"]}