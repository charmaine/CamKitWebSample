{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../../../src/generated-proto/pb_schema/google/api/http.ts"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,GAAG,MAAM,oBAAoB,CAAC;AAErC,MAAM,CAAC,MAAM,eAAe,GAAG,YAAY,CAAC;AAyR5C,SAAS,cAAc;IACrB,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,4BAA4B,EAAE,KAAK,EAAE,CAAC;AAC5D,CAAC;AAED,MAAM,CAAC,MAAM,IAAI,GAAG;IAClB,MAAM,CAAC,OAAa,EAAE,SAAqB,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE;QAC5D,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE;YAC7B,QAAQ,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;SACxD;QACD,IAAI,OAAO,CAAC,4BAA4B,KAAK,IAAI,EAAE;YACjD,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,4BAA4B,CAAC,CAAC;SAC9D;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,MAAM,CAAC,KAA8B,EAAE,MAAe;QACpD,MAAM,MAAM,GAAG,KAAK,YAAY,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC;QAClE,MAAM,OAAO,GAAG,cAAc,EAAE,CAAC;QACjC,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;YACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;YAC5B,QAAQ,GAAG,KAAK,CAAC,EAAE;gBACjB,KAAK,CAAC;oBACJ,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC7D,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,4BAA4B,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;oBACrD,MAAM;gBACR;oBACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;oBACzB,MAAM;aACT;SACF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,QAAQ,CAAC,MAAW;QAClB,OAAO;YACL,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YAC7F,4BAA4B,EAAE,KAAK,CAAC,MAAM,CAAC,4BAA4B,CAAC;gBACtE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,4BAA4B,CAAC;gBAC9C,CAAC,CAAC,KAAK;SACV,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,OAAa;QAClB,MAAM,GAAG,GAAQ,EAAE,CAAC;QACpB,IAAI,OAAO,CAAC,KAAK,EAAE;YACjB,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;SAC5E;aAAM;YACL,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC;SAChB;QACD,OAAO,CAAC,4BAA4B,KAAK,SAAS;YAChD,CAAC,GAAG,CAAC,4BAA4B,GAAG,OAAO,CAAC,4BAA4B,CAAC,CAAC;QAC5E,OAAO,GAAG,CAAC;IACb,CAAC;IAED,WAAW,CAAwC,MAAS;;QAC1D,MAAM,OAAO,GAAG,cAAc,EAAE,CAAC;QACjC,OAAO,CAAC,KAAK,GAAG,CAAA,MAAA,MAAM,CAAC,KAAK,0CAAE,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE,CAAC;QACxE,OAAO,CAAC,4BAA4B,GAAG,MAAA,MAAM,CAAC,4BAA4B,mCAAI,KAAK,CAAC;QACpF,OAAO,OAAO,CAAC;IACjB,CAAC;CACF,CAAC;AAEF,SAAS,kBAAkB;IACzB,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,EAAE,EAAE,kBAAkB,EAAE,EAAE,EAAE,CAAC;AAChF,CAAC;AAED,MAAM,CAAC,MAAM,QAAQ,GAAG;IACtB,MAAM,CAAC,OAAiB,EAAE,SAAqB,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE;;QAChE,IAAI,OAAO,CAAC,QAAQ,KAAK,EAAE,EAAE;YAC3B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;SAC5C;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,EAAE;YACpC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SAC/C;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,EAAE;YACpC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SAC/C;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,MAAM,EAAE;YACrC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SAChD;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ,EAAE;YACvC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SAClD;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,OAAO,EAAE;YACtC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACjD;QACD,IAAI,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ,EAAE;YACvC,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;SACrF;QACD,IAAI,OAAO,CAAC,IAAI,KAAK,EAAE,EAAE;YACvB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACxC;QACD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,kBAAkB,EAAE;YAC1C,QAAQ,CAAC,MAAM,CAAC,CAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;SACxD;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,MAAM,CAAC,KAA8B,EAAE,MAAe;QACpD,MAAM,MAAM,GAAG,KAAK,YAAY,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC;QAClE,MAAM,OAAO,GAAG,kBAAkB,EAAE,CAAC;QACrC,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;YACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;YAC5B,QAAQ,GAAG,KAAK,CAAC,EAAE;gBACjB,KAAK,CAAC;oBACJ,OAAO,CAAC,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;oBACnC,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;oBACzD,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;oBACzD,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;oBAC3D,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;oBAC/D,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;oBAC7D,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,iBAAiB,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC;oBACjG,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;oBAC/B,MAAM;gBACR,KAAK,EAAE;oBACL,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;oBAC1E,MAAM;gBACR;oBACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;oBACzB,MAAM;aACT;SACF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,QAAQ,CAAC,MAAW;QAClB,OAAO;YACL,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;YAC/D,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC;gBACxB,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;gBAC3C,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC;oBACnB,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;oBAC3C,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;wBACpB,CAAC,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;wBAC9C,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;4BACtB,CAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;4BACpD,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;gCACrB,CAAC,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;gCACjD,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;oCACtB,CAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,iBAAiB,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;oCACxE,CAAC,CAAC,SAAS;YACb,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YACnD,kBAAkB,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,kBAAkB,CAAC;gBAC3D,CAAC,CAAC,MAAM,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACjE,CAAC,CAAC,EAAE;SACP,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,OAAiB;;QACtB,MAAM,GAAG,GAAQ,EAAE,CAAC;QACpB,OAAO,CAAC,QAAQ,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;QACpE,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,GAAG,CAAC,CAAC;QACrE,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,GAAG,CAAC,CAAC;QACrE,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,MAAM,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,IAAI,CAAC,CAAC;QACxE,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,MAAM,CAAC,CAAC;QAC9E,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,CAAC,CAAC;QAC3E,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ;YACjC,CAAC,GAAG,CAAC,MAAM,GAAG,CAAA,MAAA,OAAO,CAAC,OAAO,0CAAE,MAAM,EAAC,CAAC,CAAC,iBAAiB,CAAC,MAAM,CAAC,MAAA,OAAO,CAAC,OAAO,0CAAE,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QACzG,OAAO,CAAC,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACxD,IAAI,OAAO,CAAC,kBAAkB,EAAE;YAC9B,GAAG,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;SACtG;aAAM;YACL,GAAG,CAAC,kBAAkB,GAAG,EAAE,CAAC;SAC7B;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAED,WAAW,CAA4C,MAAS;;QAC9D,MAAM,OAAO,GAAG,kBAAkB,EAAE,CAAC;QACrC,OAAO,CAAC,QAAQ,GAAG,MAAA,MAAM,CAAC,QAAQ,mCAAI,EAAE,CAAC;QACzC,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,GAAG,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,GAAG,MAAK,IAAI,EAAE;YACxG,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;SAC7D;QACD,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,KAAK,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,GAAG,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,GAAG,MAAK,IAAI,EAAE;YACxG,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;SAC7D;QACD,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,MAAM,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,IAAI,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,IAAI,MAAK,IAAI,EAAE;YAC3G,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;SAChE;QACD,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,MAAM,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,MAAM,MAAK,IAAI,EAAE;YACjH,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;SACtE;QACD,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,OAAO,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,IAAI,EAAE;YAC9G,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;SACnE;QACD,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,KAAK,MAAK,QAAQ,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,MAAM,MAAK,SAAS,IAAI,CAAA,MAAA,MAAM,CAAC,OAAO,0CAAE,MAAM,MAAK,IAAI,EAAE;YACjH,OAAO,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,iBAAiB,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;SACrG;QACD,OAAO,CAAC,IAAI,GAAG,MAAA,MAAM,CAAC,IAAI,mCAAI,EAAE,CAAC;QACjC,OAAO,CAAC,kBAAkB,GAAG,CAAA,MAAA,MAAM,CAAC,kBAAkB,0CAAE,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,KAAI,EAAE,CAAC;QAClG,OAAO,OAAO,CAAC;IACjB,CAAC;CACF,CAAC;AAEF,SAAS,2BAA2B;IAClC,OAAO,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;AAChC,CAAC;AAED,MAAM,CAAC,MAAM,iBAAiB,GAAG;IAC/B,MAAM,CAAC,OAA0B,EAAE,SAAqB,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE;QACzE,IAAI,OAAO,CAAC,IAAI,KAAK,EAAE,EAAE;YACvB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACxC;QACD,IAAI,OAAO,CAAC,IAAI,KAAK,EAAE,EAAE;YACvB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SACxC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,MAAM,CAAC,KAA8B,EAAE,MAAe;QACpD,MAAM,MAAM,GAAG,KAAK,YAAY,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3E,IAAI,GAAG,GAAG,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC;QAClE,MAAM,OAAO,GAAG,2BAA2B,EAAE,CAAC;QAC9C,OAAO,MAAM,CAAC,GAAG,GAAG,GAAG,EAAE;YACvB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;YAC5B,QAAQ,GAAG,KAAK,CAAC,EAAE;gBACjB,KAAK,CAAC;oBACJ,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;oBAC/B,MAAM;gBACR,KAAK,CAAC;oBACJ,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;oBAC/B,MAAM;gBACR;oBACE,MAAM,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;oBACzB,MAAM;aACT;SACF;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,QAAQ,CAAC,MAAW;QAClB,OAAO;YACL,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YACnD,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;SACpD,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,OAA0B;QAC/B,MAAM,GAAG,GAAQ,EAAE,CAAC;QACpB,OAAO,CAAC,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACxD,OAAO,CAAC,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACxD,OAAO,GAAG,CAAC;IACb,CAAC;IAED,WAAW,CAAqD,MAAS;;QACvE,MAAM,OAAO,GAAG,2BAA2B,EAAE,CAAC;QAC9C,OAAO,CAAC,IAAI,GAAG,MAAA,MAAM,CAAC,IAAI,mCAAI,EAAE,CAAC;QACjC,OAAO,CAAC,IAAI,GAAG,MAAA,MAAM,CAAC,IAAI,mCAAI,EAAE,CAAC;QACjC,OAAO,OAAO,CAAC;IACjB,CAAC;CACF,CAAC;AAqBF,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;IAC1B,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,IAAW,CAAC;IAC5B,GAAG,CAAC,SAAS,EAAE,CAAC;CACjB;AAED,SAAS,KAAK,CAAC,KAAU;IACvB,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC;AAC/C,CAAC","sourcesContent":["/* eslint-disable */\nimport Long from \"long\";\nimport _m0 from \"protobufjs/minimal\";\n\nexport const protobufPackage = \"google.api\";\n\n/**\n * Defines the HTTP configuration for an API service. It contains a list of\n * [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method\n * to one or more HTTP REST API methods.\n */\nexport interface Http {\n  /**\n   * A list of HTTP configuration rules that apply to individual API methods.\n   *\n   * **NOTE:** All service configuration rules follow \"last one wins\" order.\n   */\n  rules: HttpRule[];\n  /**\n   * When set to true, URL path parmeters will be fully URI-decoded except in\n   * cases of single segment matches in reserved expansion, where \"%2F\" will be\n   * left encoded.\n   *\n   * The default behavior is to not decode RFC 6570 reserved characters in multi\n   * segment matches.\n   */\n  fullyDecodeReservedExpansion: boolean;\n}\n\n/**\n * `HttpRule` defines the mapping of an RPC method to one or more HTTP\n * REST API methods. The mapping specifies how different portions of the RPC\n * request message are mapped to URL path, URL query parameters, and\n * HTTP request body. The mapping is typically specified as an\n * `google.api.http` annotation on the RPC method,\n * see \"google/api/annotations.proto\" for details.\n *\n * The mapping consists of a field specifying the path template and\n * method kind.  The path template can refer to fields in the request\n * message, as in the example below which describes a REST GET\n * operation on a resource collection of messages:\n *\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http).get = \"/v1/messages/{message_id}/{sub.subfield}\";\n *       }\n *     }\n *     message GetMessageRequest {\n *       message SubMessage {\n *         string subfield = 1;\n *       }\n *       string message_id = 1; // mapped to the URL\n *       SubMessage sub = 2;    // `sub.subfield` is url-mapped\n *     }\n *     message Message {\n *       string text = 1; // content of the resource\n *     }\n *\n * The same http annotation can alternatively be expressed inside the\n * `GRPC API Configuration` YAML file.\n *\n *     http:\n *       rules:\n *         - selector: <proto_package_name>.Messaging.GetMessage\n *           get: /v1/messages/{message_id}/{sub.subfield}\n *\n * This definition enables an automatic, bidrectional mapping of HTTP\n * JSON to RPC. Example:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456/foo`  | `GetMessage(message_id: \"123456\" sub: SubMessage(subfield: \"foo\"))`\n *\n * In general, not only fields but also field paths can be referenced\n * from a path pattern. Fields mapped to the path pattern cannot be\n * repeated and must have a primitive (non-message) type.\n *\n * Any fields in the request message which are not bound by the path\n * pattern automatically become (optional) HTTP query\n * parameters. Assume the following definition of the request message:\n *\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http).get = \"/v1/messages/{message_id}\";\n *       }\n *     }\n *     message GetMessageRequest {\n *       message SubMessage {\n *         string subfield = 1;\n *       }\n *       string message_id = 1; // mapped to the URL\n *       int64 revision = 2;    // becomes a parameter\n *       SubMessage sub = 3;    // `sub.subfield` becomes a parameter\n *     }\n *\n *\n * This enables a HTTP JSON to RPC mapping as below:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456?revision=2&sub.subfield=foo` | `GetMessage(message_id: \"123456\" revision: 2 sub: SubMessage(subfield: \"foo\"))`\n *\n * Note that fields which are mapped to HTTP parameters must have a\n * primitive type or a repeated primitive type. Message types are not\n * allowed. In the case of a repeated type, the parameter can be\n * repeated in the URL, as in `...?param=A&param=B`.\n *\n * For HTTP method kinds which allow a request body, the `body` field\n * specifies the mapping. Consider a REST update method on the\n * message resource collection:\n *\n *\n *     service Messaging {\n *       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n *         option (google.api.http) = {\n *           put: \"/v1/messages/{message_id}\"\n *           body: \"message\"\n *         };\n *       }\n *     }\n *     message UpdateMessageRequest {\n *       string message_id = 1; // mapped to the URL\n *       Message message = 2;   // mapped to the body\n *     }\n *\n *\n * The following HTTP JSON to RPC mapping is enabled, where the\n * representation of the JSON in the request body is determined by\n * protos JSON encoding:\n *\n * HTTP | RPC\n * -----|-----\n * `PUT /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`\n *\n * The special name `*` can be used in the body mapping to define that\n * every field not bound by the path template should be mapped to the\n * request body.  This enables the following alternative definition of\n * the update method:\n *\n *     service Messaging {\n *       rpc UpdateMessage(Message) returns (Message) {\n *         option (google.api.http) = {\n *           put: \"/v1/messages/{message_id}\"\n *           body: \"*\"\n *         };\n *       }\n *     }\n *     message Message {\n *       string message_id = 1;\n *       string text = 2;\n *     }\n *\n *\n * The following HTTP JSON to RPC mapping is enabled:\n *\n * HTTP | RPC\n * -----|-----\n * `PUT /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" text: \"Hi!\")`\n *\n * Note that when using `*` in the body mapping, it is not possible to\n * have HTTP parameters, as all fields not bound by the path end in\n * the body. This makes this option more rarely used in practice of\n * defining REST APIs. The common usage of `*` is in custom methods\n * which don't use the URL at all for transferring data.\n *\n * It is possible to define multiple HTTP methods for one RPC by using\n * the `additional_bindings` option. Example:\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http) = {\n *           get: \"/v1/messages/{message_id}\"\n *           additional_bindings {\n *             get: \"/v1/users/{user_id}/messages/{message_id}\"\n *           }\n *         };\n *       }\n *     }\n *     message GetMessageRequest {\n *       string message_id = 1;\n *       string user_id = 2;\n *     }\n *\n *\n * This enables the following two alternative HTTP JSON to RPC\n * mappings:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456` | `GetMessage(message_id: \"123456\")`\n * `GET /v1/users/me/messages/123456` | `GetMessage(user_id: \"me\" message_id: \"123456\")`\n *\n * # Rules for HTTP mapping\n *\n * The rules for mapping HTTP path, query parameters, and body fields\n * to the request message are as follows:\n *\n * 1. The `body` field specifies either `*` or a field path, or is\n *    omitted. If omitted, it indicates there is no HTTP request body.\n * 2. Leaf fields (recursive expansion of nested messages in the\n *    request) can be classified into three types:\n *     (a) Matched in the URL template.\n *     (b) Covered by body (if body is `*`, everything except (a) fields;\n *         else everything under the body field)\n *     (c) All other fields.\n * 3. URL query parameters found in the HTTP request are mapped to (c) fields.\n * 4. Any body sent with an HTTP request can contain only (b) fields.\n *\n * The syntax of the path template is as follows:\n *\n *     Template = \"/\" Segments [ Verb ] ;\n *     Segments = Segment { \"/\" Segment } ;\n *     Segment  = \"*\" | \"**\" | LITERAL | Variable ;\n *     Variable = \"{\" FieldPath [ \"=\" Segments ] \"}\" ;\n *     FieldPath = IDENT { \".\" IDENT } ;\n *     Verb     = \":\" LITERAL ;\n *\n * The syntax `*` matches a single path segment. The syntax `**` matches zero\n * or more path segments, which must be the last part of the path except the\n * `Verb`. The syntax `LITERAL` matches literal text in the path.\n *\n * The syntax `Variable` matches part of the URL path as specified by its\n * template. A variable template must not contain other variables. If a variable\n * matches a single path segment, its template may be omitted, e.g. `{var}`\n * is equivalent to `{var=*}`.\n *\n * If a variable contains exactly one path segment, such as `\"{var}\"` or\n * `\"{var=*}\"`, when such a variable is expanded into a URL path, all characters\n * except `[-_.~0-9a-zA-Z]` are percent-encoded. Such variables show up in the\n * Discovery Document as `{var}`.\n *\n * If a variable contains one or more path segments, such as `\"{var=foo/*}\"`\n * or `\"{var=**}\"`, when such a variable is expanded into a URL path, all\n * characters except `[-_.~/0-9a-zA-Z]` are percent-encoded. Such variables\n * show up in the Discovery Document as `{+var}`.\n *\n * NOTE: While the single segment variable matches the semantics of\n * [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2\n * Simple String Expansion, the multi segment variable **does not** match\n * RFC 6570 Reserved Expansion. The reason is that the Reserved Expansion\n * does not expand special characters like `?` and `#`, which would lead\n * to invalid URLs.\n *\n * NOTE: the field paths in variables and in the `body` must not refer to\n * repeated fields or map fields.\n */\nexport interface HttpRule {\n  /**\n   * Selects methods to which this rule applies.\n   *\n   * Refer to [selector][google.api.DocumentationRule.selector] for syntax details.\n   */\n  selector: string;\n  pattern?:\n    | { $case: \"get\"; get: string }\n    | { $case: \"put\"; put: string }\n    | { $case: \"post\"; post: string }\n    | { $case: \"delete\"; delete: string }\n    | { $case: \"patch\"; patch: string }\n    | { $case: \"custom\"; custom: CustomHttpPattern };\n  /**\n   * The name of the request field whose value is mapped to the HTTP body, or\n   * `*` for mapping all fields not captured by the path pattern to the HTTP\n   * body. NOTE: the referred field must not be a repeated field and must be\n   * present at the top-level of request message type.\n   */\n  body: string;\n  /**\n   * Additional HTTP bindings for the selector. Nested bindings must\n   * not contain an `additional_bindings` field themselves (that is,\n   * the nesting may only be one level deep).\n   */\n  additionalBindings: HttpRule[];\n}\n\n/** A custom pattern is used for defining custom HTTP verb. */\nexport interface CustomHttpPattern {\n  /** The name of this custom HTTP verb. */\n  kind: string;\n  /** The path matched by this custom verb. */\n  path: string;\n}\n\nfunction createBaseHttp(): Http {\n  return { rules: [], fullyDecodeReservedExpansion: false };\n}\n\nexport const Http = {\n  encode(message: Http, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    for (const v of message.rules) {\n      HttpRule.encode(v!, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.fullyDecodeReservedExpansion === true) {\n      writer.uint32(16).bool(message.fullyDecodeReservedExpansion);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): Http {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHttp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rules.push(HttpRule.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.fullyDecodeReservedExpansion = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Http {\n    return {\n      rules: Array.isArray(object?.rules) ? object.rules.map((e: any) => HttpRule.fromJSON(e)) : [],\n      fullyDecodeReservedExpansion: isSet(object.fullyDecodeReservedExpansion)\n        ? Boolean(object.fullyDecodeReservedExpansion)\n        : false,\n    };\n  },\n\n  toJSON(message: Http): unknown {\n    const obj: any = {};\n    if (message.rules) {\n      obj.rules = message.rules.map((e) => (e ? HttpRule.toJSON(e) : undefined));\n    } else {\n      obj.rules = [];\n    }\n    message.fullyDecodeReservedExpansion !== undefined &&\n      (obj.fullyDecodeReservedExpansion = message.fullyDecodeReservedExpansion);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<Http>, I>>(object: I): Http {\n    const message = createBaseHttp();\n    message.rules = object.rules?.map((e) => HttpRule.fromPartial(e)) || [];\n    message.fullyDecodeReservedExpansion = object.fullyDecodeReservedExpansion ?? false;\n    return message;\n  },\n};\n\nfunction createBaseHttpRule(): HttpRule {\n  return { selector: \"\", pattern: undefined, body: \"\", additionalBindings: [] };\n}\n\nexport const HttpRule = {\n  encode(message: HttpRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.selector !== \"\") {\n      writer.uint32(10).string(message.selector);\n    }\n    if (message.pattern?.$case === \"get\") {\n      writer.uint32(18).string(message.pattern.get);\n    }\n    if (message.pattern?.$case === \"put\") {\n      writer.uint32(26).string(message.pattern.put);\n    }\n    if (message.pattern?.$case === \"post\") {\n      writer.uint32(34).string(message.pattern.post);\n    }\n    if (message.pattern?.$case === \"delete\") {\n      writer.uint32(42).string(message.pattern.delete);\n    }\n    if (message.pattern?.$case === \"patch\") {\n      writer.uint32(50).string(message.pattern.patch);\n    }\n    if (message.pattern?.$case === \"custom\") {\n      CustomHttpPattern.encode(message.pattern.custom, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.body !== \"\") {\n      writer.uint32(58).string(message.body);\n    }\n    for (const v of message.additionalBindings) {\n      HttpRule.encode(v!, writer.uint32(90).fork()).ldelim();\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): HttpRule {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHttpRule();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.selector = reader.string();\n          break;\n        case 2:\n          message.pattern = { $case: \"get\", get: reader.string() };\n          break;\n        case 3:\n          message.pattern = { $case: \"put\", put: reader.string() };\n          break;\n        case 4:\n          message.pattern = { $case: \"post\", post: reader.string() };\n          break;\n        case 5:\n          message.pattern = { $case: \"delete\", delete: reader.string() };\n          break;\n        case 6:\n          message.pattern = { $case: \"patch\", patch: reader.string() };\n          break;\n        case 8:\n          message.pattern = { $case: \"custom\", custom: CustomHttpPattern.decode(reader, reader.uint32()) };\n          break;\n        case 7:\n          message.body = reader.string();\n          break;\n        case 11:\n          message.additionalBindings.push(HttpRule.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): HttpRule {\n    return {\n      selector: isSet(object.selector) ? String(object.selector) : \"\",\n      pattern: isSet(object.get)\n        ? { $case: \"get\", get: String(object.get) }\n        : isSet(object.put)\n        ? { $case: \"put\", put: String(object.put) }\n        : isSet(object.post)\n        ? { $case: \"post\", post: String(object.post) }\n        : isSet(object.delete)\n        ? { $case: \"delete\", delete: String(object.delete) }\n        : isSet(object.patch)\n        ? { $case: \"patch\", patch: String(object.patch) }\n        : isSet(object.custom)\n        ? { $case: \"custom\", custom: CustomHttpPattern.fromJSON(object.custom) }\n        : undefined,\n      body: isSet(object.body) ? String(object.body) : \"\",\n      additionalBindings: Array.isArray(object?.additionalBindings)\n        ? object.additionalBindings.map((e: any) => HttpRule.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: HttpRule): unknown {\n    const obj: any = {};\n    message.selector !== undefined && (obj.selector = message.selector);\n    message.pattern?.$case === \"get\" && (obj.get = message.pattern?.get);\n    message.pattern?.$case === \"put\" && (obj.put = message.pattern?.put);\n    message.pattern?.$case === \"post\" && (obj.post = message.pattern?.post);\n    message.pattern?.$case === \"delete\" && (obj.delete = message.pattern?.delete);\n    message.pattern?.$case === \"patch\" && (obj.patch = message.pattern?.patch);\n    message.pattern?.$case === \"custom\" &&\n      (obj.custom = message.pattern?.custom ? CustomHttpPattern.toJSON(message.pattern?.custom) : undefined);\n    message.body !== undefined && (obj.body = message.body);\n    if (message.additionalBindings) {\n      obj.additionalBindings = message.additionalBindings.map((e) => (e ? HttpRule.toJSON(e) : undefined));\n    } else {\n      obj.additionalBindings = [];\n    }\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<HttpRule>, I>>(object: I): HttpRule {\n    const message = createBaseHttpRule();\n    message.selector = object.selector ?? \"\";\n    if (object.pattern?.$case === \"get\" && object.pattern?.get !== undefined && object.pattern?.get !== null) {\n      message.pattern = { $case: \"get\", get: object.pattern.get };\n    }\n    if (object.pattern?.$case === \"put\" && object.pattern?.put !== undefined && object.pattern?.put !== null) {\n      message.pattern = { $case: \"put\", put: object.pattern.put };\n    }\n    if (object.pattern?.$case === \"post\" && object.pattern?.post !== undefined && object.pattern?.post !== null) {\n      message.pattern = { $case: \"post\", post: object.pattern.post };\n    }\n    if (object.pattern?.$case === \"delete\" && object.pattern?.delete !== undefined && object.pattern?.delete !== null) {\n      message.pattern = { $case: \"delete\", delete: object.pattern.delete };\n    }\n    if (object.pattern?.$case === \"patch\" && object.pattern?.patch !== undefined && object.pattern?.patch !== null) {\n      message.pattern = { $case: \"patch\", patch: object.pattern.patch };\n    }\n    if (object.pattern?.$case === \"custom\" && object.pattern?.custom !== undefined && object.pattern?.custom !== null) {\n      message.pattern = { $case: \"custom\", custom: CustomHttpPattern.fromPartial(object.pattern.custom) };\n    }\n    message.body = object.body ?? \"\";\n    message.additionalBindings = object.additionalBindings?.map((e) => HttpRule.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCustomHttpPattern(): CustomHttpPattern {\n  return { kind: \"\", path: \"\" };\n}\n\nexport const CustomHttpPattern = {\n  encode(message: CustomHttpPattern, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {\n    if (message.kind !== \"\") {\n      writer.uint32(10).string(message.kind);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): CustomHttpPattern {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCustomHttpPattern();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.kind = reader.string();\n          break;\n        case 2:\n          message.path = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): CustomHttpPattern {\n    return {\n      kind: isSet(object.kind) ? String(object.kind) : \"\",\n      path: isSet(object.path) ? String(object.path) : \"\",\n    };\n  },\n\n  toJSON(message: CustomHttpPattern): unknown {\n    const obj: any = {};\n    message.kind !== undefined && (obj.kind = message.kind);\n    message.path !== undefined && (obj.path = message.path);\n    return obj;\n  },\n\n  fromPartial<I extends Exact<DeepPartial<CustomHttpPattern>, I>>(object: I): CustomHttpPattern {\n    const message = createBaseCustomHttpPattern();\n    message.kind = object.kind ?? \"\";\n    message.path = object.path ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends { $case: string }\n  ? { [K in keyof Omit<T, \"$case\">]?: DeepPartial<T[K]> } & { $case: T[\"$case\"] }\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin\n  ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n"]}