import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../google/protobuf/timestamp";
export const protobufPackage = "snapchat.lenses";
export var UserData_Zodiac;
(function (UserData_Zodiac) {
    UserData_Zodiac["Invalid"] = "Invalid";
    UserData_Zodiac["Aquarius"] = "Aquarius";
    UserData_Zodiac["Aries"] = "Aries";
    UserData_Zodiac["Cancer"] = "Cancer";
    UserData_Zodiac["Capricorn"] = "Capricorn";
    UserData_Zodiac["Gemini"] = "Gemini";
    UserData_Zodiac["Leo"] = "Leo";
    UserData_Zodiac["Libra"] = "Libra";
    UserData_Zodiac["Pisces"] = "Pisces";
    UserData_Zodiac["Sagittarius"] = "Sagittarius";
    UserData_Zodiac["Scorpio"] = "Scorpio";
    UserData_Zodiac["Taurus"] = "Taurus";
    UserData_Zodiac["Virgo"] = "Virgo";
    UserData_Zodiac["UNRECOGNIZED"] = "UNRECOGNIZED";
})(UserData_Zodiac || (UserData_Zodiac = {}));
export function userData_ZodiacFromJSON(object) {
    switch (object) {
        case 0:
        case "Invalid":
            return UserData_Zodiac.Invalid;
        case 1:
        case "Aquarius":
            return UserData_Zodiac.Aquarius;
        case 2:
        case "Aries":
            return UserData_Zodiac.Aries;
        case 3:
        case "Cancer":
            return UserData_Zodiac.Cancer;
        case 4:
        case "Capricorn":
            return UserData_Zodiac.Capricorn;
        case 5:
        case "Gemini":
            return UserData_Zodiac.Gemini;
        case 6:
        case "Leo":
            return UserData_Zodiac.Leo;
        case 7:
        case "Libra":
            return UserData_Zodiac.Libra;
        case 8:
        case "Pisces":
            return UserData_Zodiac.Pisces;
        case 9:
        case "Sagittarius":
            return UserData_Zodiac.Sagittarius;
        case 10:
        case "Scorpio":
            return UserData_Zodiac.Scorpio;
        case 11:
        case "Taurus":
            return UserData_Zodiac.Taurus;
        case 12:
        case "Virgo":
            return UserData_Zodiac.Virgo;
        case -1:
        case "UNRECOGNIZED":
        default:
            return UserData_Zodiac.UNRECOGNIZED;
    }
}
export function userData_ZodiacToNumber(object) {
    switch (object) {
        case UserData_Zodiac.Invalid:
            return 0;
        case UserData_Zodiac.Aquarius:
            return 1;
        case UserData_Zodiac.Aries:
            return 2;
        case UserData_Zodiac.Cancer:
            return 3;
        case UserData_Zodiac.Capricorn:
            return 4;
        case UserData_Zodiac.Gemini:
            return 5;
        case UserData_Zodiac.Leo:
            return 6;
        case UserData_Zodiac.Libra:
            return 7;
        case UserData_Zodiac.Pisces:
            return 8;
        case UserData_Zodiac.Sagittarius:
            return 9;
        case UserData_Zodiac.Scorpio:
            return 10;
        case UserData_Zodiac.Taurus:
            return 11;
        case UserData_Zodiac.Virgo:
            return 12;
        default:
            return 0;
    }
}
function createBaseBitmojiUserInfo() {
    return { avatarId: "", selfieId: "" };
}
export const BitmojiUserInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.avatarId !== "") {
            writer.uint32(10).string(message.avatarId);
        }
        if (message.selfieId !== "") {
            writer.uint32(18).string(message.selfieId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBitmojiUserInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.avatarId = reader.string();
                    break;
                case 2:
                    message.selfieId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBitmojiUserInfo();
        message.avatarId = (_a = object.avatarId) !== null && _a !== void 0 ? _a : "";
        message.selfieId = (_b = object.selfieId) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseFriendUserInfo() {
    return { friendshipStart: undefined, lastInteraction: undefined, streak: 0 };
}
export const FriendUserInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.friendshipStart !== undefined) {
            Timestamp.encode(toTimestamp(message.friendshipStart), writer.uint32(10).fork()).ldelim();
        }
        if (message.lastInteraction !== undefined) {
            Timestamp.encode(toTimestamp(message.lastInteraction), writer.uint32(18).fork()).ldelim();
        }
        if (message.streak !== 0) {
            writer.uint32(24).uint32(message.streak);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFriendUserInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.friendshipStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastInteraction = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.streak = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseFriendUserInfo();
        message.friendshipStart = (_a = object.friendshipStart) !== null && _a !== void 0 ? _a : undefined;
        message.lastInteraction = (_b = object.lastInteraction) !== null && _b !== void 0 ? _b : undefined;
        message.streak = (_c = object.streak) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseUserData() {
    return {
        userId: "",
        username: "",
        birthdate: "",
        displayName: "",
        countrycode: "",
        score: 0,
        bitmojiInfo: undefined,
        friendInfo: undefined,
        zodiac: UserData_Zodiac.Invalid,
    };
}
export const UserData = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.username !== "") {
            writer.uint32(18).string(message.username);
        }
        if (message.birthdate !== "") {
            writer.uint32(26).string(message.birthdate);
        }
        if (message.displayName !== "") {
            writer.uint32(34).string(message.displayName);
        }
        if (message.countrycode !== "") {
            writer.uint32(42).string(message.countrycode);
        }
        if (message.score !== 0) {
            writer.uint32(56).uint64(message.score);
        }
        if (message.bitmojiInfo !== undefined) {
            BitmojiUserInfo.encode(message.bitmojiInfo, writer.uint32(66).fork()).ldelim();
        }
        if (message.friendInfo !== undefined) {
            FriendUserInfo.encode(message.friendInfo, writer.uint32(74).fork()).ldelim();
        }
        if (message.zodiac !== UserData_Zodiac.Invalid) {
            writer.uint32(80).int32(userData_ZodiacToNumber(message.zodiac));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.birthdate = reader.string();
                    break;
                case 4:
                    message.displayName = reader.string();
                    break;
                case 5:
                    message.countrycode = reader.string();
                    break;
                case 7:
                    message.score = longToNumber(reader.uint64());
                    break;
                case 8:
                    message.bitmojiInfo = BitmojiUserInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.friendInfo = FriendUserInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.zodiac = userData_ZodiacFromJSON(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseUserData();
        message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
        message.username = (_b = object.username) !== null && _b !== void 0 ? _b : "";
        message.birthdate = (_c = object.birthdate) !== null && _c !== void 0 ? _c : "";
        message.displayName = (_d = object.displayName) !== null && _d !== void 0 ? _d : "";
        message.countrycode = (_e = object.countrycode) !== null && _e !== void 0 ? _e : "";
        message.score = (_f = object.score) !== null && _f !== void 0 ? _f : 0;
        message.bitmojiInfo =
            object.bitmojiInfo !== undefined && object.bitmojiInfo !== null
                ? BitmojiUserInfo.fromPartial(object.bitmojiInfo)
                : undefined;
        message.friendInfo =
            object.friendInfo !== undefined && object.friendInfo !== null
                ? FriendUserInfo.fromPartial(object.friendInfo)
                : undefined;
        message.zodiac = (_g = object.zodiac) !== null && _g !== void 0 ? _g : UserData_Zodiac.Invalid;
        return message;
    },
};
function createBaseUserDataList() {
    return { userData: [] };
}
export const UserDataList = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.userData) {
            UserData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserDataList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userData.push(UserData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUserDataList();
        message.userData = ((_a = object.userData) === null || _a === void 0 ? void 0 : _a.map((e) => UserData.fromPartial(e))) || [];
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
//# sourceMappingURL=user_data.js.map