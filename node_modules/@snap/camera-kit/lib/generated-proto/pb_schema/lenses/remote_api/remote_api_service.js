import Long from "long";
import _m0 from "protobufjs/minimal";
export const protobufPackage = "snapchat.lenses";
export var HttpRequestMethod;
(function (HttpRequestMethod) {
    HttpRequestMethod["HTTP_METHOD_UNSET"] = "HTTP_METHOD_UNSET";
    HttpRequestMethod["HTTP_METHOD_GET"] = "HTTP_METHOD_GET";
    HttpRequestMethod["HTTP_METHOD_POST"] = "HTTP_METHOD_POST";
    HttpRequestMethod["HTTP_METHOD_PUT"] = "HTTP_METHOD_PUT";
    HttpRequestMethod["HTTP_METHOD_DELETE"] = "HTTP_METHOD_DELETE";
    HttpRequestMethod["HTTP_METHOD_PATCH"] = "HTTP_METHOD_PATCH";
    HttpRequestMethod["UNRECOGNIZED"] = "UNRECOGNIZED";
})(HttpRequestMethod || (HttpRequestMethod = {}));
export function httpRequestMethodFromJSON(object) {
    switch (object) {
        case 0:
        case "HTTP_METHOD_UNSET":
            return HttpRequestMethod.HTTP_METHOD_UNSET;
        case 1:
        case "HTTP_METHOD_GET":
            return HttpRequestMethod.HTTP_METHOD_GET;
        case 2:
        case "HTTP_METHOD_POST":
            return HttpRequestMethod.HTTP_METHOD_POST;
        case 3:
        case "HTTP_METHOD_PUT":
            return HttpRequestMethod.HTTP_METHOD_PUT;
        case 4:
        case "HTTP_METHOD_DELETE":
            return HttpRequestMethod.HTTP_METHOD_DELETE;
        case 5:
        case "HTTP_METHOD_PATCH":
            return HttpRequestMethod.HTTP_METHOD_PATCH;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HttpRequestMethod.UNRECOGNIZED;
    }
}
export function httpRequestMethodToNumber(object) {
    switch (object) {
        case HttpRequestMethod.HTTP_METHOD_UNSET:
            return 0;
        case HttpRequestMethod.HTTP_METHOD_GET:
            return 1;
        case HttpRequestMethod.HTTP_METHOD_POST:
            return 2;
        case HttpRequestMethod.HTTP_METHOD_PUT:
            return 3;
        case HttpRequestMethod.HTTP_METHOD_DELETE:
            return 4;
        case HttpRequestMethod.HTTP_METHOD_PATCH:
            return 5;
        default:
            return 0;
    }
}
export var ResponseCode;
(function (ResponseCode) {
    ResponseCode["RESPONSE_CODE_UNSET"] = "RESPONSE_CODE_UNSET";
    ResponseCode["SUCCESS"] = "SUCCESS";
    ResponseCode["REDIRECTED"] = "REDIRECTED";
    ResponseCode["BAD_REQUEST"] = "BAD_REQUEST";
    ResponseCode["ACCESS_DENIED"] = "ACCESS_DENIED";
    ResponseCode["NOT_FOUND"] = "NOT_FOUND";
    ResponseCode["TIMEOUT"] = "TIMEOUT";
    ResponseCode["REQUEST_TOO_LARGE"] = "REQUEST_TOO_LARGE";
    ResponseCode["SERVER_ERROR"] = "SERVER_ERROR";
    ResponseCode["CANCELLED"] = "CANCELLED";
    ResponseCode["PROXY_ERROR"] = "PROXY_ERROR";
    ResponseCode["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ResponseCode || (ResponseCode = {}));
export function responseCodeFromJSON(object) {
    switch (object) {
        case 0:
        case "RESPONSE_CODE_UNSET":
            return ResponseCode.RESPONSE_CODE_UNSET;
        case 1:
        case "SUCCESS":
            return ResponseCode.SUCCESS;
        case 2:
        case "REDIRECTED":
            return ResponseCode.REDIRECTED;
        case 3:
        case "BAD_REQUEST":
            return ResponseCode.BAD_REQUEST;
        case 4:
        case "ACCESS_DENIED":
            return ResponseCode.ACCESS_DENIED;
        case 5:
        case "NOT_FOUND":
            return ResponseCode.NOT_FOUND;
        case 6:
        case "TIMEOUT":
            return ResponseCode.TIMEOUT;
        case 7:
        case "REQUEST_TOO_LARGE":
            return ResponseCode.REQUEST_TOO_LARGE;
        case 8:
        case "SERVER_ERROR":
            return ResponseCode.SERVER_ERROR;
        case 9:
        case "CANCELLED":
            return ResponseCode.CANCELLED;
        case 10:
        case "PROXY_ERROR":
            return ResponseCode.PROXY_ERROR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseCode.UNRECOGNIZED;
    }
}
export function responseCodeToNumber(object) {
    switch (object) {
        case ResponseCode.RESPONSE_CODE_UNSET:
            return 0;
        case ResponseCode.SUCCESS:
            return 1;
        case ResponseCode.REDIRECTED:
            return 2;
        case ResponseCode.BAD_REQUEST:
            return 3;
        case ResponseCode.ACCESS_DENIED:
            return 4;
        case ResponseCode.NOT_FOUND:
            return 5;
        case ResponseCode.TIMEOUT:
            return 6;
        case ResponseCode.REQUEST_TOO_LARGE:
            return 7;
        case ResponseCode.SERVER_ERROR:
            return 8;
        case ResponseCode.CANCELLED:
            return 9;
        case ResponseCode.PROXY_ERROR:
            return 10;
        default:
            return 0;
    }
}
export var GetOAuth2InfoResponse_GrantType;
(function (GetOAuth2InfoResponse_GrantType) {
    GetOAuth2InfoResponse_GrantType["GRANT_TYPE_UNSET"] = "GRANT_TYPE_UNSET";
    GetOAuth2InfoResponse_GrantType["AUTHORIZATION_CODE"] = "AUTHORIZATION_CODE";
    GetOAuth2InfoResponse_GrantType["AUTHORIZATION_CODE_WITH_PKCE"] = "AUTHORIZATION_CODE_WITH_PKCE";
    GetOAuth2InfoResponse_GrantType["IMPLICIT"] = "IMPLICIT";
    GetOAuth2InfoResponse_GrantType["CLIENT_CREDENTIALS"] = "CLIENT_CREDENTIALS";
    GetOAuth2InfoResponse_GrantType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(GetOAuth2InfoResponse_GrantType || (GetOAuth2InfoResponse_GrantType = {}));
export function getOAuth2InfoResponse_GrantTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "GRANT_TYPE_UNSET":
            return GetOAuth2InfoResponse_GrantType.GRANT_TYPE_UNSET;
        case 1:
        case "AUTHORIZATION_CODE":
            return GetOAuth2InfoResponse_GrantType.AUTHORIZATION_CODE;
        case 2:
        case "AUTHORIZATION_CODE_WITH_PKCE":
            return GetOAuth2InfoResponse_GrantType.AUTHORIZATION_CODE_WITH_PKCE;
        case 3:
        case "IMPLICIT":
            return GetOAuth2InfoResponse_GrantType.IMPLICIT;
        case 4:
        case "CLIENT_CREDENTIALS":
            return GetOAuth2InfoResponse_GrantType.CLIENT_CREDENTIALS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GetOAuth2InfoResponse_GrantType.UNRECOGNIZED;
    }
}
export function getOAuth2InfoResponse_GrantTypeToNumber(object) {
    switch (object) {
        case GetOAuth2InfoResponse_GrantType.GRANT_TYPE_UNSET:
            return 0;
        case GetOAuth2InfoResponse_GrantType.AUTHORIZATION_CODE:
            return 1;
        case GetOAuth2InfoResponse_GrantType.AUTHORIZATION_CODE_WITH_PKCE:
            return 2;
        case GetOAuth2InfoResponse_GrantType.IMPLICIT:
            return 3;
        case GetOAuth2InfoResponse_GrantType.CLIENT_CREDENTIALS:
            return 4;
        default:
            return 0;
    }
}
export var TokenExchangeError_TokenExchangeErrorType;
(function (TokenExchangeError_TokenExchangeErrorType) {
    TokenExchangeError_TokenExchangeErrorType["ERROR_TYPE_UNSET"] = "ERROR_TYPE_UNSET";
    TokenExchangeError_TokenExchangeErrorType["INVALID_REQUEST"] = "INVALID_REQUEST";
    TokenExchangeError_TokenExchangeErrorType["INVALID_CLIENT"] = "INVALID_CLIENT";
    TokenExchangeError_TokenExchangeErrorType["INVALID_GRANT"] = "INVALID_GRANT";
    TokenExchangeError_TokenExchangeErrorType["UNAUTHORIZED_CLIENT"] = "UNAUTHORIZED_CLIENT";
    TokenExchangeError_TokenExchangeErrorType["UNSUPPORTED_GRANT_TYPE"] = "UNSUPPORTED_GRANT_TYPE";
    TokenExchangeError_TokenExchangeErrorType["INVALID_SCOPE"] = "INVALID_SCOPE";
    TokenExchangeError_TokenExchangeErrorType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(TokenExchangeError_TokenExchangeErrorType || (TokenExchangeError_TokenExchangeErrorType = {}));
export function tokenExchangeError_TokenExchangeErrorTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ERROR_TYPE_UNSET":
            return TokenExchangeError_TokenExchangeErrorType.ERROR_TYPE_UNSET;
        case 1:
        case "INVALID_REQUEST":
            return TokenExchangeError_TokenExchangeErrorType.INVALID_REQUEST;
        case 2:
        case "INVALID_CLIENT":
            return TokenExchangeError_TokenExchangeErrorType.INVALID_CLIENT;
        case 3:
        case "INVALID_GRANT":
            return TokenExchangeError_TokenExchangeErrorType.INVALID_GRANT;
        case 4:
        case "UNAUTHORIZED_CLIENT":
            return TokenExchangeError_TokenExchangeErrorType.UNAUTHORIZED_CLIENT;
        case 5:
        case "UNSUPPORTED_GRANT_TYPE":
            return TokenExchangeError_TokenExchangeErrorType.UNSUPPORTED_GRANT_TYPE;
        case 6:
        case "INVALID_SCOPE":
            return TokenExchangeError_TokenExchangeErrorType.INVALID_SCOPE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TokenExchangeError_TokenExchangeErrorType.UNRECOGNIZED;
    }
}
export function tokenExchangeError_TokenExchangeErrorTypeToNumber(object) {
    switch (object) {
        case TokenExchangeError_TokenExchangeErrorType.ERROR_TYPE_UNSET:
            return 0;
        case TokenExchangeError_TokenExchangeErrorType.INVALID_REQUEST:
            return 1;
        case TokenExchangeError_TokenExchangeErrorType.INVALID_CLIENT:
            return 2;
        case TokenExchangeError_TokenExchangeErrorType.INVALID_GRANT:
            return 3;
        case TokenExchangeError_TokenExchangeErrorType.UNAUTHORIZED_CLIENT:
            return 4;
        case TokenExchangeError_TokenExchangeErrorType.UNSUPPORTED_GRANT_TYPE:
            return 5;
        case TokenExchangeError_TokenExchangeErrorType.INVALID_SCOPE:
            return 6;
        default:
            return 0;
    }
}
function createBasePerformHttpCallRequest() {
    return {
        url: "",
        method: HttpRequestMethod.HTTP_METHOD_UNSET,
        headers: {},
        body: new Uint8Array(),
        apiSpecId: "",
        isStudioDev: false,
    };
}
export const PerformHttpCallRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.method !== HttpRequestMethod.HTTP_METHOD_UNSET) {
            writer.uint32(16).int32(httpRequestMethodToNumber(message.method));
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            PerformHttpCallRequest_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(34).bytes(message.body);
        }
        if (message.apiSpecId !== "") {
            writer.uint32(42).string(message.apiSpecId);
        }
        if (message.isStudioDev === true) {
            writer.uint32(48).bool(message.isStudioDev);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformHttpCallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.method = httpRequestMethodFromJSON(reader.int32());
                    break;
                case 3:
                    const entry3 = PerformHttpCallRequest_HeadersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.headers[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                case 5:
                    message.apiSpecId = reader.string();
                    break;
                case 6:
                    message.isStudioDev = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBasePerformHttpCallRequest();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.method = (_b = object.method) !== null && _b !== void 0 ? _b : HttpRequestMethod.HTTP_METHOD_UNSET;
        message.headers = Object.entries((_c = object.headers) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.body = (_d = object.body) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.apiSpecId = (_e = object.apiSpecId) !== null && _e !== void 0 ? _e : "";
        message.isStudioDev = (_f = object.isStudioDev) !== null && _f !== void 0 ? _f : false;
        return message;
    },
};
function createBasePerformHttpCallRequest_HeadersEntry() {
    return { key: "", value: "" };
}
export const PerformHttpCallRequest_HeadersEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformHttpCallRequest_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePerformHttpCallRequest_HeadersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePerformHttpCallResponse() {
    return { code: 0, headers: {}, body: new Uint8Array() };
}
export const PerformHttpCallResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).int32(message.code);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            PerformHttpCallResponse_HeadersEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(26).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformHttpCallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    const entry2 = PerformHttpCallResponse_HeadersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.headers[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePerformHttpCallResponse();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.headers = Object.entries((_b = object.headers) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.body = (_c = object.body) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    },
};
function createBasePerformHttpCallResponse_HeadersEntry() {
    return { key: "", value: "" };
}
export const PerformHttpCallResponse_HeadersEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformHttpCallResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePerformHttpCallResponse_HeadersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseGetOAuth2InfoRequest() {
    return { apiSpecId: "" };
}
export const GetOAuth2InfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apiSpecId !== "") {
            writer.uint32(10).string(message.apiSpecId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOAuth2InfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apiSpecId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetOAuth2InfoRequest();
        message.apiSpecId = (_a = object.apiSpecId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetOAuth2InfoResponse() {
    return { clientId: "", grantType: GetOAuth2InfoResponse_GrantType.GRANT_TYPE_UNSET, authorizationUrl: "", scope: "" };
}
export const GetOAuth2InfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.grantType !== GetOAuth2InfoResponse_GrantType.GRANT_TYPE_UNSET) {
            writer.uint32(16).int32(getOAuth2InfoResponse_GrantTypeToNumber(message.grantType));
        }
        if (message.authorizationUrl !== "") {
            writer.uint32(26).string(message.authorizationUrl);
        }
        if (message.scope !== "") {
            writer.uint32(34).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOAuth2InfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.clientId = reader.string();
                    break;
                case 2:
                    message.grantType = getOAuth2InfoResponse_GrantTypeFromJSON(reader.int32());
                    break;
                case 3:
                    message.authorizationUrl = reader.string();
                    break;
                case 4:
                    message.scope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseGetOAuth2InfoResponse();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.grantType = (_b = object.grantType) !== null && _b !== void 0 ? _b : GetOAuth2InfoResponse_GrantType.GRANT_TYPE_UNSET;
        message.authorizationUrl = (_c = object.authorizationUrl) !== null && _c !== void 0 ? _c : "";
        message.scope = (_d = object.scope) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseTokenExchangeError() {
    return { error: TokenExchangeError_TokenExchangeErrorType.ERROR_TYPE_UNSET, errorDescription: "" };
}
export const TokenExchangeError = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== TokenExchangeError_TokenExchangeErrorType.ERROR_TYPE_UNSET) {
            writer.uint32(8).int32(tokenExchangeError_TokenExchangeErrorTypeToNumber(message.error));
        }
        if (message.errorDescription !== "") {
            writer.uint32(18).string(message.errorDescription);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenExchangeError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.error = tokenExchangeError_TokenExchangeErrorTypeFromJSON(reader.int32());
                    break;
                case 2:
                    message.errorDescription = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTokenExchangeError();
        message.error = (_a = object.error) !== null && _a !== void 0 ? _a : TokenExchangeError_TokenExchangeErrorType.ERROR_TYPE_UNSET;
        message.errorDescription = (_b = object.errorDescription) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseTokenDetails() {
    return { accessToken: "", tokenType: "", expiresInSeconds: 0, refreshToken: "", scope: "" };
}
export const TokenDetails = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.accessToken !== "") {
            writer.uint32(10).string(message.accessToken);
        }
        if (message.tokenType !== "") {
            writer.uint32(18).string(message.tokenType);
        }
        if (message.expiresInSeconds !== 0) {
            writer.uint32(24).int64(message.expiresInSeconds);
        }
        if (message.refreshToken !== "") {
            writer.uint32(34).string(message.refreshToken);
        }
        if (message.scope !== "") {
            writer.uint32(42).string(message.scope);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenDetails();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accessToken = reader.string();
                    break;
                case 2:
                    message.tokenType = reader.string();
                    break;
                case 3:
                    message.expiresInSeconds = longToNumber(reader.int64());
                    break;
                case 4:
                    message.refreshToken = reader.string();
                    break;
                case 5:
                    message.scope = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseTokenDetails();
        message.accessToken = (_a = object.accessToken) !== null && _a !== void 0 ? _a : "";
        message.tokenType = (_b = object.tokenType) !== null && _b !== void 0 ? _b : "";
        message.expiresInSeconds = (_c = object.expiresInSeconds) !== null && _c !== void 0 ? _c : 0;
        message.refreshToken = (_d = object.refreshToken) !== null && _d !== void 0 ? _d : "";
        message.scope = (_e = object.scope) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBasePerformTokenExchangeRequest() {
    return { apiSpecId: "", authorizationCode: "", codeVerifier: "" };
}
export const PerformTokenExchangeRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apiSpecId !== "") {
            writer.uint32(10).string(message.apiSpecId);
        }
        if (message.authorizationCode !== "") {
            writer.uint32(18).string(message.authorizationCode);
        }
        if (message.codeVerifier !== "") {
            writer.uint32(26).string(message.codeVerifier);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformTokenExchangeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apiSpecId = reader.string();
                    break;
                case 2:
                    message.authorizationCode = reader.string();
                    break;
                case 3:
                    message.codeVerifier = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePerformTokenExchangeRequest();
        message.apiSpecId = (_a = object.apiSpecId) !== null && _a !== void 0 ? _a : "";
        message.authorizationCode = (_b = object.authorizationCode) !== null && _b !== void 0 ? _b : "";
        message.codeVerifier = (_c = object.codeVerifier) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBasePerformTokenExchangeResponse() {
    return { response: undefined };
}
export const PerformTokenExchangeResponse = {
    encode(message, writer = _m0.Writer.create()) {
        var _a, _b;
        if (((_a = message.response) === null || _a === void 0 ? void 0 : _a.$case) === "tokenDetails") {
            TokenDetails.encode(message.response.tokenDetails, writer.uint32(10).fork()).ldelim();
        }
        if (((_b = message.response) === null || _b === void 0 ? void 0 : _b.$case) === "error") {
            TokenExchangeError.encode(message.response.error, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformTokenExchangeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.response = { $case: "tokenDetails", tokenDetails: TokenDetails.decode(reader, reader.uint32()) };
                    break;
                case 2:
                    message.response = { $case: "error", error: TokenExchangeError.decode(reader, reader.uint32()) };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBasePerformTokenExchangeResponse();
        if (((_a = object.response) === null || _a === void 0 ? void 0 : _a.$case) === "tokenDetails" &&
            ((_b = object.response) === null || _b === void 0 ? void 0 : _b.tokenDetails) !== undefined &&
            ((_c = object.response) === null || _c === void 0 ? void 0 : _c.tokenDetails) !== null) {
            message.response = {
                $case: "tokenDetails",
                tokenDetails: TokenDetails.fromPartial(object.response.tokenDetails),
            };
        }
        if (((_d = object.response) === null || _d === void 0 ? void 0 : _d.$case) === "error" && ((_e = object.response) === null || _e === void 0 ? void 0 : _e.error) !== undefined && ((_f = object.response) === null || _f === void 0 ? void 0 : _f.error) !== null) {
            message.response = { $case: "error", error: TokenExchangeError.fromPartial(object.response.error) };
        }
        return message;
    },
};
function createBaseRefreshTokenRequest() {
    return { apiSpecId: "", refreshToken: "" };
}
export const RefreshTokenRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apiSpecId !== "") {
            writer.uint32(10).string(message.apiSpecId);
        }
        if (message.refreshToken !== "") {
            writer.uint32(18).string(message.refreshToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshTokenRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apiSpecId = reader.string();
                    break;
                case 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRefreshTokenRequest();
        message.apiSpecId = (_a = object.apiSpecId) !== null && _a !== void 0 ? _a : "";
        message.refreshToken = (_b = object.refreshToken) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseRefreshTokenResponse() {
    return { response: undefined };
}
export const RefreshTokenResponse = {
    encode(message, writer = _m0.Writer.create()) {
        var _a, _b;
        if (((_a = message.response) === null || _a === void 0 ? void 0 : _a.$case) === "tokenDetails") {
            TokenDetails.encode(message.response.tokenDetails, writer.uint32(10).fork()).ldelim();
        }
        if (((_b = message.response) === null || _b === void 0 ? void 0 : _b.$case) === "error") {
            TokenExchangeError.encode(message.response.error, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshTokenResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.response = { $case: "tokenDetails", tokenDetails: TokenDetails.decode(reader, reader.uint32()) };
                    break;
                case 2:
                    message.response = { $case: "error", error: TokenExchangeError.decode(reader, reader.uint32()) };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseRefreshTokenResponse();
        if (((_a = object.response) === null || _a === void 0 ? void 0 : _a.$case) === "tokenDetails" &&
            ((_b = object.response) === null || _b === void 0 ? void 0 : _b.tokenDetails) !== undefined &&
            ((_c = object.response) === null || _c === void 0 ? void 0 : _c.tokenDetails) !== null) {
            message.response = {
                $case: "tokenDetails",
                tokenDetails: TokenDetails.fromPartial(object.response.tokenDetails),
            };
        }
        if (((_d = object.response) === null || _d === void 0 ? void 0 : _d.$case) === "error" && ((_e = object.response) === null || _e === void 0 ? void 0 : _e.error) !== undefined && ((_f = object.response) === null || _f === void 0 ? void 0 : _f.error) !== null) {
            message.response = { $case: "error", error: TokenExchangeError.fromPartial(object.response.error) };
        }
        return message;
    },
};
function createBasePerformApiCallRequest() {
    return {
        apiSpecSetId: "",
        endpointRefId: "",
        parameters: {},
        body: new Uint8Array(),
        lensId: "",
        isStudioDev: false,
        cacheTtlSec: 0,
        linkedResources: [],
    };
}
export const PerformApiCallRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.apiSpecSetId !== "") {
            writer.uint32(10).string(message.apiSpecSetId);
        }
        if (message.endpointRefId !== "") {
            writer.uint32(18).string(message.endpointRefId);
        }
        Object.entries(message.parameters).forEach(([key, value]) => {
            PerformApiCallRequest_ParametersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(34).bytes(message.body);
        }
        if (message.lensId !== "") {
            writer.uint32(42).string(message.lensId);
        }
        if (message.isStudioDev === true) {
            writer.uint32(48).bool(message.isStudioDev);
        }
        if (message.cacheTtlSec !== 0) {
            writer.uint32(56).int32(message.cacheTtlSec);
        }
        for (const v of message.linkedResources) {
            LinkedResource.encode(v, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformApiCallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.apiSpecSetId = reader.string();
                    break;
                case 2:
                    message.endpointRefId = reader.string();
                    break;
                case 3:
                    const entry3 = PerformApiCallRequest_ParametersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.parameters[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                case 5:
                    message.lensId = reader.string();
                    break;
                case 6:
                    message.isStudioDev = reader.bool();
                    break;
                case 7:
                    message.cacheTtlSec = reader.int32();
                    break;
                case 8:
                    message.linkedResources.push(LinkedResource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBasePerformApiCallRequest();
        message.apiSpecSetId = (_a = object.apiSpecSetId) !== null && _a !== void 0 ? _a : "";
        message.endpointRefId = (_b = object.endpointRefId) !== null && _b !== void 0 ? _b : "";
        message.parameters = Object.entries((_c = object.parameters) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.body = (_d = object.body) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.lensId = (_e = object.lensId) !== null && _e !== void 0 ? _e : "";
        message.isStudioDev = (_f = object.isStudioDev) !== null && _f !== void 0 ? _f : false;
        message.cacheTtlSec = (_g = object.cacheTtlSec) !== null && _g !== void 0 ? _g : 0;
        message.linkedResources = ((_h = object.linkedResources) === null || _h === void 0 ? void 0 : _h.map((e) => LinkedResource.fromPartial(e))) || [];
        return message;
    },
};
function createBasePerformApiCallRequest_ParametersEntry() {
    return { key: "", value: "" };
}
export const PerformApiCallRequest_ParametersEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformApiCallRequest_ParametersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePerformApiCallRequest_ParametersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePerformApiCallResponse() {
    return {
        responseCode: ResponseCode.RESPONSE_CODE_UNSET,
        metadata: {},
        body: new Uint8Array(),
        userLocationUsed: false,
        linkedResources: [],
    };
}
export const PerformApiCallResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.responseCode !== ResponseCode.RESPONSE_CODE_UNSET) {
            writer.uint32(8).int32(responseCodeToNumber(message.responseCode));
        }
        Object.entries(message.metadata).forEach(([key, value]) => {
            PerformApiCallResponse_MetadataEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.body.length !== 0) {
            writer.uint32(26).bytes(message.body);
        }
        if (message.userLocationUsed === true) {
            writer.uint32(32).bool(message.userLocationUsed);
        }
        for (const v of message.linkedResources) {
            LinkedResource.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformApiCallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.responseCode = responseCodeFromJSON(reader.int32());
                    break;
                case 2:
                    const entry2 = PerformApiCallResponse_MetadataEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.metadata[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                case 4:
                    message.userLocationUsed = reader.bool();
                    break;
                case 5:
                    message.linkedResources.push(LinkedResource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBasePerformApiCallResponse();
        message.responseCode = (_a = object.responseCode) !== null && _a !== void 0 ? _a : ResponseCode.RESPONSE_CODE_UNSET;
        message.metadata = Object.entries((_b = object.metadata) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.body = (_c = object.body) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.userLocationUsed = (_d = object.userLocationUsed) !== null && _d !== void 0 ? _d : false;
        message.linkedResources = ((_e = object.linkedResources) === null || _e === void 0 ? void 0 : _e.map((e) => LinkedResource.fromPartial(e))) || [];
        return message;
    },
};
function createBasePerformApiCallResponse_MetadataEntry() {
    return { key: "", value: "" };
}
export const PerformApiCallResponse_MetadataEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePerformApiCallResponse_MetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePerformApiCallResponse_MetadataEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseLinkedResource() {
    return { url: "", encryptionKey: new Uint8Array() };
}
export const LinkedResource = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.encryptionKey.length !== 0) {
            writer.uint32(18).bytes(message.encryptionKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLinkedResource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.encryptionKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLinkedResource();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.encryptionKey = (_b = object.encryptionKey) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
//# sourceMappingURL=remote_api_service.js.map