{"version":3,"file":"FunctionSource.js","sourceRoot":"","sources":["../../src/media-sources/FunctionSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { LensCore } from \"../lens-core-module\";\nimport { CameraKitSource, CameraKitSourceOptions, CameraKitSourceSubscriber } from \"./CameraKitSource\";\n\nconst getYUVImageData = async (canvas: HTMLCanvasElement, lensCore: LensCore): Promise<ImageData> => {\n    const { width, height } = canvas;\n    // A YUV buffer has lower-res UV channels, so the total number of bytes works out like so:\n    const outputBuffer = new ArrayBuffer((width * height * 3) / 2);\n    await lensCore.imageToYuvBuffer({ image: canvas, width, height, outputBuffer });\n    const pixels = new Uint8ClampedArray(outputBuffer);\n    return new ImageData(pixels, width, height);\n};\n\nconst getRGBImageData = (output: HTMLCanvasElement, imageReader2D: CanvasRenderingContext2D | null): ImageData => {\n    if (imageReader2D === null) return new ImageData(0, 0);\n    imageReader2D.drawImage(output, 0, 0);\n    return imageReader2D.getImageData(0, 0, output.width, output.height);\n};\n\nconst getImageBitmap = async (imageData: ImageData, format: FrameFormat): Promise<ImageBitmap> => {\n    switch (format) {\n        case \"nv12\":\n        case \"yuv\":\n            if (!window.VideoFrame)\n                return Promise.reject(\n                    new Error(`Cannot process frame. ImageData in ${format} is not supported by this browser.`)\n                );\n            const frame = new VideoFrame(imageData.data.buffer, {\n                format: \"NV12\",\n                codedWidth: imageData.width,\n                codedHeight: imageData.height,\n                timestamp: 0,\n            });\n            return createImageBitmap(frame);\n        case \"rgb\":\n            return createImageBitmap(imageData);\n    }\n};\n\n/** @internal */\nexport type FrameFormat = \"rgb\" | \"yuv\" | \"nv12\";\n\n/** @internal */\nexport interface FrameInput {\n    format?: FrameFormat;\n    imageData: ImageData;\n    timestampMillis: number;\n}\n\n/** @internal */\nexport interface FrameOutput {\n    live: ImageData;\n    capture: ImageData;\n}\n\n/** @internal */\nexport interface MediaSourceFunction {\n    (render: (frame: FrameInput) => Promise<FrameOutput>): Promise<void>;\n}\n\n/**\n * Creates a {@link CameraKitSource} from a function which provides per-frame pixel data to CameraKit.\n *\n * @param sourceFunction This function will be called in a requestAnimationFrame loop. Each time it is called, it is\n * passed a `render` function. It may call `render` and CameraKit will process the pixel data passed to `render` and\n * return a Promise of the processed pixels (along with rendering them to the normal output canvases).\n * @param options\n * @param options.cameraType By default we set this to 'user', which is the camera type most Lenses expect.\n *\n * @internal\n */\nexport const createFunctionSource = (\n    sourceFunction: MediaSourceFunction,\n    options: Omit<CameraKitSourceOptions, \"fpsLimit\"> = {}\n): CameraKitSource => {\n    let width = 0;\n    let height = 0;\n    let shouldProcessFrame = true;\n\n    // We require an auxiliary canvas that we can use to read back pixel data (unless we're in YUV mode, in which case\n    // we use LensCore to convert between formats and we don't need this canvas).\n    const imageReaderCanvas = document.createElement(\"canvas\");\n    const imageReader2D = imageReaderCanvas.getContext(\"2d\");\n\n    const subscriber: CameraKitSourceSubscriber = {\n        onAttach: (source, lensCore, reportError) => {\n            const outputs = lensCore.getOutputCanvases();\n            const output = {\n                live: outputs[lensCore.CanvasType.Preview.value],\n                capture: outputs[lensCore.CanvasType.Capture.value],\n            };\n\n            const processFrame = (source: CameraKitSource, lensCore: LensCore, reportError: (error: Error) => void) =>\n                requestAnimationFrame(async () => {\n                    if (!shouldProcessFrame) return;\n                    try {\n                        await sourceFunction(({ format, imageData, timestampMillis }) => {\n                            // TODO: with processFrame promisified, we don't really need to create a wrapper promise\n                            const frameOutput = new Promise<FrameOutput>(async (resolve, reject) => {\n                                const inputFrame = await getImageBitmap(imageData, format ?? \"rgb\");\n                                if (inputFrame.width !== width || inputFrame.height !== height) {\n                                    width = imageReaderCanvas.width = inputFrame.width;\n                                    height = imageReaderCanvas.height = inputFrame.height;\n                                    // We don't await this promise, because we want to continue to process frames and\n                                    // let LensCore manage the concurrency between setting resolution and processing a\n                                    // frame.\n                                    source.setRenderSize(width, height);\n                                }\n                                lensCore\n                                    .processFrame({ inputFrame, timestampMillis })\n                                    .then(async () => {\n                                        // Closing releases graphics resources associated with the frame, now that is\n                                        // has been processed.\n                                        inputFrame.close();\n\n                                        switch (format ?? \"rgb\") {\n                                            case \"nv12\":\n                                            case \"yuv\":\n                                                const [live, capture] = await Promise.all([\n                                                    getYUVImageData(output.live, lensCore),\n                                                    getYUVImageData(output.capture, lensCore),\n                                                ]).catch((error) => {\n                                                    reject(error);\n                                                    return [undefined, undefined] as const;\n                                                });\n                                                // if either of these is undefined, we'll have already rejected\n                                                // the promise, so we can return.\n                                                if (!live || !capture) return;\n                                                return resolve({ live, capture });\n                                            case \"rgb\":\n                                                return resolve({\n                                                    live: getRGBImageData(output.live, imageReader2D),\n                                                    capture: getRGBImageData(output.capture, imageReader2D),\n                                                });\n                                        }\n                                    })\n                                    .catch((error) => {\n                                        inputFrame.close();\n                                        reject(error);\n                                    });\n                            });\n                            // Even if there's an error processing the frame, we do want to attempt to process the next\n                            // frame. We expect `sourceFunction` to handle a rejected `frameOutput` Promise.\n                            frameOutput.finally(() => processFrame(source, lensCore, reportError));\n                            return frameOutput;\n                        });\n                    } catch (error) {\n                        reportError(\n                            new Error(\n                                \"Failure to process frame, which was not handled by the provided \" +\n                                    `MediaSourceFunction ${sourceFunction.name ?? \"anonymous\"}.`,\n                                { cause: error }\n                            )\n                        );\n                    }\n                });\n            processFrame(source, lensCore, reportError);\n        },\n        onDetach: () => {\n            shouldProcessFrame = false;\n        },\n    };\n\n    return new CameraKitSource({ useManualFrameProcessing: true }, subscriber, options);\n};\n"]}