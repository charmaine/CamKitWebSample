/* eslint-disable @typescript-eslint/member-ordering */
import { __awaiter, __decorate, __metadata } from "tslib";
import { copyDefinedProperties } from "../common/copyDefinedProperties";
import { validate } from "../common/validate";
import { Transform2D } from "../transforms";
const defaultDeviceInfo = {
    cameraType: "user",
    fpsLimit: Number.POSITIVE_INFINITY,
};
const createNotAttachedError = (message) => new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);
/**
 * This general-purpose class represents a source of media for a {@link CameraKitSession}.
 *
 * When an instance is passed to {@link CameraKitSession.setSource | CameraKitSession.setSource}, it will be "attached"
 * to the session. Later it may be "detached" from the session.
 *
 * Passing a {@link CameraKitSourceSubscriber} to the constructor allows callers to specify behavior
 * that will occur when the source is attached and detached. This can be used to e.g. update the render size.
 *
 * @category Rendering
 */
export class CameraKitSource {
    constructor(sourceInfo, subscriber = {}, deviceInfo = {}) {
        this.sourceInfo = sourceInfo;
        this.subscriber = subscriber;
        this.deviceInfo = Object.assign(Object.assign({}, defaultDeviceInfo), copyDefinedProperties(deviceInfo));
    }
    /**
     * Called by {@link CameraKitSession} when this source is set as that session's source.
     *
     * @param lensCore
     * @param reportError Calling this function will report an error back to the session.
     * @returns Rejects if any calls to LensCore or CameraKitSource.subscriber.onAttach fail.
     * @internal
     */
    attach(lensCore, reportError) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.lensCore) {
                throw new Error("Cannot attach. This CameraKitCustomSource has already been attached to " +
                    "a CameraKitSession. To re-attach, create a copy of this CameraKitCustomSource.");
            }
            this.lensCore = lensCore;
            yield lensCore.useMediaElement({
                autoplayNewMedia: false,
                autoplayPreviewCanvas: false,
                media: this.sourceInfo.media,
                pauseExistingMedia: false,
                replayTrackingData: this.sourceInfo.replayTrackingData,
                requestWebcam: false,
                startOnFrontCamera: ["user", "front"].includes(this.deviceInfo.cameraType),
                useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing,
            });
            // LensCore uses 0 to remove the limit.
            const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;
            yield lensCore.setFPSLimit({ fps });
            if (this.subscriber.onAttach)
                yield this.subscriber.onAttach(this, lensCore, reportError);
        });
    }
    copy(deviceInfo = {}) {
        return new CameraKitSource(this.sourceInfo, this.subscriber, Object.assign(Object.assign({}, this.deviceInfo), deviceInfo));
    }
    /**
     * Called by {@link CameraKitSession} when it must remove this source.
     *
     * @param reportError Calling this function will report an error back to the session.
     * @returns
     * @internal
     */
    detach(reportError) {
        if (!this.lensCore)
            return Promise.reject(createNotAttachedError("Cannot detach"));
        if (this.subscriber.onDetach)
            return this.subscriber.onDetach(reportError);
    }
    /**
     * Set the resolution used to render this source.
     *
     * Itâ€™s important to distinguish render size from display size. The size at which the output canvases are displayed
     * on a web page is determined by the CSS of the page. It is distinct from the size at which LensCore renders
     * Lenses. Performance is dominated by render size, while any display scaling can most often be thought of as free.
     *
     * If greater performance is required, a smaller render size may boost frame-rate. It does come at a cost, including
     * loss of accuracy in various tracking and computer-vision algorithms (since they'll be operating on fewer pixels).
     *
     * The size of the Live and Capture {@link RenderTarget} is always the same.
     *
     * @todo Currently it's only valid to call `setRenderSize` after `CameraKitSession.play` has been called. This
     * constraint should be removed, so callers don't have to understand the underlying LensCore state machine.
     *
     * @param width pixels
     * @param height pixels
     * @returns Promise resolves when the render size has been successfully updated.
     */
    setRenderSize(width, height) {
        if (!this.lensCore)
            return Promise.reject(createNotAttachedError("Cannot setRenderSize"));
        const target = { width, height };
        return this.lensCore.setRenderSize({ mode: "explicit", target });
    }
    /**
     * Apply a 2D transformation to the source (e.g. translation, rotation, scale).
     *
     * @param transform Specifies the 3x3 matrix describing the transformation.
     */
    setTransform(transform) {
        if (!this.lensCore)
            return Promise.reject(createNotAttachedError("Cannot setTransform"));
        const matrix = new Float32Array(transform.matrix);
        return this.lensCore.setInputTransform({ matrix });
    }
}
__decorate([
    validate,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], CameraKitSource.prototype, "setRenderSize", null);
__decorate([
    validate,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Transform2D]),
    __metadata("design:returntype", Promise)
], CameraKitSource.prototype, "setTransform", null);
//# sourceMappingURL=CameraKitSource.js.map