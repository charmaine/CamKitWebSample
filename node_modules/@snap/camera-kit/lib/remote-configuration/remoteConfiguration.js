import { from, map, mergeMap, Observable, shareReplay, take } from "rxjs";
import { configurationToken } from "../configuration";
import { Injectable } from "../dependency-injection/Injectable";
import { Namespace } from "../generated-proto/pb_schema/cdp/cof/namespace";
import { cameraKitServiceFetchHandlerFactory } from "../handlers";
import { cofHandlerFactory } from "./cofHandler";
const defaultTargetingRequest = {
    namespaces: [Namespace.LENS_CORE, Namespace.CAMERA_KIT_CORE, Namespace.LENS_CORE_CONFIG],
};
const initializeConfigRelativePath = "/com.snap.camerakit.v3.Metrics/metrics/initialization_config";
export class RemoteConfiguration {
    constructor(lensPerformance, apiHostname, cofHandler, fetchHandler) {
        const lensCluster = Promise.resolve(lensPerformance).then((lensPerformance) => {
            // `0` means no cluster could be determined. For COF, we'll omit a value in that case.
            return (lensPerformance === null || lensPerformance === void 0 ? void 0 : lensPerformance.cluster) === 0 ? undefined : lensPerformance === null || lensPerformance === void 0 ? void 0 : lensPerformance.cluster;
        });
        this.configById = from(lensCluster).pipe(
        // Note: we don't catch errors here, purposefully letting them propagate to subscribers outside this class.
        // Subscribers, having more context about the config use-case, will know better how to handle an error than
        // we do here (e.g. their logging / reporting will have more context, and they can use the error they get
        // from this Observable as a cause).
        mergeMap((lensClusterOrig4) => from(cofHandler(Object.assign(Object.assign({}, defaultTargetingRequest), { lensClusterOrig4 })))), map((result) => {
            const configById = new Map();
            result.configResults.forEach((config) => {
                var _a;
                const configsWithId = (_a = configById.get(config.configId)) !== null && _a !== void 0 ? _a : [];
                configsWithId.push(config);
                configById.set(config.configId, configsWithId);
            });
            return configById;
        }), shareReplay(1));
        this.initializationConfig = new Observable((observer) => {
            fetchHandler(`https://${apiHostname}${initializeConfigRelativePath}`)
                .then((response) => response.json())
                .then((data) => {
                observer.next(data);
                observer.complete();
            })
                .catch((err) => observer.error(err));
        }).pipe(shareReplay(1));
    }
    /**
     * COF configuration.
     */
    get(configId) {
        return this.configById.pipe(map((config) => { var _a; return (_a = config.get(configId)) !== null && _a !== void 0 ? _a : []; }));
    }
    /**
     * Configuration that is provided by Camera Kit backend.
     */
    getInitializationConfig() {
        return this.initializationConfig;
    }
    getNamespace(namespace) {
        return this.configById.pipe(map((configs) => {
            const namespaceConfigs = Array.from(configs.values())
                .filter((values) => values.some((c) => c.namespace === namespace))
                .flatMap((results) => results);
            return namespaceConfigs;
        }));
    }
}
export const remoteConfigurationFactory = Injectable("remoteConfiguration", [configurationToken, cofHandlerFactory.token, cameraKitServiceFetchHandlerFactory.token], (config, cofHandler, fetchHandler) => {
    const remoteConfig = new RemoteConfiguration(config.lensPerformance, config.apiHostname, cofHandler, fetchHandler);
    // We'll kick off remote configuration loading by subscribing (and then unsubscribing) to a dummy config value.
    // Subsequent requests for config will use the shared Observable, benefitting from this eager loading.
    remoteConfig.get("").pipe(take(1)).subscribe();
    return remoteConfig;
});
//# sourceMappingURL=remoteConfiguration.js.map