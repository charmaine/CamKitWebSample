{"version":3,"file":"cofHandler.js","sourceRoot":"","sources":["../../src/remote-configuration/cofHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { BrowserHeaders } from \"browser-headers\";\nimport { getCameraKitUserAgent } from \"../platform/cameraKitUserAgent\";\nimport { ensureError } from \"../common/errorHelpers\";\nimport { CircumstancesServiceClientImpl, GrpcWebImpl } from \"../generated-proto/pb_schema/cdp/cof/circumstance_service\";\nimport { ConfigTargetingRequest } from \"../generated-proto/pb_schema/cdp/cof/config_request\";\nimport { ConfigTargetingResponse } from \"../generated-proto/pb_schema/cdp/cof/config_response\";\nimport { ChainableHandler, HandlerChainBuilder, RequestMetadata } from \"../handlers/HandlerChainBuilder\";\nimport {\n    RequestStateEventTarget,\n    dispatchRequestCompleted,\n    dispatchRequestErrored,\n    dispatchRequestStarted,\n    requestStateEventTargetFactory,\n} from \"../handlers/requestStateEmittingHandler\";\nimport { createResponseCachingHandler, staleWhileRevalidateStrategy } from \"../handlers/responseCachingHandler\";\nimport { createRetryingHandler } from \"../handlers/retryingHandler\";\nimport { createTimeoutHandler } from \"../handlers/timeoutHandler\";\nimport { ExpiringPersistence } from \"../persistence/ExpiringPersistence\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport {\n    OperationalMetricsReporter,\n    operationalMetricReporterFactory,\n} from \"../metrics/operational/operationalMetricsReporter\";\nimport { CameraKitConfiguration, configurationToken } from \"../configuration\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\n\nexport interface Metadata {\n    [key: string]: string;\n}\n\nconst id = <Req, Res, Meta extends RequestMetadata>(h: ChainableHandler<Req, Res, Req, Res, Meta>) => h;\n\nexport const COF_REQUEST_TYPE = \"cof\";\n\nexport type CofDimensions = { requestType: typeof COF_REQUEST_TYPE };\n\n/**\n * Handler chain used to make COF requests. Uses the COF client to perform the\n * requests, with retries, timeout, and caching.\n *\n * The handler will first attempt to retrieve the COF response from cache. If it is found, the result is returned\n * immediately and the cache is updated in the background. If no response is found, a COF request is made. This request\n * will retry (with exponential backoff + jitter) for 5 seconds before returning an error to the caller.\n */\nexport const cofHandlerFactory = Injectable(\n    \"cofHandler\",\n    [configurationToken, requestStateEventTargetFactory.token, operationalMetricReporterFactory.token] as const,\n    (\n        config: CameraKitConfiguration,\n        requestStateEventTarget: RequestStateEventTarget,\n        reporter: OperationalMetricsReporter\n    ) => {\n        // We need to wrap `targetingQuery` to create a usable Handler – the main issue is that HandlerChainBuilder\n        // always adds a `signal` property to the metadata argument (second argument of the Handler), but\n        // `targetingQuery` expects the second argument to only contain headers.\n        return (\n            new HandlerChainBuilder(\n                async (\n                    request: Partial<ConfigTargetingRequest>,\n                    { signal, isSideEffect: _, ...metadata }: Metadata & RequestMetadata\n                ) => {\n                    const rpc = new GrpcWebImpl(`https://${config.apiHostname}`, {});\n                    const client = new CircumstancesServiceClientImpl(rpc);\n                    return new Promise<ConfigTargetingResponse>((resolve, reject) => {\n                        if (signal) {\n                            signal.addEventListener(\"abort\", () =>\n                                reject(new Error(\"COF request aborted by handler chain.\"))\n                            );\n                        }\n                        client\n                            .targetingQuery(\n                                request,\n                                new BrowserHeaders({\n                                    authorization: `Bearer ${config.apiToken}`,\n                                    \"x-snap-client-user-agent\": getCameraKitUserAgent(),\n                                    ...metadata,\n                                })\n                            )\n                            .then((response) => {\n                                // NOTE: in order for cache persistance to work, we need to make the object cloneable,\n                                // i.e. with no methods (it appears targetingQuery() attaches toObject() to response\n                                // object). Safety: We have to cast response object to a type that has toObject\n                                // defined, because that is indeed what generated code has:\n                                // eslint-disable-next-line max-len\n                                // https://github.sc-corp.net/Snapchat/camera-kit-web-sdk/blob/8d6b4e8bfa3717b376ab197a49972a1e410851f7/packages/web-sdk/src/generated-proto/pb_schema/cdp/cof/circumstance_service.ts#L1459\n                                delete (response as any).toObject;\n                                resolve(response);\n                            })\n                            .catch(reject);\n                    });\n                }\n            )\n                .map(\n                    id((next) => async (request, metadata) => {\n                        const dimensions: CofDimensions = { requestType: COF_REQUEST_TYPE };\n                        const { requestId } = dispatchRequestStarted(requestStateEventTarget, { dimensions });\n                        try {\n                            const response = await next(request, metadata);\n                            // TODO: We hardcode status code and sizeByte values because we do not have access to\n                            // underlying transport of configs-web.\n                            // When this ticket is done https://jira.sc-corp.net/browse/CAMKIT-2840,\n                            // we will remove this handler and benefit from existing ones.\n                            const status = 200;\n                            let sizeByte = 0;\n                            try {\n                                sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;\n                            } finally {\n                                dispatchRequestCompleted(requestStateEventTarget, {\n                                    requestId,\n                                    dimensions,\n                                    status,\n                                    sizeByte,\n                                });\n                                return response;\n                            }\n                        } catch (error) {\n                            dispatchRequestErrored(requestStateEventTarget, {\n                                requestId,\n                                dimensions,\n                                error: ensureError(error),\n                            });\n                            throw error;\n                        }\n                    })\n                )\n                // targetingQuery() always converts failed responses into errors (unlike fetch()), so we need a custom\n                // retryPredicate that retries all errors. We'll keep retrying (with backoff) for 20 seconds total\n                // elapsed time before we return an error back up the chain.\n                .map(createRetryingHandler({ retryPredicate: (r) => r instanceof Error }))\n                // API gateway has 15 seconds timeout, so we rely on that first\n                .map(createTimeoutHandler({ timeout: 20 * 1000 }))\n                .map(\n                    createResponseCachingHandler(\n                        // COF responses will be removed from cache after 1 week. Keep in mind that the\n                        // staleWhileRevalidate strategy will update the cache each time COF is requested\n                        //  – this expiration comes into play only if e.g. a user doesn't load the page\n                        // for more than a week.\n                        new ExpiringPersistence<ConfigTargetingResponse>(\n                            () => 7 * 24 * 60 * 60,\n                            new IndexedDBPersistence({ databaseName: \"COFCache\" })\n                        ),\n                        (r: Partial<ConfigTargetingRequest>) => JSON.stringify(r),\n\n                        // If we have a matching response already in cache,\n                        // we'll return it immediately and then update the cache in the background.\n                        staleWhileRevalidateStrategy({ requestType: \"cof\", reporter })\n                    )\n                ).handler\n        );\n    }\n);\n"]}