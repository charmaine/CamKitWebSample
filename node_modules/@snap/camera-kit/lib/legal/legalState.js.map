{"version":3,"file":"legalState.js","sourceRoot":"","sources":["../../src/legal/legalState.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    defineAction,\n    defineActions,\n    defineState,\n    defineStates,\n    dispatch,\n    forActions,\n    inStates,\n    StateMachine,\n} from \"@snap/state-management\";\nimport { catchError, forkJoin, from, map, merge, of, switchMap } from \"rxjs\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport {\n    LegalDocument,\n    LegalDocument_Type,\n    LegalPrompt as LegalPromptProto,\n} from \"../generated-proto/pb_schema/camera_kit/v3/legal_prompt\";\nimport { ConfigResult } from \"../generated-proto/pb_schema/cdp/cof/config_result\";\nimport { getLogger } from \"../logger/logger\";\nimport { ExpiringPersistence } from \"../persistence/ExpiringPersistence\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport { RemoteConfiguration, remoteConfigurationFactory } from \"../remote-configuration/remoteConfiguration\";\nimport { GetInitializationConfigResponse } from \"../generated-proto/pb_schema/camera_kit/v3/service\";\nimport { LegalPromptFactory, legalPromptFactory } from \"./legalPrompt\";\n\nconst logger = getLogger(\"LegalState\");\n\ntype SupportedDocumentType =\n    | LegalDocument_Type.PRIVACY_POLICY\n    | LegalDocument_Type.TERMS_OF_SERVICE\n    | LegalDocument_Type.LEARN_MORE;\n\n/**\n * We store a hash of the last accepted ToS content. This is how we determine if the user previously accepted the\n * relevant ToS.\n *\n * ToS acceptance is only valid for 12 hours. That is, if legal status is checked and the last acceptance occurred more\n * than 12 hours ago, the user must be prompted to accept again.\n */\nconst tosContentHashExpiry = 12 * 60 * 60;\nconst tosContentHashKey = \"lastAcceptedTosContentHash\";\n\nconst createLegalState = () => {\n    const states = defineStates(defineState(\"unknown\")(), defineState(\"accepted\")(), defineState(\"rejected\")());\n\n    const actions = defineActions(\n        defineAction(\"requestLegalPrompt\")(),\n        defineAction(\"accept\")<string>(),\n        defineAction(\"reject\")<string>()\n    );\n\n    return new StateMachine(actions, states, states.unknown(), (actions) => {\n        return merge(\n            actions.pipe(\n                inStates(\"unknown\"),\n                forActions(\"accept\"),\n                map(() => states.accepted())\n            ),\n            actions.pipe(\n                inStates(\"unknown\"),\n                forActions(\"reject\"),\n                map(() => states.rejected())\n            ),\n\n            // We don't treat \"rejected\" as a terminal state -- if we get another request to display the legal prompt,\n            // even though we're in the rejected state, we'll transition back to unknown and the prompt will be shown.\n            //\n            // Conversely, we do treat \"accepted\" as a terminal state -- we will not transition back to unknown or\n            // show the legal prompt if we're already in accepted state, even if we get a request to display the prompt.\n            actions.pipe(\n                inStates(\"rejected\"),\n                forActions(\"requestLegalPrompt\"),\n                map(() => states.unknown())\n            )\n        );\n    });\n};\n\nconst defaultLegalDocumentDate = new Date(\"2021-09-30T00:00:00+00:00\");\nconst defaultLegalPrompt = LegalPromptProto.fromPartial({\n    documents: [\n        LegalDocument.fromPartial({\n            type: LegalDocument_Type.PRIVACY_POLICY,\n            webUrl: \"https://values.snap.com/privacy/privacy-policy\",\n            version: \"1\",\n            timestamp: defaultLegalDocumentDate,\n        }),\n        LegalDocument.fromPartial({\n            type: LegalDocument_Type.TERMS_OF_SERVICE,\n            webUrl: \"https://snap.com/terms\",\n            version: \"1\",\n            timestamp: defaultLegalDocumentDate,\n        }),\n        LegalDocument.fromPartial({\n            type: LegalDocument_Type.LEARN_MORE,\n            webUrl: \"https://support.snapchat.com/article/camera-information-use\",\n            version: \"1\",\n            timestamp: defaultLegalDocumentDate,\n        }),\n    ],\n    // By default, we adopt a fail-open approach, which means that if COF fails,\n    // we do not display ToS for the following reasons:\n    // 1. It provides better experince for big partners with ToS disabled\n    // 2. It has minimal risk\n    disabled: true,\n});\n\nconst defaultInitConfig = GetInitializationConfigResponse.fromPartial({});\n\nconst hasAnyValue = (c: ConfigResult): c is ConfigResult & { value: { anyValue: { value: Uint8Array } } } => {\n    return c.value?.anyValue?.value instanceof Uint8Array;\n};\n\nconst getDocumentOrDefault =\n    (documents: LegalDocument[]) =>\n    <T extends SupportedDocumentType>(type: T): LegalDocument & { type: T } => {\n        return (documents.find((d) => d.type === type) ??\n            defaultLegalPrompt.documents.find((d) => d.type === type)!) as LegalDocument & { type: T };\n    };\n\nexport type LegalState = ReturnType<typeof createLegalState>;\n\n/**\n * We maintain the state of the user's acceptance of Snap's various legal documents. Other components may require that\n * the legal state be \"accepted\" before proceeding (e.g. to apply a lens).\n *\n * On page load, the legal state starts as \"unknown.\" If a request is made to determine the legal state, the following\n * business logic is implemented:\n *\n * 1. Download remote COF config value containing the legal documents + a `disabled` field to optionally skip the legal\n * requirement.\n * 2. Check for a `lastAcceptedTosContentHash` stored in IndexedDB.\n * 3. Prompt the user to accept/reject the legal documents.\n *\n *                     ┌────────────────────────────────────────────────────────┐\n *                     │       COF config value includes \"disabled: true\"       │\n *                     └────────────────────────────────────────────────────────┘\n *                                                  │\n *                                                  │\n *                           ┌────────No────────────┴────────────Yes──────────────────┐\n *                           │                                                        │\n *                           ▼                                                        │\n *        ┌────────────────────────────────────┐                                      ▼\n *        │\"lastAcceptedTosContentHash\" exists │                               ┌────────────┐\n *        └────────────────────────────────────┘                               │  Skip ToS  │\n *                           │                                                 └────────────┘\n *                           │                                                        ▲\n *        ┌─────────────No───┴───────Yes────────────┐                                 │\n *        │                                         │                                 │\n *        │                                         │                                 │\n *        ▼                                         ▼                                 │\n * ┌────────────┐              ┌────────────────────────────────────────┐             │\n * │  Show ToS  │              │  Hash of ToS content from COF matches  │             │\n * └────────────┘              │      \"lastAcceptedTosContentHash\"      │             │\n *        ▲                    └────────────────────────────────────────┘             │\n *        │                                         │                                 │\n *        │                                         │                                 │\n *        └──────────────────No─────────────────────┴───────────────────Yes───────────┘\n *\n * @internal\n */\nexport const legalStateFactory = Injectable(\n    \"legalState\",\n    [remoteConfigurationFactory.token, legalPromptFactory.token] as const,\n    (remoteConfig: RemoteConfiguration, legalPrompt: LegalPromptFactory): LegalState => {\n        const persistance = new ExpiringPersistence<string>(\n            () => tosContentHashExpiry,\n            new IndexedDBPersistence({ databaseName: \"Legal\" })\n        );\n        const getLastAcceptedTosContentHash = () =>\n            from(persistance.retrieve(tosContentHashKey).catch((error) => logger.warn(error)));\n\n        const setLastAcceptedTosContentHash = (hash: string) =>\n            persistance.store(tosContentHashKey, hash).catch((error) => logger.warn(error));\n\n        const legalState = createLegalState();\n\n        legalState.events\n            .pipe(\n                inStates(\"unknown\"),\n                forActions(\"requestLegalPrompt\"),\n                switchMap(() =>\n                    forkJoin({\n                        cofConfig: remoteConfig.get(\"CAMERA_KIT_LEGAL_PROMPT\").pipe(\n                            map((configResults) => {\n                                const config = configResults.find(hasAnyValue);\n                                if (!config) return defaultLegalPrompt;\n                                return LegalPromptProto.decode(config.value.anyValue.value);\n                            }),\n                            catchError((error) => {\n                                logger.error(error);\n                                return of(defaultLegalPrompt);\n                            })\n                        ),\n                        initConfig: remoteConfig.getInitializationConfig().pipe(\n                            catchError((error) => {\n                                logger.error(error);\n                                return of(defaultInitConfig);\n                            })\n                        ),\n                    })\n                ),\n                switchMap(({ cofConfig, initConfig }) => {\n                    // NOTE: Currently, we check two sources to determine whether ToS is disabled or not:\n                    // COF and initConfig. Legal document links are pulled only from COF (or defaults),\n                    // because initConfig has not been implemented yet. In the future, we may choose\n                    // to exclusively use initConfig, which could incorporate the COF call internally:\n                    // https://jira.sc-corp.net/browse/CAMKIT-4791\n\n                    if (initConfig.legalPrompt?.disabled) {\n                        return of(legalState.actions.accept(\"disabled\"));\n                    }\n\n                    if (cofConfig.disabled) {\n                        return of(legalState.actions.accept(\"disabled\"));\n                    }\n\n                    const documentOfType = getDocumentOrDefault(cofConfig.documents);\n                    const prompt = legalPrompt(\n                        documentOfType(LegalDocument_Type.PRIVACY_POLICY),\n                        documentOfType(LegalDocument_Type.TERMS_OF_SERVICE),\n                        documentOfType(LegalDocument_Type.LEARN_MORE),\n                        initConfig.childrenProtectionActRestricted\n                    );\n\n                    return getLastAcceptedTosContentHash().pipe(\n                        switchMap((lastAcceptedTosContentHash) => {\n                            if (prompt.contentHash === lastAcceptedTosContentHash) return of(true);\n\n                            // Delegate prompting the end-user to accept/reject the legal documents. This returns with\n                            // a Promise<boolean> indicating accept/reject.\n                            return prompt.show();\n                        }),\n                        map((didAccept) => {\n                            if (!didAccept) return legalState.actions.reject(prompt.contentHash);\n                            setLastAcceptedTosContentHash(prompt.contentHash);\n                            return legalState.actions.accept(prompt.contentHash);\n                        })\n                    );\n                }),\n                dispatch(legalState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        return legalState;\n    }\n);\n"]}