{"version":3,"file":"bootstrapCameraKit.js","sourceRoot":"","sources":["../src/bootstrapCameraKit.ts"],"names":[],"mappings":"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","sourcesContent":["import { lensRepositoryFactory } from \"./lens/LensRepository\";\nimport { Container } from \"./dependency-injection/Container\";\nimport { CameraKit, cameraKitFactory } from \"./CameraKit\";\nimport { lensCoreFactory } from \"./lens-core-module/loader/lensCoreFactory\";\nimport { Injectable } from \"./dependency-injection/Injectable\";\nimport { remoteMediaAssetLoaderFactory } from \"./lens/assets/remoteMediaAssetLoaderFactory\";\nimport { deviceDependentAssetLoaderFactory } from \"./lens/assets/deviceDependentAssetLoader\";\nimport { staticAssetLoaderFactory } from \"./lens/assets/staticAssetLoader\";\nimport { defaultFetchHandlerFactory } from \"./handlers/defaultFetchHandler\";\nimport { cameraKitServiceFetchHandlerFactory } from \"./handlers/cameraKitServiceFetchHandlerFactory\";\nimport { CameraKitBootstrapConfiguration, createCameraKitConfigurationFactory } from \"./configuration\";\nimport { PublicServices } from \"./dependency-injection/RootServices\";\nimport { PartialContainer } from \"./dependency-injection/PartialContainer\";\nimport { metricsHandlerFactory } from \"./metrics/metricsHandler\";\nimport { operationalMetricReporterFactory } from \"./metrics/operational/operationalMetricsReporter\";\nimport { lensSourcesFactory } from \"./extensions/LensSources\";\nimport { uriHandlersFactory } from \"./extensions/UriHandlers\";\nimport { assert } from \"./common/assertions\";\nimport { isSafeString } from \"./common/typeguards\";\nimport { metricsEventTargetFactory } from \"./metrics/metricsEventTarget\";\nimport { reportGloballyScopedMetrics } from \"./metrics/reporters/reporters\";\nimport { getLogger } from \"./logger/logger\";\nimport { logEntriesFactory } from \"./logger/logEntries\";\nimport { assertPlatformSupported } from \"./platform/assertPlatformSupported\";\nimport { lensPersistenceStoreFactory } from \"./lens/LensPersistenceStore\";\nimport { remoteConfigurationFactory } from \"./remote-configuration/remoteConfiguration\";\nimport { lensAssetRepositoryFactory } from \"./lens/assets/LensAssetRepository\";\nimport { legalStateFactory } from \"./legal/legalState\";\nimport { legalPromptFactory } from \"./legal/legalPrompt\";\nimport { bootstrapError, ConfigurationError, configurationError, PlatformNotSupportedError } from \"./namedErrors\";\nimport { businessEventsReporterFactory } from \"./metrics/businessEventsReporter\";\nimport { reportGlobalException } from \"./metrics/reporters/reportGlobalException\";\nimport { registerLogEntriesSubscriber } from \"./logger/registerLogEntriesSubscriber\";\nimport { requestStateEventTargetFactory } from \"./handlers/requestStateEmittingHandler\";\nimport { pageVisibilityFactory } from \"./common/pageVisibility\";\nimport { cofHandlerFactory } from \"./remote-configuration/cofHandler\";\nimport { remoteApiServicesFactory } from \"./extensions/RemoteApiServices\";\n\nconst logger = getLogger(\"bootstrapCameraKit\");\n\n// The following errors are not wrapped with BootstrapError and bubble up as is.\nconst nonWrappableErrors: [ConfigurationError[\"name\"], PlatformNotSupportedError[\"name\"]] = [\n    \"ConfigurationError\",\n    \"PlatformNotSupportedError\",\n];\n\n/**\n * Returns true if given error has to be wrapped with BoostrapError.\n */\nfunction shouldWrapError(error: unknown): boolean {\n    if (error instanceof Error) {\n        return !nonWrappableErrors.some((name) => error.name === name);\n    }\n    return true;\n}\n\n/**\n * For more advanced use-cases, this DI Container holds services for which a custom implementation may be provided by\n * the application.\n *\n * @category Bootstrapping and Configuration\n */\nexport type PublicContainer = Container<PublicServices>;\n\n/**\n * Bootstrap CameraKit. This will download the WebAssembly code which powers CameraKit's rendering engine, and return\n * an instance of {@link CameraKit}.\n *\n * CameraKit must be provided with some configuration (the application's API token), and there are some additional\n * configurations which are optional.\n *\n * Descriptions of the available configurations can be found in the documentation for\n * {@link CameraKitBootstrapConfiguration}\n *\n * ---\n *\n * There is also a second, more advanced way to modify CameraKit to provide greater flexibility to support less common\n * use cases.\n *\n * This requires some knowledge of CameraKit's dependency injection system, and allows applications to provide their\n * own custom implementations of certain CameraKit components. This functionality will only be needed by applications\n * with very specific, more advanced requirements.\n *\n * @example\n * ```ts\n * // The most common way to bootstrap:\n * const cameraKit = await bootstrapCameraKit({ apiToken: myApiToken })\n *\n * // For special advanced use-cases, it is possible to provide custom implementations for certain CameraKit components.\n * const cameraKit = await bootstrapCameraKit(config, (container) => {\n *   return container.provides(myCustomRemoteMediaAssetLoaderFactory)\n * })\n * ```\n *\n * @param configuration Configure CameraKit with e.g. credentials, global resource endpoints, etc.\n * @param provide Optional function that can make modifications to CameraKit's root DI container.\n * @returns A {@link CameraKit} instance, which is the entry point to CameraKit's API.\n *\n * @throws\n *  - {@link ConfigurationError} when provided configuration object is invalid\n *  - {@link PlatformNotSupportedError} when current platform is not supported by CameraKit\n *  - {@link BootstrapError} when a failure occurs while initializing CameraKit and downloading the render engine\n * WebAssembly binary.\n *\n * @category Bootstrapping and Configuration\n */\nexport async function bootstrapCameraKit(\n    configuration: CameraKitBootstrapConfiguration,\n    provide?: (c: PublicContainer) => PublicContainer\n): Promise<CameraKit> {\n    try {\n        const startTimeMs = performance.now();\n\n        assert(isSafeString(configuration.apiToken), configurationError(\"Invalid or unsafe apiToken provided.\"));\n\n        const configurationFactory = createCameraKitConfigurationFactory(configuration);\n\n        // Public container holds services which applications can overwrite with their own implementations.\n        const defaultPublicContainer = Container.provides(configurationFactory)\n            .provides(pageVisibilityFactory)\n            .provides(defaultFetchHandlerFactory)\n            .provides(remoteMediaAssetLoaderFactory)\n            .provides(lensSourcesFactory)\n            .provides(remoteApiServicesFactory)\n            .provides(uriHandlersFactory);\n\n        const publicContainer = provide ? provide(defaultPublicContainer) : defaultPublicContainer;\n\n        // Now that the client's provide() function has completed and the configuration override is ready,\n        // we create another container to initialize the logger. This ensures that logging is available\n        // as we continue bootstrapping. We don't initialize the logger as part of the defaultPublicContainer\n        // because we don't want applications to provide their own logger implementations,\n        // and we're not interested in errors thrown by their provide() function.\n        // Below is the minimum required container to report errors to Blizzard.\n        const telemetryContainer = Container.provides(publicContainer)\n            .provides(logEntriesFactory)\n            .run(registerLogEntriesSubscriber)\n            .provides(cameraKitServiceFetchHandlerFactory)\n            .provides(requestStateEventTargetFactory)\n            .provides(metricsEventTargetFactory)\n            .provides(metricsHandlerFactory)\n            .provides(operationalMetricReporterFactory)\n            .provides(reportGlobalException)\n            .provides(cofHandlerFactory)\n            .provides(remoteConfigurationFactory)\n            .provides(legalPromptFactory)\n            .provides(legalStateFactory)\n            // We'll run a PartialContainer containing reporters for globally-scoped metrics. Running this container\n            // allows each metric reporter to initialize itself (e.g. by adding event listeners to detect when certain\n            // actions occur). This PartialContainer also includes the service which listens to locally-reported metrics\n            // and sends them to our backend.\n            .run(reportGloballyScopedMetrics)\n            .run(businessEventsReporterFactory);\n\n        // Run the exception logger so that it can subscribe to log events -- we can't use `Container.run()` because\n        // reportGlobalException is also used as a dependency by other Services (and run does not provide Services,\n        // it just runs them once).\n        telemetryContainer.get(reportGlobalException.token);\n\n        // At this point, logger is configured to report to console and Blizzard.\n\n        await assertPlatformSupported();\n\n        // LensCore is a foundational component which must be created asynchronously.\n        // But it's annoying for every consumer of LensCore to have to wait on Promise<LensCore>\n        // (which means they become async themselves). So we'll create a DI container which provides Promise<LensCore>,\n        // wait for that promise once here, then create a new DI container that just contains LensCore.\n        const lensCore = await telemetryContainer.provides(lensCoreFactory).get(lensCoreFactory.token);\n\n        const container = telemetryContainer\n            .provides(Injectable(lensCoreFactory.token, () => lensCore))\n            .provides(lensPersistenceStoreFactory)\n            .provides(deviceDependentAssetLoaderFactory)\n            .provides(staticAssetLoaderFactory)\n            .provides(lensAssetRepositoryFactory)\n            .provides(lensRepositoryFactory)\n\n            .provides(cameraKitFactory);\n        const cameraKit = container.get(cameraKitFactory.token);\n\n        const bootstrapTimeMs = performance.now() - startTimeMs;\n        const reporter = container.get(operationalMetricReporterFactory.token);\n        reporter.timer(\"bootstrap_time\", bootstrapTimeMs);\n\n        return cameraKit;\n    } catch (error) {\n        if (shouldWrapError(error)) {\n            error = bootstrapError(\"Error occurred during Camera Kit bootstrapping.\", error);\n        }\n        logger.error(error);\n        throw error;\n    }\n}\n\n/**\n * Extensions offer a way to provide custom implementations of certain parts of the CameraKit SDK.\n *\n * This enables more advanced use-cases, in which the default behavior of the SDK is substantially altered. For example,\n * replacing the default implementation that loads remote lens assets with a custom implementation that returns\n * different assets based on some business logic within the application.\n *\n * An extension is implemented as a [PartialContainer] – a collection of factory functions, each with its own\n * dependencies, which each provide some \"Service.\" A Service can be of any type, and the CameraKit SDK defines its\n * own Services, some of which can be overridden by providing a custom implementation of the type via an extension.\n *\n * Here's an example of how extensions might be used:\n * ```ts\n * import { bootstrapCameraKit, createExtension, remoteMediaAssetLoaderFactory } from '@snap/camera-kit'\n *\n * const myCustomRemoteAssetLoader = Injectable(\n *   remoteMediaAssetLoaderFactory.token,\n *   [remoteMediaAssetLoaderFactory.token] as const,\n *   (defaultLoader: AssetLoader): AssetLoader => {\n *     return async (asset, lens) => {\n *       if (lens?.id === MY_SPECIAL_LENS) {\n *         return (await fetch('my/asset.glb')).arrayBuffer()\n *       }\n *       return defaultLoader(asset, lens)\n *     }\n *   },\n * )\n *\n * const myExtension = createExtension().provides(myCustomeRemoteAssetLoader)\n * const cameraKit = bootstrapCameraKit(config, container => container.provides(myExtension))\n * ```\n *\n * This also enables greater modularity – the person/team creating the extension can do so in their own package, which\n * could be shared by many applications that all require the same functionality.\n *\n * @returns A {@link PartialContainer} which can be used to create a collection of Services, and can later be provided\n * to CameraKit's DI container during {@link bootstrapCameraKit}.\n *\n * @category Bootstrapping and Configuration\n */\nexport function createExtension(): PartialContainer {\n    return new PartialContainer({});\n}\n"]}