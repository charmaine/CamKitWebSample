import { Subject, catchError, filter, map, merge, retry, takeUntil, tap } from "rxjs";
import { forActions } from "@snap/state-management";
import { Injectable } from "../dependency-injection/Injectable";
import { RemoteApiInfo } from "../generated-proto/pb_schema/camera_kit/v3/features/remote_api_info";
import { ResponseCode, responseCodeToNumber } from "../generated-proto/pb_schema/lenses/remote_api/remote_api_service";
import { getLogger } from "../logger/logger";
import { knownAnyTypes } from "../common/any";
import { extractSchemeAndRoute } from "./UriHandlers";
// NOTE: There's potential for overloads when reporting metrics if reporting is triggered on each frame,
// (i.e., when the lens sends Remote API requests every frame).
// As of now, this isn't a concern because src/metrics/operational/operationalMetricsReporter.ts aggregates
// "count" metrics into a single metric within a batch, and the Remote API service currently
// reports only "count" metrics. For instance, if 30 metrics with the same name are generated per second,
// given the current bundle size of 100 operational metrics, there will be one metrics report approximately
// every 3.3 seconds.
// In the future, if we opt to report "histogram" or other metric types, they must be approached with caution:
// either the operationalMetricsReporter should be enhanced to aggregate such metrics,
// or the Remote API service should manage it directly.
// Mobiles ticket: https://jira.sc-corp.net/browse/CAMKIT-3092
const logger = getLogger("RemoteApiServices");
const uriResponseOkCode = 200;
const apiResponseStatusHeader = ":sc_lens_api_status";
const apiBinaryContentType = "application/octet-stream";
const statusToResponseCodeMap = {
    success: ResponseCode.SUCCESS,
    redirected: ResponseCode.REDIRECTED,
    badRequest: ResponseCode.BAD_REQUEST,
    accessDenied: ResponseCode.ACCESS_DENIED,
    notFound: ResponseCode.NOT_FOUND,
    timeout: ResponseCode.TIMEOUT,
    requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,
    serverError: ResponseCode.SERVER_ERROR,
    cancelled: ResponseCode.CANCELLED,
    proxyError: ResponseCode.PROXY_ERROR,
};
/**
 * Invokes the cancellation handler associated with the provided key and removes it from the collection of handlers.
 */
function callCancellationHandler(cancellationHandlers, ...keys) {
    var _a;
    for (const key of keys) {
        (_a = cancellationHandlers.get(key)) === null || _a === void 0 ? void 0 : _a();
        cancellationHandlers.delete(key);
    }
}
/**
 * Removes the specified lenses' metadata from the cache and invokes their cancellation callbacks.
 *
 * @param lensRequestState The state representing the lens cache.
 * @param lensIds An array of lens IDs to be removed from the cache
 * and for which the cancellation callbacks will be invoked.
 */
function handleLensApplicationEnd(lensRequestState, ...lensIds) {
    for (const lensId of lensIds) {
        const state = lensRequestState.get(lensId);
        if (state) {
            callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());
            lensRequestState.delete(lensId);
        }
    }
}
export const remoteApiServicesFactory = Injectable("remoteApiServices", () => {
    const remoteApiServices = [];
    return remoteApiServices;
});
/**
 * Provides a URI handler that searches for a match within the provided services to handle Remote API requests,
 * i.e., those whose URI starts with 'app://remote-api/performApiRequest'.
 */
export function getRemoteApiUriHandler(registeredServices, sessionState, lensState, lensRepository, reporter) {
    // Groups services by spec ID for faster lookups.
    const registeredServiceMap = new Map();
    for (const service of registeredServices) {
        const existingServices = registeredServiceMap.get(service.apiSpecId) || [];
        registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);
    }
    const uriRequests = new Subject();
    const uriCancelRequests = new Subject();
    const lensRequestState = new Map();
    const lensTurnOffEvents = lensState.events.pipe(forActions("turnedOff"), tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id)));
    const uriRequestEvents = uriRequests.pipe(map((uriRequest) => {
        var _a, _b;
        const lensId = uriRequest.lens.id;
        if (!lensRequestState.has(lensId)) {
            lensRequestState.set(lensId, {
                // Prepares a collection to store cancellation handlers.
                // A specific handler will be invoked when a cancellation request is issued by the lens.
                // All handlers will be invoked when the lens is replaced with another one or the session
                // is destroyed.
                cancellationHandlers: new Map(),
                // Parse lens metadata to obtain supported Remote API specs.
                supportedSpecIds: new Set(((_b = (_a = lensRepository.getLensMetadata(lensId)) === null || _a === void 0 ? void 0 : _a.featureMetadata) !== null && _b !== void 0 ? _b : [])
                    .filter((feature) => feature.typeUrl === knownAnyTypes.remoteApiInfo)
                    .flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds)),
            });
        }
        const requestState = lensRequestState.get(lensId);
        // Extracts the spec ID and endpoint ID from the provided Remote API request URI.
        // The given URI is expected to conform to the following specification:
        // eslint-disable-next-line max-len
        // https://docs.google.com/document/d/18fbGYDhD2N_aMTe4ZLY4QKeCSoMeJuklG28TutDzLZc/edit#bookmark=id.p2y39gwgbm4g
        const { route } = extractSchemeAndRoute(uriRequest.request.uri);
        const [specId, endpointIdWithQuery] = route.split("/").slice(2);
        const [endpointId] = endpointIdWithQuery.split("?");
        return { uriRequest, specId, endpointId, requestState };
    }), 
    // only handle requests for API spec ID that current lens supports
    filter(({ specId, requestState }) => requestState.supportedSpecIds.has(specId)), 
    // only handle requests if we have a registered service for it
    filter(({ specId }) => registeredServiceMap.has(specId)), map(({ uriRequest, specId, endpointId, requestState }) => {
        var _a;
        const dimensions = new Map([["specId", specId]]);
        reporter.count("lens_remote-api_requests", 1, dimensions);
        const remoteApiRequest = {
            apiSpecId: specId,
            body: uriRequest.request.data,
            endpointId,
            parameters: uriRequest.request.metadata,
        };
        // Looks for the first Remote API request handler.
        for (const service of (_a = registeredServiceMap.get(specId)) !== null && _a !== void 0 ? _a : []) {
            let requestHandler = undefined;
            try {
                requestHandler = service.getRequestHandler(remoteApiRequest, uriRequest.lens);
            }
            catch (_b) {
                logger.warn("Client's Remote API request handler factory threw an error.");
            }
            if (requestHandler) {
                reporter.count("lens_remote-api_handled-requests", 1, dimensions);
                let cancellationHandler = undefined;
                try {
                    // Calls client's Remote API handler to process the request.
                    cancellationHandler = requestHandler((response) => {
                        var _a;
                        reporter.count("lens_remote-api_responses", 1, dimensions);
                        const responseCode = (_a = statusToResponseCodeMap[response.status]) !== null && _a !== void 0 ? _a : ResponseCode.UNRECOGNIZED;
                        const uriResponse = {
                            code: uriResponseOkCode,
                            description: "",
                            contentType: apiBinaryContentType,
                            data: response.body,
                            metadata: Object.assign(Object.assign({}, response.metadata), { [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString() }),
                        };
                        uriRequest.reply(uriResponse);
                    });
                }
                catch (error) {
                    logger.warn("Client's Remote API request handler threw an error.");
                }
                if (typeof cancellationHandler === "function") {
                    requestState.cancellationHandlers.set(uriRequest.request.identifier, () => {
                        try {
                            cancellationHandler();
                        }
                        catch (_a) {
                            logger.warn("Client's Remote API request cancellation handler threw an error.");
                        }
                    });
                }
                break;
            }
        }
    }));
    const uriCancelRequestEvents = uriCancelRequests.pipe(tap((uriRequest) => {
        var _a;
        const cancellationHandlers = (_a = lensRequestState.get(uriRequest.lens.id)) === null || _a === void 0 ? void 0 : _a.cancellationHandlers;
        if (cancellationHandlers) {
            callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);
        }
    }));
    merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents)
        .pipe(catchError((error, sourcePipe) => {
        // The expectation is that if an error occurs, it happens in our own implementation,
        // because app callbacks are wrapped with try..catch blocks.
        // Therefore, we would like to report this error.
        logger.error(error);
        reporter.count("lens_remote-api_errors", 1);
        // Return the source pipe so that we can retry the pipe instead of just completing it.
        return sourcePipe;
    }), 
    // When the pipe completes due to an error,
    // we want to resubscribe to the original pipe to keep it alive.
    retry(), takeUntil(sessionState.events.pipe(forActions("destroy"))))
        .subscribe({
        complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys()),
    });
    return {
        uri: "app://remote-api/performApiRequest",
        handleRequest(request, reply, lens) {
            uriRequests.next({ request, reply, lens });
        },
        cancelRequest(request, lens) {
            uriCancelRequests.next({ request, lens });
        },
    };
}
//# sourceMappingURL=RemoteApiServices.js.map