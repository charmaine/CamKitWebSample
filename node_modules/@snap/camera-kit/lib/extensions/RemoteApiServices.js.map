{"version":3,"file":"RemoteApiServices.js","sourceRoot":"","sources":["../../src/extensions/RemoteApiServices.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject, catchError, filter, map, merge, retry, takeUntil, tap } from \"rxjs\";\nimport { forActions } from \"@snap/state-management\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { RemoteApiInfo } from \"../generated-proto/pb_schema/camera_kit/v3/features/remote_api_info\";\nimport { ResponseCode, responseCodeToNumber } from \"../generated-proto/pb_schema/lenses/remote_api/remote_api_service\";\nimport { LensRepository } from \"../lens\";\nimport { Lens } from \"../lens/Lens\";\nimport { LensState } from \"../session/lensState\";\nimport { SessionState } from \"../session/sessionState\";\nimport { getLogger } from \"../logger/logger\";\nimport { knownAnyTypes } from \"../common/any\";\nimport { CamelToSnakeCase, SnakeToCamelCase } from \"../common/types\";\nimport { OperationalMetricsReporter } from \"../metrics/operational/operationalMetricsReporter\";\nimport { UriCancelRequest, UriHandler, UriRequest, UriResponse, extractSchemeAndRoute } from \"./UriHandlers\";\n\n// NOTE: There's potential for overloads when reporting metrics if reporting is triggered on each frame,\n// (i.e., when the lens sends Remote API requests every frame).\n// As of now, this isn't a concern because src/metrics/operational/operationalMetricsReporter.ts aggregates\n// \"count\" metrics into a single metric within a batch, and the Remote API service currently\n// reports only \"count\" metrics. For instance, if 30 metrics with the same name are generated per second,\n// given the current bundle size of 100 operational metrics, there will be one metrics report approximately\n// every 3.3 seconds.\n// In the future, if we opt to report \"histogram\" or other metric types, they must be approached with caution:\n// either the operationalMetricsReporter should be enhanced to aggregate such metrics,\n// or the Remote API service should manage it directly.\n// Mobiles ticket: https://jira.sc-corp.net/browse/CAMKIT-3092\n\nconst logger = getLogger(\"RemoteApiServices\");\n\nconst uriResponseOkCode = 200;\nconst apiResponseStatusHeader = \":sc_lens_api_status\";\nconst apiBinaryContentType = \"application/octet-stream\";\n\nconst statusToResponseCodeMap = {\n    success: ResponseCode.SUCCESS,\n    redirected: ResponseCode.REDIRECTED,\n    badRequest: ResponseCode.BAD_REQUEST,\n    accessDenied: ResponseCode.ACCESS_DENIED,\n    notFound: ResponseCode.NOT_FOUND,\n    timeout: ResponseCode.TIMEOUT,\n    requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,\n    serverError: ResponseCode.SERVER_ERROR,\n    cancelled: ResponseCode.CANCELLED,\n    proxyError: ResponseCode.PROXY_ERROR,\n} satisfies { [Status in RemoteApiStatusInternal]: Uppercase<CamelToSnakeCase<Status>> };\n\ntype RemoteApiStatusInternal = SnakeToCamelCase<\n    Lowercase<Exclude<keyof typeof ResponseCode, \"RESPONSE_CODE_UNSET\" | \"UNRECOGNIZED\">>\n>;\n\ntype LensId = string;\ntype RequestId = string;\n\ntype UriRequestEvent = {\n    request: UriRequest;\n    reply: (response: UriResponse) => void;\n    lens: Lens;\n};\n\ntype UriCancelRequestEvent = {\n    request: UriCancelRequest;\n    lens: Lens;\n};\n\ninterface LensRequestState {\n    cancellationHandlers: Map<RequestId, RemoteApiCancelRequestHandler>;\n    supportedSpecIds: Set<string>;\n}\n\n/**\n * Invokes the cancellation handler associated with the provided key and removes it from the collection of handlers.\n */\nfunction callCancellationHandler(\n    cancellationHandlers: Map<RequestId, RemoteApiCancelRequestHandler>,\n    ...keys: RequestId[]\n) {\n    for (const key of keys) {\n        cancellationHandlers.get(key)?.();\n        cancellationHandlers.delete(key);\n    }\n}\n\n/**\n * Removes the specified lenses' metadata from the cache and invokes their cancellation callbacks.\n *\n * @param lensRequestState The state representing the lens cache.\n * @param lensIds An array of lens IDs to be removed from the cache\n * and for which the cancellation callbacks will be invoked.\n */\nfunction handleLensApplicationEnd(lensRequestState: Map<LensId, LensRequestState>, ...lensIds: LensId[]) {\n    for (const lensId of lensIds) {\n        const state = lensRequestState.get(lensId);\n        if (state) {\n            callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());\n            lensRequestState.delete(lensId);\n        }\n    }\n}\n\n/**\n * Status of a Remote API response.\n */\nexport type RemoteApiStatus = keyof typeof statusToResponseCodeMap;\n\n/**\n * Remote API request sent by a lens.\n */\nexport interface RemoteApiRequest {\n    /**\n     * Unique id of the remote API service specification.\n     */\n    apiSpecId: string;\n    /**\n     * Unique id of the remote API service endpoint requested by this request.\n     */\n    endpointId: string;\n    /**\n     * A map of named parameters associated with the request.\n     */\n    parameters: Record<string, string>;\n    /**\n     * Additional binary request payload.\n     */\n    body: ArrayBuffer;\n}\n\n/**\n * Remote API response to a request sent by a lens.\n */\nexport interface RemoteApiResponse {\n    /**\n     * Status of the response\n     */\n    status: RemoteApiStatus;\n    /**\n     * A map of named metadata associated with the response.\n     */\n    metadata: Record<string, string>;\n    /**\n     * Additional binary request payload.\n     */\n    body: ArrayBuffer;\n}\n\n/**\n * Represents a Remote API request cancellation handler function.\n */\nexport type RemoteApiCancelRequestHandler = () => void;\n\n/**\n * Represents a Remote API request handler function.\n * It is provided with a reply callback that must be invoked to send a response back to the lens.\n * The reply callback can be invoked multiple times if needed.\n * Additionally, the handler can return a cancellation callback, which is triggered when the lens cancels the request.\n */\nexport type RemoteApiRequestHandler = (\n    reply: (response: RemoteApiResponse) => void\n) => RemoteApiCancelRequestHandler | void;\n\n/**\n * Service to handle a lens Remote API request.\n */\nexport interface RemoteApiService {\n    /**\n     * Remote API spec ID(s).\n     */\n    apiSpecId: string;\n\n    /**\n     * This method is called by Camera Kit when a lens triggers a Remote API request with a corresponding spec ID.\n     * If the service can handle the request, the method returns a request handler; otherwise, it returns nothing.\n     * @param request Remote API request object.\n     * @param lens Lens that trigges the request.\n     * @returns A request handler if applicable.\n     */\n    getRequestHandler(request: RemoteApiRequest, lens: Lens): RemoteApiRequestHandler | undefined;\n}\n\nexport type RemoteApiServices = RemoteApiService[];\n\nexport const remoteApiServicesFactory = Injectable(\"remoteApiServices\", () => {\n    const remoteApiServices: RemoteApiServices = [];\n    return remoteApiServices;\n});\n\n/**\n * Provides a URI handler that searches for a match within the provided services to handle Remote API requests,\n * i.e., those whose URI starts with 'app://remote-api/performApiRequest'.\n */\nexport function getRemoteApiUriHandler(\n    registeredServices: RemoteApiService[],\n    sessionState: SessionState,\n    lensState: LensState,\n    lensRepository: LensRepository,\n    reporter: OperationalMetricsReporter\n): UriHandler {\n    // Groups services by spec ID for faster lookups.\n    const registeredServiceMap = new Map<string, RemoteApiService[]>();\n    for (const service of registeredServices) {\n        const existingServices = registeredServiceMap.get(service.apiSpecId) || [];\n        registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);\n    }\n\n    const uriRequests = new Subject<UriRequestEvent>();\n    const uriCancelRequests = new Subject<UriCancelRequestEvent>();\n    const lensRequestState = new Map<LensId, LensRequestState>();\n\n    const lensTurnOffEvents = lensState.events.pipe(\n        forActions(\"turnedOff\"),\n\n        tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id))\n    );\n\n    const uriRequestEvents = uriRequests.pipe(\n        map((uriRequest) => {\n            const lensId = uriRequest.lens.id;\n\n            if (!lensRequestState.has(lensId)) {\n                lensRequestState.set(lensId, {\n                    // Prepares a collection to store cancellation handlers.\n                    // A specific handler will be invoked when a cancellation request is issued by the lens.\n                    // All handlers will be invoked when the lens is replaced with another one or the session\n                    // is destroyed.\n                    cancellationHandlers: new Map(),\n                    // Parse lens metadata to obtain supported Remote API specs.\n                    supportedSpecIds: new Set(\n                        (lensRepository.getLensMetadata(lensId)?.featureMetadata ?? [])\n                            .filter((feature) => feature.typeUrl === knownAnyTypes.remoteApiInfo)\n                            .flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds)\n                    ),\n                });\n            }\n            const requestState = lensRequestState.get(lensId)!;\n\n            // Extracts the spec ID and endpoint ID from the provided Remote API request URI.\n            // The given URI is expected to conform to the following specification:\n            // eslint-disable-next-line max-len\n            // https://docs.google.com/document/d/18fbGYDhD2N_aMTe4ZLY4QKeCSoMeJuklG28TutDzLZc/edit#bookmark=id.p2y39gwgbm4g\n            const { route } = extractSchemeAndRoute(uriRequest.request.uri);\n            const [specId, endpointIdWithQuery] = route.split(\"/\").slice(2);\n            const [endpointId] = endpointIdWithQuery.split(\"?\");\n\n            return { uriRequest, specId, endpointId, requestState };\n        }),\n\n        // only handle requests for API spec ID that current lens supports\n        filter(({ specId, requestState }) => requestState.supportedSpecIds.has(specId)),\n\n        // only handle requests if we have a registered service for it\n        filter(({ specId }) => registeredServiceMap.has(specId)),\n\n        map(({ uriRequest, specId, endpointId, requestState }) => {\n            const dimensions = new Map([[\"specId\", specId]]);\n            reporter.count(\"lens_remote-api_requests\", 1, dimensions);\n\n            const remoteApiRequest: RemoteApiRequest = {\n                apiSpecId: specId,\n                body: uriRequest.request.data,\n                endpointId,\n                parameters: uriRequest.request.metadata,\n            };\n\n            // Looks for the first Remote API request handler.\n            for (const service of registeredServiceMap.get(specId) ?? []) {\n                let requestHandler: RemoteApiRequestHandler | undefined = undefined;\n                try {\n                    requestHandler = service.getRequestHandler(remoteApiRequest, uriRequest.lens);\n                } catch {\n                    logger.warn(\"Client's Remote API request handler factory threw an error.\");\n                }\n\n                if (requestHandler) {\n                    reporter.count(\"lens_remote-api_handled-requests\", 1, dimensions);\n\n                    let cancellationHandler: RemoteApiCancelRequestHandler | void = undefined;\n                    try {\n                        // Calls client's Remote API handler to process the request.\n                        cancellationHandler = requestHandler((response) => {\n                            reporter.count(\"lens_remote-api_responses\", 1, dimensions);\n\n                            const responseCode = statusToResponseCodeMap[response.status] ?? ResponseCode.UNRECOGNIZED;\n                            const uriResponse: UriResponse = {\n                                code: uriResponseOkCode,\n                                description: \"\",\n                                contentType: apiBinaryContentType,\n                                data: response.body,\n                                metadata: {\n                                    ...response.metadata,\n                                    [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString(),\n                                },\n                            };\n                            uriRequest.reply(uriResponse);\n                        });\n                    } catch (error) {\n                        logger.warn(\"Client's Remote API request handler threw an error.\");\n                    }\n\n                    if (typeof cancellationHandler === \"function\") {\n                        requestState.cancellationHandlers.set(uriRequest.request.identifier, () => {\n                            try {\n                                cancellationHandler!();\n                            } catch {\n                                logger.warn(\"Client's Remote API request cancellation handler threw an error.\");\n                            }\n                        });\n                    }\n\n                    break;\n                }\n            }\n        })\n    );\n\n    const uriCancelRequestEvents = uriCancelRequests.pipe(\n        tap((uriRequest) => {\n            const cancellationHandlers = lensRequestState.get(uriRequest.lens.id)?.cancellationHandlers;\n            if (cancellationHandlers) {\n                callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);\n            }\n        })\n    );\n\n    merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents)\n        .pipe(\n            catchError((error, sourcePipe) => {\n                // The expectation is that if an error occurs, it happens in our own implementation,\n                // because app callbacks are wrapped with try..catch blocks.\n                // Therefore, we would like to report this error.\n                logger.error(error);\n                reporter.count(\"lens_remote-api_errors\", 1);\n                // Return the source pipe so that we can retry the pipe instead of just completing it.\n                return sourcePipe;\n            }),\n            // When the pipe completes due to an error,\n            // we want to resubscribe to the original pipe to keep it alive.\n            retry(),\n            takeUntil(sessionState.events.pipe(forActions(\"destroy\")))\n        )\n        .subscribe({\n            complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys()),\n        });\n\n    return {\n        uri: \"app://remote-api/performApiRequest\",\n\n        handleRequest(request, reply, lens) {\n            uriRequests.next({ request, reply, lens });\n        },\n\n        cancelRequest(request, lens) {\n            uriCancelRequests.next({ request, lens });\n        },\n    };\n}\n"]}