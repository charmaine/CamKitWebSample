{"version":3,"file":"LensSources.js","sourceRoot":"","sources":["../../src/extensions/LensSources.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,MAAM,oCAAoC,CAAC;AA0BhE;;;;;GAKG;AACH,MAAM,OAAO,WAAW;IACpB;;;OAGG;IACH,MAAM,CAAC,KAAK;QACR,qEAAqE;QACrE,sDAAsD;QACtD,mBAAmB;QACnB,OAAO,IAAI,WAAW,EAAE,CAAC;IAC7B,CAAC;IAKD;;;;OAIG;IACH,YAAY,eAA4B,EAAE,MAAkB;QACxD,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACzB,CAAC;IAED;;;;;;OAMG;IACG,cAAc,CAAC,EAAE,OAAO,EAAE,MAAM,EAAwC;;;YAC1E,IAAI,MAAA,IAAI,CAAC,MAAM,0CAAE,YAAY,CAAC,OAAO,CAAC,EAAE;gBACpC,IAAI,WAAW,CAAC,MAAM,CAAC,EAAE;oBACrB,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY;wBAAE,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;iBAC1E;qBAAM,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;oBAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;iBAC9E;aACJ;YACD,OAAO,MAAA,IAAI,CAAC,eAAe,0CAAE,cAAc,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;;KACpE;CACJ;AAED,MAAM,CAAC,MAAM,kBAAkB,GAAG,UAAU,CAAC,aAAa,EAAE,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC","sourcesContent":["import { isUndefined } from \"../common/typeguards\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\n\n/**\n * A source of a lens group.\n */\nexport interface LensSource {\n    /**\n     * Whether the given source is able to load lenses of the supplied group.\n     * @param groupId Group ID to check.\n     */\n    isGroupOwner(groupId: string): boolean;\n\n    /**\n     * Returns an encoded lens object.\n     * @param lensId Lens ID to get.\n     * @param groupId Group ID the lens belongs to.\n     */\n    getLens?(lensId: string, groupId: string): Promise<ArrayBuffer>;\n\n    /**\n     * Returns encoded lens objects.\n     * @param groupId Group ID to get lenses of.\n     */\n    getLensGroup?(groupId: string): Promise<ArrayBuffer[]>;\n}\n\n/**\n * A chain of {@link LensSource} objects to be registered in Camera Kit on bootstrap. Camera Kit evaluates all\n * registered {@link LensSource} objects for a group ownership during Lens retrieval ({@link CameraKit.lenses}).\n * And if a source claims the ownership, its {@link LensSource.getLens} or {@link LensSource.getLensGroup}\n * methods are called.\n */\nexport class LensSources {\n    /**\n     * Returns empty LensSources instance.\n     * @internal\n     */\n    static empty() {\n        // NOTE: we want to keep LensSources constructor to require arguments\n        // but internally we don't need them for the base case\n        // @ts-expect-error\n        return new LensSources();\n    }\n\n    private readonly fallbackSources: LensSources | undefined;\n    private readonly source: LensSource | undefined;\n\n    /**\n     * Creates an instance of Lens sources.\n     * @param fallbackSources A fallback sources if given {@link LensSource} doesn't claim a group ownership.\n     * @param source Lens source.\n     */\n    constructor(fallbackSources: LensSources, source: LensSource) {\n        this.fallbackSources = fallbackSources;\n        this.source = source;\n    }\n\n    /**\n     * Returns envelopes of lens/groups taking into account group ownership.\n     * @internal\n     * @param groupId A group to test ownership and get lens envelopes of.\n     * @param lensId An optional lens ID to narrow envelopes down to a single lens.\n     * @returns Envelopes or undefined if not applicable.\n     */\n    async retrieveLenses({ groupId, lensId }: { groupId: string; lensId?: string }): Promise<ArrayBuffer[] | void> {\n        if (this.source?.isGroupOwner(groupId)) {\n            if (isUndefined(lensId)) {\n                if (this.source.getLensGroup) return this.source.getLensGroup(groupId);\n            } else if (this.source.getLens) {\n                return this.source.getLens(lensId, groupId).then((envelope) => [envelope]);\n            }\n        }\n        return this.fallbackSources?.retrieveLenses({ groupId, lensId });\n    }\n}\n\nexport const lensSourcesFactory = Injectable(\"lensSources\", () => LensSources.empty());\n"]}