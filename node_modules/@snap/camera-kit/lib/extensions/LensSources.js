import { __awaiter } from "tslib";
import { isUndefined } from "../common/typeguards";
import { Injectable } from "../dependency-injection/Injectable";
/**
 * A chain of {@link LensSource} objects to be registered in Camera Kit on bootstrap. Camera Kit evaluates all
 * registered {@link LensSource} objects for a group ownership during Lens retrieval ({@link CameraKit.lenses}).
 * And if a source claims the ownership, its {@link LensSource.getLens} or {@link LensSource.getLensGroup}
 * methods are called.
 */
export class LensSources {
    /**
     * Returns empty LensSources instance.
     * @internal
     */
    static empty() {
        // NOTE: we want to keep LensSources constructor to require arguments
        // but internally we don't need them for the base case
        // @ts-expect-error
        return new LensSources();
    }
    /**
     * Creates an instance of Lens sources.
     * @param fallbackSources A fallback sources if given {@link LensSource} doesn't claim a group ownership.
     * @param source Lens source.
     */
    constructor(fallbackSources, source) {
        this.fallbackSources = fallbackSources;
        this.source = source;
    }
    /**
     * Returns envelopes of lens/groups taking into account group ownership.
     * @internal
     * @param groupId A group to test ownership and get lens envelopes of.
     * @param lensId An optional lens ID to narrow envelopes down to a single lens.
     * @returns Envelopes or undefined if not applicable.
     */
    retrieveLenses({ groupId, lensId }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.source) === null || _a === void 0 ? void 0 : _a.isGroupOwner(groupId)) {
                if (isUndefined(lensId)) {
                    if (this.source.getLensGroup)
                        return this.source.getLensGroup(groupId);
                }
                else if (this.source.getLens) {
                    return this.source.getLens(lensId, groupId).then((envelope) => [envelope]);
                }
            }
            return (_b = this.fallbackSources) === null || _b === void 0 ? void 0 : _b.retrieveLenses({ groupId, lensId });
        });
    }
}
export const lensSourcesFactory = Injectable("lensSources", () => LensSources.empty());
//# sourceMappingURL=LensSources.js.map