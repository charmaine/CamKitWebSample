import { wrapLensCoreError } from "./lensCoreError";
// By using PropertiesOfKind, we can ensure a compile-time error if LensCoreModule adds a new async method,
// but we forget to update this list.
const promisifiableMethods = {
    addLens: null,
    clearAllLenses: null,
    imageToYuvBuffer: null,
    pauseCanvas: null,
    playCanvas: null,
    processAudioSampleBuffer: null,
    processFrame: null,
    removeLens: null,
    replaceLenses: null,
    setAudioParameters: null,
    setDeviceClass: null,
    setFPSLimit: null,
    setInputTransform: null,
    setOnFrameProcessedCallback: null,
    setRenderLoopMode: null,
    setRenderSize: null,
    teardown: null,
    useMediaElement: null,
    yuvBufferToBitmap: null,
};
export const createLensCore = (lensCoreModule) => {
    const customMethods = {
        initialize(input) {
            return new Promise((onSuccess, onFailure) => lensCoreModule.initialize(Object.assign(Object.assign({}, input), { exceptionHandler: input.exceptionHandler && wrapLensCoreError(input.exceptionHandler), onSuccess, onFailure: wrapLensCoreError(onFailure) })));
        },
        provideRemoteAssetsResponse(input) {
            return lensCoreModule.provideRemoteAssetsResponse(Object.assign(Object.assign({}, input), { onFailure: input.onFailure && wrapLensCoreError(input.onFailure) }));
        },
    };
    return new Proxy(lensCoreModule, {
        get: (target, property, receiver) => {
            // Handle special methods with custom implementations
            if (property in customMethods) {
                // Safety: "in" operator above ensures that property is keyof LensCoreCustomMethods
                return customMethods[property];
            }
            // All other async methods return Promises
            if (property in promisifiableMethods) {
                const method = Reflect.get(target, property, receiver);
                if (!method)
                    method;
                return (input) => new Promise((onSuccess, onFailure) => method(Object.assign(Object.assign({}, input), { onSuccess, onFailure: wrapLensCoreError(onFailure) })));
            }
            // All other kinds of properties (enums, sync methods) are unmodified.
            return Reflect.get(target, property, receiver);
        },
        // Safety: We ensured safety by defining types for both custom and promisifiable methods.
    });
};
//# sourceMappingURL=lensCore.js.map