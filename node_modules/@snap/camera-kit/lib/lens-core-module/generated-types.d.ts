/// <reference types="webxr" />
/// <reference types="dom-webcodecs" />
export type DefaultEventHandler = (...data: any[]) => void;
export type DefaultErrorHandler = (err: LensCoreError) => void;
export type LensCoreEnumValue = {
    value: number;
};
export type GetOutputCanvasesOutput = Record<number, HTMLCanvasElement>;
export type SetRenderSizeInput = SetRenderSizeMatchInputResolutionInput | SetRenderSizeExplicitInput;
export type SetRemoteAssetsProviderInput = (assetDescriptor: AssetDescriptor) => void;
export type SetRemoteAssetsUploadHandlerInput = (assetUploadDescriptor: AssetUploadDescriptor) => void;
export type ContentType = "text/plain" | "text/html" | "application/json" | "application/octet-stream" | "application/x-protobuf" | "application/grpc";
export type SavePersistentStoreCallback = (id: string, data: ArrayBuffer) => void;
export type ShowHintCallback = (effectId: string, hintId: string) => void;
export type HideHintCallback = (effectId: string) => void;
export type ReceiveInstanceCallback = (instance: WebAssembly.Instance, module: WebAssembly.Module) => void;
export type AssetType = LensCoreEnumValue;
export type CanvasType = LensCoreEnumValue;
export type RenderLoopMode = LensCoreEnumValue;
export type LensApiVisibility = LensCoreEnumValue;
export type DeviceClass = LensCoreEnumValue;
export type UserDataAccess = LensCoreEnumValue;
export type InterfaceControl = LensCoreEnumValue;
export type InterfaceAction = LensCoreEnumValue;
export type ExternalMediaOrientation = LensCoreEnumValue;
export type ErrorType = LensCoreEnumValue;
export type Uri = `${string}://${string}`;
export type Dimensions = {
    width: number;
    height: number;
};
export type Size2D = {
    width: number;
    height: number;
};
export type Vec2D = {
    x: number;
    y: number;
};
export type Rect = {
    origin: Vec2D;
    size: Size2D;
};
export interface ClearAllLensesInput {
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface OnFrameProcessedParam {
    processingTimeMs: number;
}
export interface XrCapabilities {
    sixDofSupported: boolean;
    sceneDepthSupported: boolean;
}
export interface InitializeInput {
    canvas?: HTMLCanvasElement | string;
    outputResolution?: Dimensions;
    showFpsPanel?: boolean;
    shouldUseWorker?: boolean;
    onFrameProcessed?: (arg: OnFrameProcessedParam) => void;
    xrCapabilities?: XrCapabilities;
    onFailure?: DefaultErrorHandler;
    onSuccess?: DefaultEventHandler;
    exceptionHandler?: (error: LensCoreError) => void;
}
export interface PlayCanvasInput {
    type: CanvasType;
    onReady?: () => void;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface PauseCanvasInput {
    type: CanvasType;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetFpsLimitInput {
    fps: number;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetInputTransformInput {
    matrix: Float32Array | ArrayBuffer;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetOnFrameProcessedInput {
    onFrameProcessed: (arg: OnFrameProcessedParam) => void;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetRenderSizeMatchInputResolutionInput {
    mode: "matchInputResolution";
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetRenderSizeExplicitInput {
    mode: "explicit";
    target: Dimensions;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetRenderLoopInput {
    mode: RenderLoopMode;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface TeardownInput {
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultEventHandler;
}
export interface ReplayTrackingDataInput {
    buffer: Uint8Array | ArrayBuffer;
}
export interface UseMediaElementInput {
    media?: HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | MediaStream;
    requestWebcam?: boolean;
    startOnFrontCamera?: boolean;
    mirrorMedia?: boolean;
    pauseExistingMedia?: boolean;
    autoplayNewMedia?: boolean;
    autoplayPreviewCanvas?: boolean;
    useManualFrameProcessing?: boolean;
    replayTrackingData?: ReplayTrackingDataInput;
    onFailure?: DefaultErrorHandler;
    onSuccess?: DefaultEventHandler;
}
export interface UriListener {
    handleRequest: (request: UriRequest) => void;
    cancelRequest?: (request: UriCancelRequest) => void;
}
export interface UriRequest {
    uri: Uri;
    identifier: string;
    method: "GET" | "POST";
    contentType: ContentType;
    data: ArrayBuffer;
    metadata: Record<string, string>;
}
export interface UriResponse {
    code: number;
    description: string;
    contentType: ContentType;
    data: ArrayBuffer;
    metadata?: Record<string, string>;
}
export interface UriCancelRequest {
    uri: Uri;
    requestId: string;
}
export interface LensDescriptor {
    lensId: string;
    lensChecksum: string;
    lensPath?: string;
    lensDataBuffer?: Uint8Array | ArrayBuffer;
    onTurnOn?: DefaultEventHandler;
    onTurnOff?: DefaultEventHandler;
    onFirstFrameProcessed?: DefaultEventHandler;
    onResourcesLoaded?: DefaultEventHandler;
    launchData?: Uint8Array | ArrayBuffer;
    apiVisibility?: LensApiVisibility;
    publicApiUserDataAccess?: UserDataAccess;
}
export interface AddLensInput extends LensDescriptor {
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface ReplaceLensesInput {
    lenses: LensDescriptor | Array<LensDescriptor>;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface RemoveLensInput {
    lensId: string;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface AssetDescriptor {
    assetId: string;
    assetType: AssetType;
    avatarId?: string;
    effectId?: string;
    encryptionKey?: ArrayBuffer;
}
export interface AssetUploadDescriptor {
    requestId: number;
    assetId: string;
    assetType: AssetType;
    effectId: string;
    assetBuffer: ArrayBuffer;
    encryptionKey?: ArrayBuffer;
    encryptionIv?: ArrayBuffer;
    assetBatchId?: string;
}
export interface ProvideRemoteAssetsResponseInput {
    assetId: string;
    assetType: AssetType;
    assetBuffer?: ArrayBuffer;
    assetChecksum?: string;
    onFailure?: DefaultErrorHandler;
}
export interface ProvideRemoteAssetsUploadResponseInput {
    requestId: number;
    success: boolean;
    assetUrl?: string;
    assetUploadMetadata?: ArrayBuffer;
}
export interface XRInput {
    layer: XRWebGLLayer;
    binding: XRWebGLBinding;
    frame: XRFrame;
    referenceSpace: XRReferenceSpace;
}
export interface ProcessFrameInput {
    inputFrame: ImageBitmap | HTMLCanvasElement | HTMLImageElement | VideoFrame | XRInput;
    timestampMillis: number;
    renderTimestampMillis?: number;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface LensCoreError extends Error {
    otherExceptions?: Array<Error>;
    cause: {
        type: ErrorType;
        metadata?: any;
    };
}
export interface ImageToYuvBufferInput {
    image: Uint8Array | ArrayBuffer | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;
    width: number;
    height: number;
    outputBuffer?: Uint8Array | ArrayBuffer;
    onSuccess: (buffer: ArrayBuffer) => void;
    onFailure?: DefaultErrorHandler;
}
export interface YuvBufferToBitmapInput {
    buffer: Uint8Array | ArrayBuffer;
    width: number;
    height: number;
    targetWidth?: number;
    targetHeight?: number;
    preserveCanvasState?: boolean;
    allowBufferTransfer?: boolean;
    onSuccess: (bitmap: ImageBitmap) => void;
    onFailure?: DefaultErrorHandler;
}
export interface SetInterfaceControlVisibilityInput {
    effectId: string;
    interfaceControl: InterfaceControl;
    visibility: boolean;
}
export interface HandleClientInterfaceActionInput {
    effectId: string;
    interfaceControl: InterfaceControl;
    interfaceAction: InterfaceAction;
}
export interface ProvideExternalImageInput {
    data: Uint8Array | ArrayBuffer;
    orientation: ExternalMediaOrientation;
    faceRects?: Array<Rect>;
}
export interface ProvideExternalVideoInput {
    data: Uint8Array | ArrayBuffer;
    orientation: ExternalMediaOrientation;
    relStartPosition?: number;
    relEndPosition?: number;
    volume?: number;
}
export interface ScreenDimmingRequestInput {
    effectId: string;
    enabled: boolean;
}
export type ScreenDimmingRequestHandler = (config: ScreenDimmingRequestInput) => void;
export interface ClientInterfaceData {
    HeaderId?: string;
    DescriptionId?: string;
    FaceFilteringEnabled?: "0" | "1";
    FaceFilteringMultipleFaces?: "0" | "1";
    ImageEnabled?: "0" | "1";
    VideoEnabled?: "0" | "1";
}
export interface ClientInterfaceRequestInput {
    effectId: string;
    interfaceControl: InterfaceControl;
    interfaceAction: InterfaceAction;
    data: ClientInterfaceData;
}
export type ClientInterfaceRequestHandler = (config: ClientInterfaceRequestInput) => void;
export interface LensCoreConfig {
    configId: string;
    value: {
        stringValue: string;
    } | {
        boolValue: boolean;
    } | {
        intValue: number;
    } | {
        longValue: number;
    } | {
        floatValue: number;
    } | {
        anyValue: {
            typeUrl: string;
            value: Uint8Array | ArrayBuffer;
        };
    };
}
export type SetPreloadedConfigurationInput = Array<LensCoreConfig>;
export interface SetAllSoundsMutedInput {
    muted: boolean;
    fade: boolean;
}
export interface SetDeviceClassInput {
    deviceClass: DeviceClass;
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SetAudioParametersInput {
    parameters: {
        numChannels?: number;
        sampleRate?: number;
    };
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface SystemFont {
    name: string;
    data: Uint8Array | ArrayBuffer;
}
export interface SetSystemFontsInput {
    fonts: SystemFont[];
}
export interface ProcessAudioSampleBufferInput {
    input: Float32Array[] | ArrayBuffer[];
    output?: Float32Array[] | ArrayBuffer[];
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}
export interface BeginWebXrInput {
    glContext: WebGL2RenderingContext;
    requestConfig: {
        requiredFeatures?: string[];
    };
}
export interface InitialEmscriptenModule {
    mainScriptUrlOrBlob: string;
    compiledModule?: WebAssembly.Module;
    pthreadWorkerScriptUrl?: string;
    instantiateWasm?: (importObject: WebAssembly.Imports, receiveInstance: ReceiveInstanceCallback) => void;
    print?: (text: string) => void;
    printErr?: (text: string) => void;
}
export interface LensCoreModule extends InitialEmscriptenModule {
    AssetType: {
        RemoteMediaByUrl: AssetType;
        DeviceDependent: AssetType;
        Static: AssetType;
        URL: AssetType;
        BitmojiDynamicAsset: AssetType;
    };
    CanvasType: {
        None: CanvasType;
        Preview: CanvasType;
        Capture: CanvasType;
        All: CanvasType;
    };
    LensApiVisibility: {
        Dev: LensApiVisibility;
        Private: LensApiVisibility;
        Public: LensApiVisibility;
    };
    DeviceClass: {
        Undefined: DeviceClass;
        BarelyWorking: DeviceClass;
        LowEnd: DeviceClass;
        MidEnd: DeviceClass;
        HighEnd: DeviceClass;
    };
    RenderLoopMode: {
        SetTimeout: RenderLoopMode;
        RequestAnimationFrame: RenderLoopMode;
    };
    UserDataAccess: {
        Restricted: UserDataAccess;
        Unrestricted: UserDataAccess;
    };
    InterfaceControl: {
        ToggleCameraButton: InterfaceControl;
        ImagePicker: InterfaceControl;
        Hint: InterfaceControl;
        Modal: InterfaceControl;
        LinkBitmojiCallToAction: InterfaceControl;
        SnapButton: InterfaceControl;
        PlayButton: InterfaceControl;
        All: InterfaceControl;
        ExitFullScreenButton: InterfaceControl;
        MemoriesButton: InterfaceControl;
        LensAttachmentButton: InterfaceControl;
        ReverseCamera: InterfaceControl;
    };
    InterfaceAction: {
        EnableHighlight: InterfaceAction;
        DisableHighlight: InterfaceAction;
        Trigger: InterfaceAction;
        Show: InterfaceAction;
        Hide: InterfaceAction;
    };
    ExternalMediaOrientation: {
        CW0: ExternalMediaOrientation;
        CW90: ExternalMediaOrientation;
        CW180: ExternalMediaOrientation;
        CW270: ExternalMediaOrientation;
    };
    ErrorType: {
        LensDeserialization: ErrorType;
        Validation: ErrorType;
        Uncategorized: ErrorType;
        LensExecution: ErrorType;
        Abort: ErrorType;
        Uninitialized: ErrorType;
    };
    initialize: (config: InitializeInput) => void;
    processFrame: (config: ProcessFrameInput) => void;
    addLens: (config: AddLensInput) => void;
    replaceLenses: (config: ReplaceLensesInput) => void;
    removeLens: (config: RemoveLensInput) => void;
    clearAllLenses: (config: ClearAllLensesInput) => void;
    teardown: (config: TeardownInput) => void;
    useMediaElement: (config: UseMediaElementInput) => void;
    setFPSLimit: (config: SetFpsLimitInput) => void;
    setRenderLoopMode: (config: SetRenderLoopInput) => void;
    getCoreVersion: () => number;
    playCanvas: (input: PlayCanvasInput) => void;
    pauseCanvas: (input: PauseCanvasInput) => void;
    getOutputCanvases: () => GetOutputCanvasesOutput;
    setRenderSize: (input: SetRenderSizeInput) => void;
    startProfiling: () => void;
    endProfiling: () => void;
    setInputTransform: (config: SetInputTransformInput) => void;
    registerUriListener: (scheme: string, route: string, listener: UriListener) => void;
    provideUriResponse: (requestId: string, response: UriResponse) => void;
    setRemoteAssetsProvider: (provider: SetRemoteAssetsProviderInput) => void;
    provideRemoteAssetsResponse: (assetResponse: ProvideRemoteAssetsResponseInput) => void;
    setRemoteAssetsUploadHandler: (provider: SetRemoteAssetsUploadHandlerInput) => void;
    provideRemoteAssetsUploadResponse: (assetResponse: ProvideRemoteAssetsUploadResponseInput) => void;
    registerShowHintCallback: (callback: ShowHintCallback) => void;
    registerHideHintCallback: (callback: HideHintCallback) => void;
    registerSavePersistentStoreCallback: (callback: SavePersistentStoreCallback) => void;
    imageToYuvBuffer: (config: ImageToYuvBufferInput) => void;
    yuvBufferToBitmap: (config: YuvBufferToBitmapInput) => void;
    setOnFrameProcessedCallback: (config: SetOnFrameProcessedInput) => void;
    setInterfaceControlVisibility: (config: SetInterfaceControlVisibilityInput) => void;
    handleClientInterfaceAction: (config: HandleClientInterfaceActionInput) => void;
    provideExternalImage: (config: ProvideExternalImageInput) => void;
    provideExternalVideo: (config: ProvideExternalVideoInput) => void;
    setScreenDimmingRequestHandler: (callback: ScreenDimmingRequestHandler) => void;
    setClientInterfaceRequestHandler: (callback: ClientInterfaceRequestHandler) => void;
    setPreloadedConfiguration: (config: SetPreloadedConfigurationInput) => void;
    setAllSoundsMuted: (config: SetAllSoundsMutedInput) => void;
    setDeviceClass: (config: SetDeviceClassInput) => void;
    setSystemFonts: (config: SetSystemFontsInput) => void;
    setAudioParameters: (config: SetAudioParametersInput) => void;
    processAudioSampleBuffer: (config: ProcessAudioSampleBufferInput) => void;
    registerBeginWebXrHandler: (handler: ((config: BeginWebXrInput) => void) | null) => void;
    registerEndWebXrHandler: (handler: (() => void) | null) => void;
}
declare global {
    function createLensesModule(module: InitialEmscriptenModule): Promise<InitialEmscriptenModule & LensCoreModule>;
}
