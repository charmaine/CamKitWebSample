{"version":3,"file":"retryingHandler.js","sourceRoot":"","sources":["../../src/handlers/retryingHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { copyDefinedProperties } from \"../common/copyDefinedProperties\";\nimport { getLogger } from \"../logger/logger\";\nimport { ChainableHandler, Handler, RequestMetadata } from \"./HandlerChainBuilder\";\n\nconst logger = getLogger(\"retryingHandler\");\n\nconst logRetry = (responseOrError: any, sleep: number) => {\n    logger.warn(\n        `Retrying handler got failed response:`,\n        responseOrError,\n        `Waited ${sleep} millis, attempting retry now.`\n    );\n};\n\nconst sleep = (millis: number) => new Promise((resolve) => setTimeout(resolve, millis));\n\nconst randomInRange = (min: number, max: number) => Math.round(Math.random() * (max - min) + min);\n\nconst defaultOptions: RetryingHandlerOptions<unknown> = {\n    backoffMultiple: 3,\n    baseSleep: 500,\n    maxSleep: 5 * 1000,\n    maxRetries: 10,\n\n    // The Response type is very common, so our default predicate special-cases to retry all failed Responses.\n    retryPredicate: (responseOrError: unknown) => (responseOrError instanceof Response ? !responseOrError.ok : true),\n};\n\n/**\n * Returns a cloned instance of Request if the input is of that type, otherwise returns the input unchanged.\n *\n * This is necessary when attempting to retry a request.\n * It is not possible to reuse the same Request instance that has already been sent.\n */\nexport function ensureClonedRequest<T>(input: T): T {\n    return input instanceof Request ? (input.clone() as T) : input;\n}\n\nexport interface RetryingHandlerOptions<Req> {\n    /**\n     * Multiple used to increase the random backoff between attempts. Default is 3, usually doesn't need to be changed.\n     */\n    backoffMultiple: number;\n\n    /**\n     * The minimum number of milliseconds to sleep between attempts.\n     *\n     * The actual number of milliseconds slept between attempts is chosen at random.\n     */\n    baseSleep: number;\n\n    /**\n     * The maximum number of milliseconds to sleep between attempts. Note that this is not a timeout -- if multiple\n     * request attempts are made, the total request latency will be longer than this.\n     *\n     * The actual number of milliseconds slept between attempts is chosen at random.\n     */\n    maxSleep: number;\n\n    /**\n     * The maximum number of retry attempts. The initial request is not counted against this number.\n     */\n    maxRetries: number;\n\n    /**\n     * Determine if a given error is retryable. If `false` is returned, the error will be passed up to the Handler's\n     * caller and no additional retry attempts will be made.\n     */\n    retryPredicate: (responseOrError: Req | Error, retryCount: number) => boolean;\n}\n\n/**\n * Retry requests using an exponential backoff with jitter strategy.\n *\n * More about this approach to retries can be found\n * [here](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/). This implementation uses the\n * \"Decorrelated jitter\" algorithm described in that post. This offers a good tradeoff between call volume and latency,\n * and also allows for convenient configurability.\n *\n * @param options\n * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}\n */\nexport const createRetryingHandler = <Req, Res, Meta extends RequestMetadata>(\n    options: Partial<RetryingHandlerOptions<Res>> = {}\n): ChainableHandler<Req, Res, Req, Res, Meta> => {\n    const definedOptions = copyDefinedProperties(options);\n    const { backoffMultiple, baseSleep, maxSleep, maxRetries, retryPredicate } = {\n        ...defaultOptions,\n        ...definedOptions,\n    };\n    let retryCount = -1;\n\n    const jitterSleep = async (priorSleep: number) => {\n        const nextSleep = Math.min(maxSleep, randomInRange(baseSleep, priorSleep * backoffMultiple));\n        await sleep(nextSleep);\n        return nextSleep;\n    };\n\n    const makeRequestAttempt =\n        (next: Handler<Req, Res, Meta>, priorSleep = baseSleep) =>\n        async (req: Req, metadata?: Meta): Promise<Res> => {\n            retryCount++;\n\n            try {\n                const response = await next(ensureClonedRequest(req), metadata);\n                if (retryCount < maxRetries && retryPredicate(response, retryCount)) {\n                    const nextSleep = await jitterSleep(priorSleep);\n                    // The request may have been aborted while we were sleeping. In that case, we'll resolve\n                    // with the failed response. In many cases this will be ignored, because an AbortError has already\n                    // been returned to the caller of the Handler chain â€“ but this prevents us from doing\n                    // any extra work, and there may be edge cases where the caller could find the response useful.\n                    if (metadata?.signal?.aborted) return response;\n                    logRetry(response, nextSleep);\n                    return makeRequestAttempt(next, nextSleep)(req, metadata);\n                }\n                return response;\n            } catch (error) {\n                if (!(error instanceof Error)) {\n                    throw new Error(\n                        \"Invalid type caught by retrying handler. Handlers may only throw Errors. Got \" +\n                            `${JSON.stringify(error)}`\n                    );\n                }\n\n                // If the request fails because it was aborted, we assume this was done intentionally and we can stop.\n                if (error.name === \"AbortError\") throw error;\n\n                if (retryCount < maxRetries && retryPredicate(error, retryCount)) {\n                    const nextSleep = await jitterSleep(priorSleep);\n                    if (metadata?.signal?.aborted) throw error;\n                    logRetry(error, nextSleep);\n                    return makeRequestAttempt(next, nextSleep)(req, metadata);\n                }\n\n                // If no retry is to be attempted, return the error to the caller.\n                throw error;\n            }\n        };\n\n    return (next) => makeRequestAttempt(next);\n};\n"]}