import { __awaiter } from "tslib";
import { getLogger } from "../logger/logger";
const logger = getLogger("persistingHandler");
/**
 * This handler persists in-flight requests locally, so that if there is an unexpected termination of the process (e.g.
 * the browser tab crashes or is closed) those requests can be recovered and retried on the next page load.
 *
 * Keep in mind, using this handler means some *successful* requests may be repeated (e.g. if the request made it to a
 * server, which responded, but the response didn't reach the browser before the tab closed). Any handler chain making
 * use of this handler should only handle idempotent requests.
 *
 * @param persistence Requests will be temporarily stored here while they are in-flight.
 * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}
 */
export const createPersistingHandler = (persistence) => {
    let needsRecovery = true;
    const maybePerformRecovery = (next) => __awaiter(void 0, void 0, void 0, function* () {
        if (!needsRecovery)
            return;
        needsRecovery = false;
        try {
            const requests = yield persistence.removeAll();
            if (requests.length === 0)
                return;
            // If a recovered request fails, we'll report the error and prevent it from disrupting other requests. We
            // won't re-persist to avoid a poison-pill request that remains in storage forever.
            requests.forEach(([request, metadata]) => performRequest(next)(request, metadata).catch((error) => {
                logger.error(error);
            }));
            // If we fail to retrieve, we have no option but to report the error and proceed. Since we can't tell here
            // if there were any requests to recover, we cannot say if an error here will actually result in data loss.
        }
        catch (error) {
            // TODO: we will also want to report persistence size (either here or elsewhere) to detect scenarious that
            // could result in unbounded DB growth.
            logger.error(error);
        }
    });
    const performRequest = (next) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
        // If there are requests to be recovered (e.g. a prior session crashed while requests were in-flight), they will
        // be passed to the next handler in the chain. This will happen at most once per page load.
        maybePerformRecovery(next);
        // Whether the persistence succeeds or fails, we always want to make the request – so we don't need to wait for
        // the request to be stored before passing it to the `next` handler. This is why we're not awaiting the store
        // call here. We'll also swallow any errors, simply returning `null` for the key – persistence and recovery are
        // always best-effort, and failure should not disrupt other application behavior.
        const keyPromise = persistence.store([req, metadata]).catch((error) => {
            logger.error(error);
            return null;
        });
        try {
            return yield next(req, metadata);
        }
        finally {
            // We don't care if the request was successful or not, either way once it is completed we will remove
            // the request from the persistent store.
            keyPromise
                .then((key) => {
                if (key !== null)
                    return persistence.remove(key);
                return;
            })
                // If removal fails, we will recover and re-send the request – failure could occur if the OS cannot
                // complete the DB transaction (e.g. power loss), or potentially in other exceptional scenarios.
                // Therefore it's important that requests handled by this handler be idempotent.
                .catch((error) => logger.error(error));
        }
    });
    return performRequest;
};
//# sourceMappingURL=persistingHandler.js.map