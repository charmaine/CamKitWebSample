{"version":3,"file":"noCorsRetryingFetchHandler.js","sourceRoot":"","sources":["../../src/handlers/noCorsRetryingFetchHandler.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAE7C,OAAO,EAAE,mBAAmB,EAAE,MAAM,mBAAmB,CAAC;AAExD,MAAM,MAAM,GAAG,SAAS,CAAC,4BAA4B,CAAC,CAAC;AAEvD,MAAM,QAAQ,GAAG,CAAC,KAAU,EAAE,EAAE;IAC5B,MAAM,CAAC,IAAI,CAAC,6CAA6C,EAAE,KAAK,EAAE,0CAA0C,CAAC,CAAC;AAClH,CAAC,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6CG;AACH,MAAM,CAAC,MAAM,gCAAgC,GAAG,GAM9C,EAAE;IACA,+GAA+G;IAC/G,yGAAyG;IACzG,uEAAuE;IACvE,MAAM,cAAc,GAAG,IAAI,GAAG,EAAwB,CAAC;IAEvD,OAAO,CAAC,IAAI,EAAE,EAAE,CACZ,CAAO,KAAK,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE;;QACvB,sGAAsG;QACtG,oGAAoG;QACpG,uFAAuF;QACvF,IAAI,UAAU,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;QAC/D,IAAI;YACA,UAAU,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC;SAC1D;QAAC,OAAO,CAAC,EAAE;YACR,qDAAqD;SACxD;QAED,IAAI;YACA,oGAAoG;YACpG,kGAAkG;YAClG,sGAAsG;YACtG,wGAAwG;YACxG,OAAO,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;SACvD;QAAC,OAAO,KAAK,EAAE;YACZ,sGAAsG;YACtG,IAAI,KAAK,YAAY,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY;gBAAE,MAAM,KAAK,CAAC;YAEvE,iGAAiG;YACjG,mGAAmG;YACnG,wGAAwG;YACxG,oFAAoF;YACpF,QAAQ,CAAC,KAAK,CAAC,CAAC;YAChB,MAAM,aAAa,GACf,MAAA,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,mCAAI,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,kCAAO,IAAI,KAAE,IAAI,EAAE,SAAS,IAAG,CAAC;YACrG,cAAc,CAAC,GAAG,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;YAC9C,MAAM,aAAa,CAAC;YACpB,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;YAClC,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;SACjD;IACL,CAAC,CAAA,CAAC;AACV,CAAC,CAAC","sourcesContent":["import { getLogger } from \"../logger/logger\";\nimport { ChainableHandler } from \"./HandlerChainBuilder\";\nimport { ensureClonedRequest } from \"./retryingHandler\";\n\nconst logger = getLogger(\"noCorsRetryingFetchHandler\");\n\nconst logRetry = (error: any) => {\n    logger.warn(`NoCorsRetrying handler got failed response:`, error, `Retrying request with {mode: \"no-cors\"}.`);\n};\n\n/**\n * Some requests may require a no-cors pre-flight (which are allowed to follow redirects) before they can be\n * successful.\n *\n * An example is a federated identity authentication flow, like OpenID Connect or OAuth. In many such schemes,\n * an unauthenticated request will not include CORs headers. Instead, a redirect to an Identity Provider will be\n * returned. In order follow this redirect, the Fetch request must be made with \"no-cors\" mode.\n *\n * Once the \"no-cors\" request is made, redirects are followed resulting in authentication cookies being set on the\n * original domain. Then, the original request can be retried and the server will authenticate the request and set\n * proper CORs headers on the response.\n *\n * Here's an example request flow, in which the page already has cookies for IdentityProvider.com (if that wasn't\n * the case, IdentityProvider.com would prompt the user for credentials and the rest of the flow would be the same):\n *\n * ```\n * WebPage a.com        MyServer b.com    IdentityProvider c.com\n *    |                         |                 |\n * Original request,            |                 |\n * unauthenticated:             |                 |\n *    |------------------------>|                 |\n *    |<--302: c.com, no CORs---|                 |\n *    |                         |                 |\n *    |                         |                 |\n * No CORs headers in           |                 |\n * response. Retry in           |                 |\n * \"no-cors\" mode:              |                 |\n *    |-----\"no-cors\" mode----->|                 |\n *    |<--302: c.com, no CORs---|                 |\n *    |                         |                 |\n *    |                         |                 |\n *    |------------------IdP cookies------------->|\n *    |<----------302: b.com?token=foo------------|\n *                              |                 |\n *    |                         |                 |\n *    |----b.com?token=foo----->|                 |\n *    |<-302: b.com, set cookie-|                 |\n *    |                         |                 |\n *    |                         |                 |\n * Retry original request,      |                 |\n * now authenticated:           |                 |\n *    |-----------cookie------->|                 |\n *    |<-----------200----------|                 |\n *                              |                 |\n * ```\n */\nexport const createNoCorsRetryingFetchHandler = <Res>(): ChainableHandler<\n    RequestInfo,\n    Res,\n    RequestInfo,\n    Res,\n    RequestInit | undefined\n> => {\n    // If concurrent requests are made to the same domain, we only want to perform one \"no-cors\" request. We assume\n    // requests to the same domain will set the same authentication cookies. To support this, we'll store any\n    // in-flight \"no-cors\" retries and re-use them for concurrent requests.\n    const noCorsRequests = new Map<string, Promise<Res>>();\n\n    return (next) =>\n        async (input, init = {}) => {\n            // `host` includes domain:port, so works for local development. If the input is a relative path, we'll\n            // use `location.origin` to resolve into a fully qualified URL (although of course we don't actually\n            // anticipate any CORs issues in that case -- but this is cleaner than special-casing).\n            let requestKey = typeof input === \"string\" ? input : input.url;\n            try {\n                requestKey = new URL(requestKey, location.origin).host;\n            } catch (_) {\n                /* no-op, use the full input URL as the requestKey */\n            }\n\n            try {\n                // By always attempting the request first, we avoid needing to maintain any state about the validity\n                // of the request (e.g. the expiration time for a credential). We just make the request, and if it\n                // fails, this tells us we've made an invalid request. This does result in one additional request, but\n                // it makes this much more flexible and avoids having to maintain state (which can be a source of bugs).\n                return await next(ensureClonedRequest(input), init);\n            } catch (error) {\n                // If the request fails because it was aborted, we assume this was done intentionally and we can stop.\n                if (error instanceof Error && error.name === \"AbortError\") throw error;\n\n                // Otherwise we don't actually care what error occurred â€“ we know this will be an error thrown by\n                // `fetch` itself (rather than some error encountered on the server, which wouldn't cause `next` to\n                // throw), and we'll just assume it's a CORs error. If it's not, we'll perform a \"no-cors\" retry anyway,\n                // which will presumably also fail, and that failure will be returned to the caller.\n                logRetry(error);\n                const noCorsRequest =\n                    noCorsRequests.get(requestKey) ?? next(ensureClonedRequest(input), { ...init, mode: \"no-cors\" });\n                noCorsRequests.set(requestKey, noCorsRequest);\n                await noCorsRequest;\n                noCorsRequests.delete(requestKey);\n                return next(ensureClonedRequest(input), init);\n            }\n        };\n};\n"]}