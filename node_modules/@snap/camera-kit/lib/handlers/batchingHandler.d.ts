import { PageVisibility } from "../common/pageVisibility";
import { ChainableHandler, RequestMetadata } from "./HandlerChainBuilder";
export interface BatchingHandlerOptions<Req, BatchReq> {
    batchReduce: (batch: BatchReq | undefined, req: Req) => BatchReq | Promise<BatchReq>;
    isBatchComplete: (batch: BatchReq) => boolean;
    maxBatchAge?: number;
    /**
     * Determines whether to flush buffered requests when the page becomes hidden.
     * `false` value indicates that page visibility handling is avoided, while
     * a {@link PageVisibility} instance is used to subscribe to page visibility change events.
     */
    pageVisibility: PageVisibility | false;
}
/**
 * Accumulate requests into batches, which are then sent to the next handler in the chain. Batches are sent when either:
 * - the given `isBatchComplete` function returns true, closing the current batch and sending it down the chain.
 * - an optional `maxBatchAge` time has elapsed since the first request in the batch was received.
 * - the page terminates.
 *
 * When handling a request, the Promise returned will resolve when that request has been successfully added to the
 * current batch â€“ **NOT** when that batch has been successfully processed by the rest of the handler chain.
 *
 * The `next` handler in the chain will receive the batch and should handle any errors arising from further processing
 * on the batch (e.g. sending it to a server).
 *
 * **Note:** This handler does not support aborting handled requests via AbortSignal.
 *
 * @param options
 * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}
 */
export declare const createBatchingHandler: <Req, BatchReq, BatchRes, Meta extends RequestMetadata>({ batchReduce, isBatchComplete, maxBatchAge, pageVisibility, }: BatchingHandlerOptions<Req, BatchReq>) => ChainableHandler<Req, void, BatchReq, BatchRes, Meta>;
