{"version":3,"file":"responseCachingHandler.js","sourceRoot":"","sources":["../../src/handlers/responseCachingHandler.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,EAAE,qBAAqB,EAAE,MAAM,gBAAgB,CAAC;AACvD,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAK7C,MAAM,MAAM,GAAG,SAAS,CAAC,wBAAwB,CAAC,CAAC;AACnD,MAAM,QAAQ,GAAG,CAAC,GAAa,EAAE,EAAE,CAAC,qBAAqB,CAAC,oBAAoB,GAAG,sBAAsB,CAAC,CAAC;AACzG,MAAM,cAAc,GAAG,CAAC,GAAa,EAAE,KAAe,EAAE,EAAE,CACtD,IAAI,KAAK,CAAC,4CAA4C,GAAG,eAAe,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;AAQzF;;;GAGG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAC7B,GAA0B,EAAE,CAC5B,CAAO,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE;IAC1B,IAAI;QACA,MAAM,QAAQ,GAAG,MAAM,OAAO,EAAE,CAAC;QACjC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YACvC,MAAM,CAAC,IAAI,CAAC,4CAA4C,GAAG,GAAG,EAAE,KAAK,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;KACnB;IAAC,OAAO,YAAY,EAAE;QACnB,IAAI;YACA,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACjD,IAAI,CAAC,cAAc;gBAAE,MAAM,QAAQ,CAAC,GAAG,CAAC,CAAC;YACzC,MAAM,CAAC,KAAK,CACR,gEAAgE,GAAG,uBAAuB,EAC1F,YAAY,CACf,CAAC;YACF,OAAO,cAAc,CAAC;SACzB;QAAC,OAAO,UAAU,EAAE;YACjB,MAAM,KAAK,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC;YACtC,KAAK,CAAC,KAAK,GAAG,YAAY,CAAC;YAC3B,MAAM,cAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SACpC;KACJ;AACL,CAAC,CAAA,CAAC;AASN;;;;GAIG;AACH,MAAM,CAAC,MAAM,4BAA4B,GACrC,CAAI,OAAqC,EAAsB,EAAE,CACjE,CAAO,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE;IAC1B,IAAI;QACA,MAAM,cAAc,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACjD,IAAI,CAAC,cAAc;YAAE,MAAM,QAAQ,CAAC,GAAG,CAAC,CAAC;QAEzC,uGAAuG;QACvG,2GAA2G;QAC3G,sGAAsG;QACtG,qGAAqG;QACrG,8BAA8B;QAC9B,OAAO,CAAC,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;aAC1B,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;aAC9C,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YACb,MAAM,CAAC,IAAI,CAAC,iEAAiE,GAAG,GAAG,EAAE,KAAK,CAAC,CAAC;QAChG,CAAC,CAAC,CAAC;QACP,OAAO,cAAc,CAAC;KACzB;IAAC,OAAO,UAAU,EAAE;QACjB,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC,cAAc,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3F,IAAI;YACA,MAAM,QAAQ,GAAG,MAAM,OAAO,EAAE,CAAC;YACjC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACvC,MAAM,CAAC,IAAI,CAAC,oDAAoD,GAAG,GAAG,EAAE,KAAK,CAAC,CAAC;YACnF,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,KAAK,CACR,0EAA0E,GAAG,qBAAqB,EAClG,UAAU,CACb,CAAC;YACF,OAAO,QAAQ,CAAC;SACnB;QAAC,OAAO,YAAY,EAAE;YACnB,MAAM,KAAK,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;YACxC,KAAK,CAAC,KAAK,GAAG,UAAU,CAAC;YACzB,MAAM,cAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SACpC;KACJ;AACL,CAAC,CAAA,CAAC;AAEN;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,MAAM,4BAA4B,GAAG,CACxC,KAAuB,EACvB,UAAuD,EACvD,QAA8B,EACY,EAAE;IAC5C,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAO,OAAO,EAAE,QAAQ,EAAE,EAAE;QACzC,MAAM,OAAO,GAAG,CAAC,qBAAsC,EAAE,EAAE,EAAE;YACzD,MAAM,CAAC,GAAG,gCAAK,QAAQ,GAAK,kBAAkB,CAAU,CAAC;YACzD,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAC5B,CAAC,CAAC;QAEF,IAAI,GAAa,CAAC;QAClB,IAAI;YACA,GAAG,GAAG,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SACvC;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,CAAC,IAAI,CAAC,kEAAkE,EAAE,KAAK,CAAC,CAAC;YACvF,OAAO,OAAO,EAAE,CAAC;SACpB;QACD,OAAO,QAAQ,CAAC,GAAG,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACzC,CAAC,CAAA,CAAC;AACN,CAAC,CAAC","sourcesContent":["import { ensureError } from \"../common/errorHelpers\";\nimport { cacheKeyNotFoundError } from \"../namedErrors\";\nimport { getLogger } from \"../logger/logger\";\nimport { Persistence, ValidKey } from \"../persistence/Persistence\";\nimport { OperationalMetricsReporter } from \"../metrics/operational/operationalMetricsReporter\";\nimport { ChainableHandler, RequestMetadata } from \"./HandlerChainBuilder\";\n\nconst logger = getLogger(\"responseCachingHandler\");\nconst notFound = (key: ValidKey) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);\nconst strategyFailed = (key: ValidKey, cause?: unknown) =>\n    new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });\n\nexport type CachingStrategy<T> = (\n    key: ValidKey,\n    cache: Persistence<T>,\n    network: (metadata?: RequestMetadata) => Promise<T>\n) => Promise<T>;\n\n/**\n * Create a CachingStrategy that first makes a request to the network, falling back to cache if the network request\n * fails. If the network request fails and a prior response has not been cached, an error is returned to the caller.\n */\nexport const staleIfErrorStrategy =\n    <T>(): CachingStrategy<T> =>\n    async (key, cache, network) => {\n        try {\n            const response = await network();\n            cache.store(key, response).catch((error) => {\n                logger.warn(`staleIfErrorStrategy failed to store key ${key}.`, error);\n            });\n            return response;\n        } catch (networkError) {\n            try {\n                const cachedResponse = await cache.retrieve(key);\n                if (!cachedResponse) throw notFound(key);\n                logger.debug(\n                    `staleIfErrorStrategy successfully fell back to cache for key ${key} after network error.`,\n                    networkError\n                );\n                return cachedResponse;\n            } catch (cacheError) {\n                const error = ensureError(cacheError);\n                error.cause = networkError;\n                throw strategyFailed(key, error);\n            }\n        }\n    };\n\n/**\n * If provided these options allow staleWhileRevalidateStrategy to report cache_miss metrics.\n */\nexport interface StaleWhileRevalidateOptions {\n    requestType: string;\n    reporter: OperationalMetricsReporter;\n}\n/**\n * Create a CachingStrategy that first does a cache lookup â€“ if the response is found in cache, it is returned and the\n * entry is updated with a request to the network in the background. If no cached response is found, the network request\n * is made, the result cached and returned to the caller.\n */\nexport const staleWhileRevalidateStrategy =\n    <T>(options?: StaleWhileRevalidateOptions): CachingStrategy<T> =>\n    async (key, cache, network) => {\n        try {\n            const cachedResponse = await cache.retrieve(key);\n            if (!cachedResponse) throw notFound(key);\n\n            // By specifying isSideEffect: true, the handler chain allows the network handler to run to completion,\n            // even though we return an immediate response from the cache. In the typical use-case, once a response has\n            // resolved, any ongoing handlers are aborted because the handler chain knows their result will not be\n            // used -- but here, the network handler is run as a side-effect to update the cache after the cached\n            // response has been resolved.\n            network({ isSideEffect: true })\n                .then((response) => cache.store(key, response))\n                .catch((error) => {\n                    logger.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);\n                });\n            return cachedResponse;\n        } catch (cacheError) {\n            options?.reporter.count(\"cache_miss\", 1, new Map([[\"request_type\", options.requestType]]));\n            try {\n                const response = await network();\n                cache.store(key, response).catch((error) => {\n                    logger.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);\n                });\n                logger.debug(\n                    `staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`,\n                    cacheError\n                );\n                return response;\n            } catch (networkError) {\n                const error = ensureError(networkError);\n                error.cause = cacheError;\n                throw strategyFailed(key, error);\n            }\n        }\n    };\n\n/**\n * Create a Handler capable of caching responses using various caching strategies.\n *\n * More than one caching strategy can be provided, and they will be composed into a single strategy. For example, an\n * expiringStrategy could be composed with a staleIfErrorStrategy so that responses\n *\n * @param cache A Persistence instance capable of storing responses.\n * @param resolveKey This function is called once for each request, and must return a valid persistence key\n * corresponding uniquely to that request.\n * @param strategy A CachingStrategy used to determine when to retrieve from cache vs. request from the network.\n * @returns\n */\nexport const createResponseCachingHandler = <Req, Res, Meta extends RequestMetadata>(\n    cache: Persistence<Res>,\n    resolveKey: (request: Req, metadata?: Meta) => ValidKey,\n    strategy: CachingStrategy<Res>\n): ChainableHandler<Req, Res, Req, Res, Meta> => {\n    return (next) => async (request, metadata) => {\n        const network = (additionalMetadata: RequestMetadata = {}) => {\n            const m = { ...metadata, ...additionalMetadata } as Meta;\n            return next(request, m);\n        };\n\n        let key: ValidKey;\n        try {\n            key = resolveKey(request, metadata);\n        } catch (error) {\n            logger.warn(\"Cache lookup failed because the cache key could not be resolved.\", error);\n            return network();\n        }\n        return strategy(key, cache, network);\n    };\n};\n"]}