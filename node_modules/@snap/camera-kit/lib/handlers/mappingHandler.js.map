{"version":3,"file":"mappingHandler.js","sourceRoot":"","sources":["../../src/handlers/mappingHandler.ts"],"names":[],"mappings":";AASA;;;;;;;;;;;;;;;GAeG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAChC,GAAqD,EACrD,cAAsC,EACtC,oBAA4B,MAAM,CAAC,iBAAiB,EACJ,EAAE;IAClD,MAAM,MAAM,GAAiC,EAAE,CAAC;IAChD,IAAI,cAAc,GAAG,CAAC,CAAC;IAEvB,MAAM,cAAc,GAAG,CAAO,OAAmC,EAAE,EAAE;QACjE,IAAI;YACA,cAAc,EAAE,CAAC;YACjB,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;YAC7B,0GAA0G;YAC1G,wGAAwG;YACxG,wGAAwG;YACxG,gFAAgF;YAChF,IAAI,MAAM,YAAY,OAAO;gBAAE,OAAO,CAAC,IAAI,CAAC,MAAM,MAAM,CAAC,CAAC;iBACrD,IAAI,MAAM;gBAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACzC;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACzB;gBAAS;YACN,cAAc,EAAE,CAAC;SACpB;QACD,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,cAAc,GAAG,iBAAiB,EAAE;YAC5D,iGAAiG;YACjG,cAAc,CAAC,MAAM,CAAC,KAAK,EAAG,CAAC,CAAC;SACnC;IACL,CAAC,CAAA,CAAC;IAEF,8GAA8G;IAC9G,sGAAsG;IACtG,IAAI,cAAc,EAAE;QAChB,cAAc,CAAC,YAAY,CAAC,GAAG,EAAE;YAC7B,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC;gBAAE,cAAc,CAAC,MAAM,CAAC,KAAK,EAAG,CAAC,CAAC;QAC9D,CAAC,CAAC,CAAC;KACN;IAED,OAAO,CAAC,IAAmC,EAAE,EAAE,CAAC,CAAC,OAAY,EAAE,QAAe,EAAE,EAAE;QAC9E,OAAO,IAAI,OAAO,CAAM,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACxC,MAAM,eAAe,GAA+B;gBAChD,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC;gBACvB,IAAI,EAAE,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC;gBAClF,MAAM;aACT,CAAC;YACF,IAAI,cAAc,GAAG,iBAAiB;gBAAE,cAAc,CAAC,eAAe,CAAC,CAAC;;gBACnE,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC,CAAC;AACN,CAAC,CAAC","sourcesContent":["import { PageVisibility } from \"../common/pageVisibility\";\nimport { ChainableHandler, Handler, RequestMetadata } from \"./HandlerChainBuilder\";\n\ninterface MappableRequest<T> {\n    map: () => T | Promise<T>;\n    next: (request: T) => Promise<void>;\n    reject: (reason: unknown) => void;\n}\n\n/**\n * Map from one request type to another, potentially asynchronously.\n *\n * **NOTE:** If `maxMapConcurrency` is set to some finite number, and more requests are handled than are allowed to\n * be concurrently mapped, the waiting requests will be placed into a unbounded buffer. If, for example, requests are\n * handled with high frequency, `maxMapConcurrency` is low, and the `map` function returns a long-running Promise, this\n * buffer could use a large amount of memory. Keep this in mind when using this handler.\n *\n * @param map Transform each request, may be sync or async.\n * @param pageVisibility Determines whether to flush buffered requests when the page becomes hidden.\n * `false` value indicates that page visibility handling is avoided, while\n * a {@link PageVisibility} instance is used to subscribe to page visibility change events.\n * @param maxMapConcurrency If the `map` function is async, it will be invoked at most this number of times\n * concurrently. Setting this to 1 could be useful if it's important for `map` to be called in serial.\n * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}\n */\nexport const createMappingHandler = <Req, MappedReq, Res, Meta extends RequestMetadata>(\n    map: (request: Req) => MappedReq | Promise<MappedReq>,\n    pageVisibility: PageVisibility | false,\n    maxMapConcurrency: number = Number.POSITIVE_INFINITY\n): ChainableHandler<Req, Res, MappedReq, Res, Meta> => {\n    const buffer: MappableRequest<MappedReq>[] = [];\n    let mapConcurrency = 0;\n\n    const processRequest = async (request: MappableRequest<MappedReq>) => {\n        try {\n            mapConcurrency++;\n            const mapped = request.map();\n            // We want to make sure that if the mapping operation is not async, we don't introduce asynchronicity here\n            // (which unfortunately happens even if you `await` a non-Promise value). This is important so that e.g.\n            // handlers which run when the page is terminated can send requests synchronously, since the browser may\n            // not pick up any async handlers registered to run on the following event loop.\n            if (mapped instanceof Promise) request.next(await mapped);\n            else if (mapped) request.next(mapped);\n        } catch (error) {\n            request.reject(error);\n        } finally {\n            mapConcurrency--;\n        }\n        while (buffer.length > 0 && mapConcurrency < maxMapConcurrency) {\n            // Safety: we just checked for `buffer.length > 0`, so the shifted value will never be undefined.\n            processRequest(buffer.shift()!);\n        }\n    };\n\n    // This may indicate that the page is being unloaded, in which case we may want to flush any buffered requests\n    // regardless of our max concurrency â€“ otherwise those requests will be lost when the page terminates.\n    if (pageVisibility) {\n        pageVisibility.onPageHidden(() => {\n            while (buffer.length > 0) processRequest(buffer.shift()!);\n        });\n    }\n\n    return (next: Handler<MappedReq, Res, Meta>) => (request: Req, metadata?: Meta) => {\n        return new Promise<Res>((resolve, reject) => {\n            const mappableRequest: MappableRequest<MappedReq> = {\n                map: () => map(request),\n                next: (mappedRequest) => next(mappedRequest, metadata).then(resolve).catch(reject),\n                reject,\n            };\n            if (mapConcurrency < maxMapConcurrency) processRequest(mappableRequest);\n            else buffer.push(mappableRequest);\n        });\n    };\n};\n"]}