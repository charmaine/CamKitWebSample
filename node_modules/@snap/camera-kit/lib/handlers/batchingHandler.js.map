{"version":3,"file":"batchingHandler.js","sourceRoot":"","sources":["../../src/handlers/batchingHandler.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAcxD;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAwD,EACzF,WAAW,EACX,eAAe,EACf,WAAW,EACX,cAAc,GACsB,EAAyD,EAAE;IAC/F,mHAAmH;IACnH,kHAAkH;IAClH,oDAAoD;IACpD,IAAI,YAA2C,CAAC;IAChD,IAAI,YAAY,GAAyB,SAAS,CAAC;IACnD,IAAI,aAAa,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;IAE7B,MAAM,eAAe,GAAG,oBAAoB,CACxC,CAAO,OAAO,EAAE,EAAE;QACd,YAAY,GAAG,MAAM,WAAW,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;QACxD,OAAO,YAAY,CAAC;IACxB,CAAC,CAAA,EACD,cAAc,EACd,CAAC,CACJ,CAAC;IAEF,MAAM,YAAY,GAAG,CAAC,IAAuC,EAAE,OAAa,EAAE,QAAe,EAAE,EAAE;QAC7F,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;QAC1E,IAAI,CAAC,KAAK;YAAE,OAAO;QAEnB,8GAA8G;QAC9G,uDAAuD;QACvD,MAAM,QAAQ,GACV,KAAK,YAAY,OAAO;YACpB,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC;YACtD,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;QAEhD,YAAY,GAAG,SAAS,CAAC;QACzB,YAAY,CAAC,YAAY,CAAC,CAAC;QAC3B,aAAa,EAAE,CAAC;QAEhB,OAAO,QAAQ,CAAC;IACpB,CAAC,CAAC;IAEF,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAO,OAAO,EAAE,QAAQ,EAAE,EAAE;QACzC,+GAA+G;QAC/G,8GAA8G;QAC9G,2BAA2B;QAC3B,IAAI,cAAc,IAAI,cAAc,CAAC,4BAA4B,CAAC,QAAQ,CAAC,EAAE;YACzE,MAAM,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YAC5C,OAAO;SACV;QAED,4GAA4G;QAC5G,gBAAgB;QAChB,EAAE;QACF,6BAA6B;QAC7B,6FAA6F;QAC7F,EAAE;QACF,IAAI,YAAY,KAAK,SAAS,EAAE;YAC5B,MAAM,SAAS,GAAG,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;YAChE,IAAI,WAAW,KAAK,SAAS;gBAAE,YAAY,GAAG,UAAU,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YACjF,IAAI,cAAc;gBAAE,aAAa,GAAG,cAAc,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SAC9E;QAED,MAAM,MAAM,GAAG,eAAe,CAAC,GAAS,EAAE;YACtC,IAAI,CAAC,YAAY;gBAAE,OAAO;YAC1B,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC;gBAAE,OAAO;YAC3C,MAAM,YAAY,CAAC,IAAI,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;QAClD,CAAC,CAAA,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IACrC,CAAC,CAAA,CAAC;AACN,CAAC,CAAC","sourcesContent":["import { PageVisibility } from \"../common/pageVisibility\";\nimport { ChainableHandler, Handler, RequestMetadata } from \"./HandlerChainBuilder\";\nimport { createMappingHandler } from \"./mappingHandler\";\n\nexport interface BatchingHandlerOptions<Req, BatchReq> {\n    batchReduce: (batch: BatchReq | undefined, req: Req) => BatchReq | Promise<BatchReq>;\n    isBatchComplete: (batch: BatchReq) => boolean;\n    maxBatchAge?: number;\n    /**\n     * Determines whether to flush buffered requests when the page becomes hidden.\n     * `false` value indicates that page visibility handling is avoided, while\n     * a {@link PageVisibility} instance is used to subscribe to page visibility change events.\n     */\n    pageVisibility: PageVisibility | false;\n}\n\n/**\n * Accumulate requests into batches, which are then sent to the next handler in the chain. Batches are sent when either:\n * - the given `isBatchComplete` function returns true, closing the current batch and sending it down the chain.\n * - an optional `maxBatchAge` time has elapsed since the first request in the batch was received.\n * - the page terminates.\n *\n * When handling a request, the Promise returned will resolve when that request has been successfully added to the\n * current batch – **NOT** when that batch has been successfully processed by the rest of the handler chain.\n *\n * The `next` handler in the chain will receive the batch and should handle any errors arising from further processing\n * on the batch (e.g. sending it to a server).\n *\n * **Note:** This handler does not support aborting handled requests via AbortSignal.\n *\n * @param options\n * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}\n */\nexport const createBatchingHandler = <Req, BatchReq, BatchRes, Meta extends RequestMetadata>({\n    batchReduce,\n    isBatchComplete,\n    maxBatchAge,\n    pageVisibility,\n}: BatchingHandlerOptions<Req, BatchReq>): ChainableHandler<Req, void, BatchReq, BatchRes, Meta> => {\n    // TODO: this should just be `number`, but we're picking up NodeJS types (@types/node) when building, so setTimeout\n    // gets a different return type than what it should have in the browser. We should build without NodeJS types, but\n    // that will require some fixes across the codebase.\n    let batchTimeout: ReturnType<typeof setTimeout>;\n    let currentBatch: BatchReq | undefined = undefined;\n    let clearOnHidden = () => {};\n\n    const reducingHandler = createMappingHandler<Req, BatchReq, void, Meta>(\n        async (request) => {\n            currentBatch = await batchReduce(currentBatch, request);\n            return currentBatch;\n        },\n        pageVisibility,\n        1\n    );\n\n    const batchAndSend = (next: Handler<BatchReq, BatchRes, Meta>, request?: Req, metadata?: Meta) => {\n        const batch = request ? batchReduce(currentBatch, request) : currentBatch;\n        if (!batch) return;\n\n        // `next` should handle its own errors – that is, the batchingHandler is meant to be placed in a handler chain\n        // prior to any error logging, retrying, etc. handlers.\n        const complete =\n            batch instanceof Promise\n                ? batch.then((b) => next(b, metadata)).catch(() => {})\n                : next(batch, metadata).catch(() => {});\n\n        currentBatch = undefined;\n        clearTimeout(batchTimeout);\n        clearOnHidden();\n\n        return complete;\n    };\n\n    return (next) => async (request, metadata) => {\n        // Requests may be made while the page is transitioning to hidden – for example, the page is being unloaded and\n        // we're reporting final metrics. In this case, we need to skip batching and synchronously call `next` so that\n        // the request is not lost.\n        if (pageVisibility && pageVisibility.isDuringVisibilityTransition(\"hidden\")) {\n            await batchAndSend(next, request, metadata);\n            return;\n        }\n\n        // If this is the first request in a batch, we need to set up some callbacks to flush the batch when certain\n        // events occur:\n        //\n        // - maxBatchAge time passes.\n        // - page visibility transitions to hidden (which could indicate the page is being unloaded).\n        //\n        if (currentBatch === undefined) {\n            const sendBatch = () => batchAndSend(next, undefined, metadata);\n            if (maxBatchAge !== undefined) batchTimeout = setTimeout(sendBatch, maxBatchAge);\n            if (pageVisibility) clearOnHidden = pageVisibility.onPageHidden(sendBatch);\n        }\n\n        const handle = reducingHandler(async () => {\n            if (!currentBatch) return;\n            if (!isBatchComplete(currentBatch)) return;\n            await batchAndSend(next, undefined, metadata);\n        });\n\n        return handle(request, metadata);\n    };\n};\n"]}