{"version":3,"file":"persistingHandler.js","sourceRoot":"","sources":["../../src/handlers/persistingHandler.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAI7C,MAAM,MAAM,GAAG,SAAS,CAAC,mBAAmB,CAAC,CAAC;AAE9C;;;;;;;;;;GAUG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACnC,WAAiD,EACP,EAAE;IAC5C,IAAI,aAAa,GAAG,IAAI,CAAC;IACzB,MAAM,oBAAoB,GAAG,CAAO,IAA6B,EAAE,EAAE;QACjE,IAAI,CAAC,aAAa;YAAE,OAAO;QAC3B,aAAa,GAAG,KAAK,CAAC;QACtB,IAAI;YACA,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC,SAAS,EAAE,CAAC;YAC/C,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAO;YAClC,yGAAyG;YACzG,mFAAmF;YACnF,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,EAAE,CACrC,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpD,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACxB,CAAC,CAAC,CACL,CAAC;YAEF,0GAA0G;YAC1G,2GAA2G;SAC9G;QAAC,OAAO,KAAK,EAAE;YACZ,0GAA0G;YAC1G,uCAAuC;YACvC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;SACvB;IACL,CAAC,CAAA,CAAC;IAEF,MAAM,cAAc,GAAG,CAAC,IAA6B,EAAE,EAAE,CAAC,CAAO,GAAQ,EAAE,QAAe,EAAE,EAAE;QAC1F,gHAAgH;QAChH,2FAA2F;QAC3F,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAE3B,+GAA+G;QAC/G,6GAA6G;QAC7G,+GAA+G;QAC/G,iFAAiF;QACjF,MAAM,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YAClE,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACpB,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC,CAAC;QACH,IAAI;YACA,OAAO,MAAM,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;SACpC;gBAAS;YACN,qGAAqG;YACrG,yCAAyC;YACzC,UAAU;iBACL,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE;gBACV,IAAI,GAAG,KAAK,IAAI;oBAAE,OAAO,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACjD,OAAO;YACX,CAAC,CAAC;gBACF,mGAAmG;gBACnG,gGAAgG;gBAChG,gFAAgF;iBAC/E,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;SAC9C;IACL,CAAC,CAAA,CAAC;IACF,OAAO,cAAc,CAAC;AAC1B,CAAC,CAAC","sourcesContent":["import { getLogger } from \"../logger/logger\";\nimport { Persistence } from \"../persistence/Persistence\";\nimport { ChainableHandler, Handler, RequestMetadata } from \"./HandlerChainBuilder\";\n\nconst logger = getLogger(\"persistingHandler\");\n\n/**\n * This handler persists in-flight requests locally, so that if there is an unexpected termination of the process (e.g.\n * the browser tab crashes or is closed) those requests can be recovered and retried on the next page load.\n *\n * Keep in mind, using this handler means some *successful* requests may be repeated (e.g. if the request made it to a\n * server, which responded, but the response didn't reach the browser before the tab closed). Any handler chain making\n * use of this handler should only handle idempotent requests.\n *\n * @param persistence Requests will be temporarily stored here while they are in-flight.\n * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}\n */\nexport const createPersistingHandler = <Req, Res, Meta extends RequestMetadata>(\n    persistence: Persistence<[Req, Meta | undefined]>\n): ChainableHandler<Req, Res, Req, Res, Meta> => {\n    let needsRecovery = true;\n    const maybePerformRecovery = async (next: Handler<Req, Res, Meta>) => {\n        if (!needsRecovery) return;\n        needsRecovery = false;\n        try {\n            const requests = await persistence.removeAll();\n            if (requests.length === 0) return;\n            // If a recovered request fails, we'll report the error and prevent it from disrupting other requests. We\n            // won't re-persist to avoid a poison-pill request that remains in storage forever.\n            requests.forEach(([request, metadata]) =>\n                performRequest(next)(request, metadata).catch((error) => {\n                    logger.error(error);\n                })\n            );\n\n            // If we fail to retrieve, we have no option but to report the error and proceed. Since we can't tell here\n            // if there were any requests to recover, we cannot say if an error here will actually result in data loss.\n        } catch (error) {\n            // TODO: we will also want to report persistence size (either here or elsewhere) to detect scenarious that\n            // could result in unbounded DB growth.\n            logger.error(error);\n        }\n    };\n\n    const performRequest = (next: Handler<Req, Res, Meta>) => async (req: Req, metadata?: Meta) => {\n        // If there are requests to be recovered (e.g. a prior session crashed while requests were in-flight), they will\n        // be passed to the next handler in the chain. This will happen at most once per page load.\n        maybePerformRecovery(next);\n\n        // Whether the persistence succeeds or fails, we always want to make the request – so we don't need to wait for\n        // the request to be stored before passing it to the `next` handler. This is why we're not awaiting the store\n        // call here. We'll also swallow any errors, simply returning `null` for the key – persistence and recovery are\n        // always best-effort, and failure should not disrupt other application behavior.\n        const keyPromise = persistence.store([req, metadata]).catch((error) => {\n            logger.error(error);\n            return null;\n        });\n        try {\n            return await next(req, metadata);\n        } finally {\n            // We don't care if the request was successful or not, either way once it is completed we will remove\n            // the request from the persistent store.\n            keyPromise\n                .then((key) => {\n                    if (key !== null) return persistence.remove(key);\n                    return;\n                })\n                // If removal fails, we will recover and re-send the request – failure could occur if the OS cannot\n                // complete the DB transaction (e.g. power loss), or potentially in other exceptional scenarios.\n                // Therefore it's important that requests handled by this handler be idempotent.\n                .catch((error) => logger.error(error));\n        }\n    };\n    return performRequest;\n};\n"]}