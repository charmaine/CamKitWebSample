import { __awaiter } from "tslib";
import { ensureError } from "../common/errorHelpers";
import { cacheKeyNotFoundError } from "../namedErrors";
import { getLogger } from "../logger/logger";
const logger = getLogger("responseCachingHandler");
const notFound = (key) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);
const strategyFailed = (key, cause) => new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });
/**
 * Create a CachingStrategy that first makes a request to the network, falling back to cache if the network request
 * fails. If the network request fails and a prior response has not been cached, an error is returned to the caller.
 */
export const staleIfErrorStrategy = () => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const response = yield network();
        cache.store(key, response).catch((error) => {
            logger.warn(`staleIfErrorStrategy failed to store key ${key}.`, error);
        });
        return response;
    }
    catch (networkError) {
        try {
            const cachedResponse = yield cache.retrieve(key);
            if (!cachedResponse)
                throw notFound(key);
            logger.debug(`staleIfErrorStrategy successfully fell back to cache for key ${key} after network error.`, networkError);
            return cachedResponse;
        }
        catch (cacheError) {
            const error = ensureError(cacheError);
            error.cause = networkError;
            throw strategyFailed(key, error);
        }
    }
});
/**
 * Create a CachingStrategy that first does a cache lookup â€“ if the response is found in cache, it is returned and the
 * entry is updated with a request to the network in the background. If no cached response is found, the network request
 * is made, the result cached and returned to the caller.
 */
export const staleWhileRevalidateStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const cachedResponse = yield cache.retrieve(key);
        if (!cachedResponse)
            throw notFound(key);
        // By specifying isSideEffect: true, the handler chain allows the network handler to run to completion,
        // even though we return an immediate response from the cache. In the typical use-case, once a response has
        // resolved, any ongoing handlers are aborted because the handler chain knows their result will not be
        // used -- but here, the network handler is run as a side-effect to update the cache after the cached
        // response has been resolved.
        network({ isSideEffect: true })
            .then((response) => cache.store(key, response))
            .catch((error) => {
            logger.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);
        });
        return cachedResponse;
    }
    catch (cacheError) {
        options === null || options === void 0 ? void 0 : options.reporter.count("cache_miss", 1, new Map([["request_type", options.requestType]]));
        try {
            const response = yield network();
            cache.store(key, response).catch((error) => {
                logger.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);
            });
            logger.debug(`staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`, cacheError);
            return response;
        }
        catch (networkError) {
            const error = ensureError(networkError);
            error.cause = cacheError;
            throw strategyFailed(key, error);
        }
    }
});
/**
 * Create a Handler capable of caching responses using various caching strategies.
 *
 * More than one caching strategy can be provided, and they will be composed into a single strategy. For example, an
 * expiringStrategy could be composed with a staleIfErrorStrategy so that responses
 *
 * @param cache A Persistence instance capable of storing responses.
 * @param resolveKey This function is called once for each request, and must return a valid persistence key
 * corresponding uniquely to that request.
 * @param strategy A CachingStrategy used to determine when to retrieve from cache vs. request from the network.
 * @returns
 */
export const createResponseCachingHandler = (cache, resolveKey, strategy) => {
    return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
        const network = (additionalMetadata = {}) => {
            const m = Object.assign(Object.assign({}, metadata), additionalMetadata);
            return next(request, m);
        };
        let key;
        try {
            key = resolveKey(request, metadata);
        }
        catch (error) {
            logger.warn("Cache lookup failed because the cache key could not be resolved.", error);
            return network();
        }
        return strategy(key, cache, network);
    });
};
//# sourceMappingURL=responseCachingHandler.js.map