{"version":3,"file":"rateLimitingHandler.js","sourceRoot":"","sources":["../../src/handlers/rateLimitingHandler.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAExD,MAAM,KAAK,GAAG,CAAC,QAAgB,EAAE,EAAE,CAAC,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;AAElG;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,CAAC,MAAM,yBAAyB,GAAG,CACrC,QAAgB,EAChB,cAAsC,EACI,EAAE;IAC5C,IAAI,kBAAkB,GAAuB,SAAS,CAAC;IAEvD,MAAM,cAAc,GAAG,oBAAoB,CACvC,CAAO,OAAO,EAAE,EAAE;QACd,IAAI,kBAAkB,KAAK,SAAS,EAAE;YAClC,MAAM,mBAAmB,GAAG,QAAQ,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,kBAAkB,CAAC,CAAC;YACzE,IAAI,mBAAmB,GAAG,CAAC;gBAAE,MAAM,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACjE;QACD,kBAAkB,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAChC,OAAO,OAAO,CAAC;IACnB,CAAC,CAAA,EACD,cAAc,EACd,CAAC,CACJ,CAAC;IAEF,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,EAAE;QACnC,+GAA+G;QAC/G,2GAA2G;QAC3G,mCAAmC;QACnC,IAAI,cAAc,IAAI,cAAc,CAAC,4BAA4B,CAAC,QAAQ,CAAC;YAAE,OAAO,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC5G,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IACnD,CAAC,CAAC;AACN,CAAC,CAAC","sourcesContent":["import { PageVisibility } from \"../common/pageVisibility\";\nimport { ChainableHandler, RequestMetadata } from \"./HandlerChainBuilder\";\nimport { createMappingHandler } from \"./mappingHandler\";\n\nconst delay = (duration: number) => new Promise<void>((resolve) => setTimeout(resolve, duration));\n\n/**\n * Limit the rate at which requests are passed to the next handler in the chain.\n *\n * During any page transitions to \"hidden\" – possibly indicating the page is about to terminate – requests will not be\n * rate limited, to ensure that they are not lost.\n *\n * TODO: If there are requests in the queue waiting to be sent when the page transitions to \"hidden,\" these will not\n * be immediately sent. This means there still is an edge case in which a request may be lost on page termination. This\n * can be fixed with changes to `createMappingHandler`.\n *\n * **NOTE:** Under the hood, requests that come in faster than the set `duration` are placed in an unbounded buffer.\n * If many requests are made quickly and `duration` is long, this could result in high memory usage. Keep this in mind\n * when using this handler.\n *\n * @param duration In milliseconds. Requests will be passed to the next handler in the chain no faster than this. That\n * is, if `duration` is `1000`, the next handler will be called at most once per second.\n * @param pageVisibility Determines whether to flush buffered requests when the page becomes hidden.\n * `false` value indicates that page visibility handling is avoided, while\n * a {@link PageVisibility} instance is used to subscribe to page visibility change events.\n * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}\n */\nexport const createRateLimitingHandler = <Req, Res, Meta extends RequestMetadata>(\n    duration: number,\n    pageVisibility: PageVisibility | false\n): ChainableHandler<Req, Res, Req, Res, Meta> => {\n    let mostRecentSendTime: number | undefined = undefined;\n\n    const mappingHandler = createMappingHandler<Req, Req, Res, Meta>(\n        async (request) => {\n            if (mostRecentSendTime !== undefined) {\n                const millisUntilNextSend = duration - (Date.now() - mostRecentSendTime);\n                if (millisUntilNextSend > 0) await delay(millisUntilNextSend);\n            }\n            mostRecentSendTime = Date.now();\n            return request;\n        },\n        pageVisibility,\n        1\n    );\n\n    return (next) => (request, metadata) => {\n        // Requests may be made while the page is transitioning to hidden – for example, the page is being unloaded and\n        // we're reporting final metrics. In this case, we need to skip rate limiting and synchronously call `next`\n        // so that the request is not lost.\n        if (pageVisibility && pageVisibility.isDuringVisibilityTransition(\"hidden\")) return next(request, metadata);\n        return mappingHandler(next)(request, metadata);\n    };\n};\n"]}