import { PageVisibility } from "../common/pageVisibility";
import { ChainableHandler, RequestMetadata } from "./HandlerChainBuilder";
/**
 * Map from one request type to another, potentially asynchronously.
 *
 * **NOTE:** If `maxMapConcurrency` is set to some finite number, and more requests are handled than are allowed to
 * be concurrently mapped, the waiting requests will be placed into a unbounded buffer. If, for example, requests are
 * handled with high frequency, `maxMapConcurrency` is low, and the `map` function returns a long-running Promise, this
 * buffer could use a large amount of memory. Keep this in mind when using this handler.
 *
 * @param map Transform each request, may be sync or async.
 * @param pageVisibility Determines whether to flush buffered requests when the page becomes hidden.
 * `false` value indicates that page visibility handling is avoided, while
 * a {@link PageVisibility} instance is used to subscribe to page visibility change events.
 * @param maxMapConcurrency If the `map` function is async, it will be invoked at most this number of times
 * concurrently. Setting this to 1 could be useful if it's important for `map` to be called in serial.
 * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}
 */
export declare const createMappingHandler: <Req, MappedReq, Res, Meta extends RequestMetadata>(map: (request: Req) => MappedReq | Promise<MappedReq>, pageVisibility: PageVisibility | false, maxMapConcurrency?: number) => ChainableHandler<Req, Res, MappedReq, Res, Meta>;
