import { Persistence, ValidKey } from "../persistence/Persistence";
import { OperationalMetricsReporter } from "../metrics/operational/operationalMetricsReporter";
import { ChainableHandler, RequestMetadata } from "./HandlerChainBuilder";
export type CachingStrategy<T> = (key: ValidKey, cache: Persistence<T>, network: (metadata?: RequestMetadata) => Promise<T>) => Promise<T>;
/**
 * Create a CachingStrategy that first makes a request to the network, falling back to cache if the network request
 * fails. If the network request fails and a prior response has not been cached, an error is returned to the caller.
 */
export declare const staleIfErrorStrategy: <T>() => CachingStrategy<T>;
/**
 * If provided these options allow staleWhileRevalidateStrategy to report cache_miss metrics.
 */
export interface StaleWhileRevalidateOptions {
    requestType: string;
    reporter: OperationalMetricsReporter;
}
/**
 * Create a CachingStrategy that first does a cache lookup â€“ if the response is found in cache, it is returned and the
 * entry is updated with a request to the network in the background. If no cached response is found, the network request
 * is made, the result cached and returned to the caller.
 */
export declare const staleWhileRevalidateStrategy: <T>(options?: StaleWhileRevalidateOptions) => CachingStrategy<T>;
/**
 * Create a Handler capable of caching responses using various caching strategies.
 *
 * More than one caching strategy can be provided, and they will be composed into a single strategy. For example, an
 * expiringStrategy could be composed with a staleIfErrorStrategy so that responses
 *
 * @param cache A Persistence instance capable of storing responses.
 * @param resolveKey This function is called once for each request, and must return a valid persistence key
 * corresponding uniquely to that request.
 * @param strategy A CachingStrategy used to determine when to retrieve from cache vs. request from the network.
 * @returns
 */
export declare const createResponseCachingHandler: <Req, Res, Meta extends RequestMetadata>(cache: Persistence<Res>, resolveKey: (request: Req, metadata?: Meta | undefined) => ValidKey, strategy: CachingStrategy<Res>) => ChainableHandler<Req, Res, Req, Res, Meta>;
