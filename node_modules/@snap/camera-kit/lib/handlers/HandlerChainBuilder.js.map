{"version":3,"file":"HandlerChainBuilder.js","sourceRoot":"","sources":["../../src/handlers/HandlerChainBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["export type RequestMetadata =\n    | {\n          signal?: AbortSignal | null | undefined;\n          /**\n           * When calling a handler, if that handler is part of a handler chain, then by default an abort signal will be\n           * sent to that handler if another handler higher up in the chain completes first. Usually this is desirable,\n           * since we know if a handler higher up in the chain has completed and returned a response to its caller, then\n           * the response from all the handlers below it in the chain will not be used.\n           *\n           * But in some cases, a handler in a handler chain wants to call the next handler in the chain as a\n           * side-effect. If a handler is called as a side-effect, it will not be sent an abort signal when handlers\n           * higher up in the chain complete.\n           *\n           * For example: a caching handler might return a cached value immediately, but then call the next handler as\n           * a side-effect to fetch an updated value to refresh the cache in the background. In that case, the next\n           * handler should not be sent an abort signal when the caching handler returns the cached value.\n           */\n          isSideEffect?: boolean;\n      }\n    | undefined;\nexport type Handler<Req, Res, Meta extends RequestMetadata> = (req: Req, metadata?: Meta) => Promise<Res>;\nexport type ChainableHandler<Req, Res, NextReq, NextRes, Meta extends RequestMetadata | undefined> = (\n    next: Handler<NextReq, NextRes, Meta>\n) => Handler<Req, Res, Meta>;\n\n/**\n * Creates a Handler chain – a series of functions composed such that each function may call a supplied `next` function\n * which passes execution down the chain. When the final Handler in the chain returns, execution passes back up the\n * chain eventually returning to the caller.\n *\n * Each Handler chain begins with a \"raw\" Handler – this is a function which takes some request and returns some\n * response. A chain is then created by supplying a series of mapping functions – the ChainableHandler type – which will\n * be called with the `next` Handler in the chain.\n *\n * Ex:\n * ```ts\n * const handler = (request: string, metadata?: RequestMetadata) => Promise.resolve(`Responded to ${request}`)\n * const chainable = (next: Handler<string, string>) => (request: string, metadata?: RequestMetadata) => {\n *   return next(`modified ${request}`, metadata)\n * }\n *\n * const chain = new HandlerChainBuilder(handler)\n *   .map(chainable)\n *   .handler\n *\n * const response = await chain('hello')\n * expect(response).toBe('Responded to modified hello; 0')\n * ```\n * You can largely ignore the `metadata` argument present in the above example. This is the mechanism by which an\n * AbortSignal is passed to each Handler in the chain, but the only real requirement when implementing a Handler is\n * to pass this argument along to the `next` function. In fact, many Handlers will want to be generic over the type\n * of metadata:\n * ```ts\n * const chainable = <Meta>(next: Handler<string, string, Meta>) => (request: string, metadata: Meta) => {\n *   return next(`modified ${request}`, metadata)\n * }\n * ```\n * Actually, it's a very good idea for Handlers to be as generic as possible, since that will allow greater re-use. In\n * the above example, we don't do anything with the response from `next`, so we can let that be generic, too:\n * ```ts\n * const chainable = <Res, Meta>(next: Handler<string, Res, Meta>) => (request: string, metadata: Meta) => {\n *   return next(`modified ${request}`, metadata)\n * }\n * ```\n * Now if some other Handler in the chain decides to return a different response type, our Handler won't require any\n * changes to compile.\n *\n * ---\n *\n * Since execution passes from handler to handler in the chain, and then back, handlers have the opportunity to modify\n * or observe both the request and response. This might be useful for implementing serialization/deserialization, but\n * the simplest example that demonstrates this feature is measuring request latency:\n * ```ts\n * const latencyMeasuringHandler = <Req, Res, Meta>(next: Handler<Req, Res, Meta>) =>\n *   async (req: Req, metadata: Meta) => {\n *     const start = performance.now()\n *     const response = await next(req, metadata)\n *     const latency = performance.now() - start\n *     console.log(`latency for request ${request} was ${latency}`)\n *     return response\n *   }\n * ```\n * Execution is first passed to our measuring handler, which marks the `start` timestamp. Then it passes execution on\n * down the chain. After a response is received (by some handler down the chain), execution passes back up to our\n * handler here, which records the amount of time spent inside `next`.\n *\n * ---\n *\n * Handlers may also abort requests. They can do this in two ways:\n *   1. Create an `AbortController` and add its `AbortSignal` to the `metadata` object when calling `next`.\n *   2. Resolve its returned Promise.\n *\n * The first approach is straightforward, but the second may benefit from an example – the simplest is a handler which\n * will timeout a request:\n * ```ts\n * const timeoutHandler = <Req, Res, Meta>(next: Handler<Req, Res, Meta>) => (req: Req, metadata: Meta) => {\n *   return Promise.race([\n *     next(req, metadata),\n *     sleep(1000),\n *   ])\n * }\n * ```\n * The Promise returned by this handler will resolve either when the `next` handler resolves or 1 second has elapsed,\n * whichever happens first. If the timeout happens first, we want the `next` handler to recieve an abort signal so that\n * it can terminate early (since its result is no longer needed).\n *\n * HandlerChainBuilder makes this happen by observing when each handler completes, and sending an abort signal to all\n * the handlers \"downstream\" from the aborting handler.\n */\nexport class HandlerChainBuilder<Req, Res, Meta extends RequestMetadata> {\n    private readonly inner: Handler<Req, Res, Meta>;\n\n    constructor(inner: (req: Req, metadata: Meta) => Promise<Res>) {\n        // The TS compiler has the following behavior:\n        //\n        // class Infer<T extends SomeType | undefined> { constructor(f: (t?: T) => void) {} }\n        // const f = (t?: SomeType) => {}\n        // const i = new Infer(f)\n        //\n        // The type of `i` is inferred to be `Infer<SomeType>` instead of `Infer<SomeType | undefined>`, even though the\n        // type of `f`'s argument is `SomeType | undefined`. This seems to be a bug in type inference. Note that making\n        // the constructor argument required gives the expected behavior:\n        //\n        // class Infer<T extends SomeType | undefined> { constructor(f: (t: T) => void) {} }\n        // const f = (t?: SomeType) => {}\n        // const i = new Infer(f)\n        //\n        // Now `i` is inferred to be `Infer<SomeType | undefined>`.\n        //\n        // This has consequences if the inferred type T is used elsewhere in the class.\n        //\n        // In this case, we need to make sure that if the given `inner` function marks the metadata argument as\n        // optional, that HandlerChainBuilder correctly infers that the Meta type includes undefined. So we don't mark\n        // metadata as optional, and so we must cast to `Handler` (which does mark it as optional).\n        //\n        // Safety: We're adding `| undefined` to the metadata type, which may be unsafe – `undefined` may not be\n        // assignable to Meta. But when handling the argument of type Meta, we simply pass it through from handler to\n        // handler – we never call `inner` without passing the metadata argument we've received from some call to an\n        // outer handler. The typing visible to callers remains safe.\n        this.inner = inner as Handler<Req, Res, Meta>;\n    }\n\n    get handler(): Handler<Req, Res, Meta> {\n        return this.inner;\n    }\n\n    map<PriorReq, PriorRes>(\n        outer: ChainableHandler<PriorReq, PriorRes, Req, Res, Meta>\n    ): HandlerChainBuilder<PriorReq, PriorRes, Meta> {\n        // To create the next handler in the chain, we compose the \"outer\" handler with the \"inner\" handler.\n        //\n        // The outer handler observes its own completion and sends an abort signal to the inner handler when it has\n        // resolved. To prevent unexpected behavior, the inner handler also observes its own completion, setting a flag\n        // when it resolves so that – if it resolves before the outer handler – the outer handler can skip sending the\n        // abort signal (since the inner handler has already completed).\n        const outerHandler = (req: PriorReq, metadata: Meta): Promise<PriorRes> => {\n            const abort = new AbortController();\n            const signal = abort.signal;\n\n            // It's important to not signal an abort to an inner handler which has already completed – it seems like\n            // this would be a non-issue (shouldn't aborting after completion be a no-op?), but specifically for the\n            // browser's implementation of `fetch`, aborting even after the `fetch` Promise resolves can cause an abort\n            // error if e.g. the Fetch Response's body has not yet been read.\n            //\n            // So, for safety, we will only abort inner handlers which are still executing.\n            let innerCompleted = false;\n\n            const maybeAbort = () => {\n                // Safety: we never give `abort` to anyone else, so we know if the signal is aborted, this function\n                // has already run, so we can return early without fear of leaking. We also know if inner has completed,\n                // it has already performed cleanup.\n                if (signal.aborted || innerCompleted) return;\n\n                // If we've gotten here, the outer handler has either completed, or we heard an abort event while the\n                // inner handler is still executing – so we pass the abort signal down to the inner handler.\n                abort.abort();\n                metadata?.signal?.removeEventListener(\"abort\", maybeAbort);\n            };\n\n            metadata?.signal?.addEventListener(\"abort\", maybeAbort);\n\n            const innerHandler = new Proxy(this.inner, {\n                apply: (target, thisArg, args) => {\n                    const [req, metadata] = args as Parameters<typeof target>;\n\n                    // When calling the inner handler, we may not care about the result and don't want the handler's\n                    // operation to be interrupted by an abort signal. For example, we might be calling the inner\n                    // handler as a side-effect which we want to continue after the outer handler has completed.\n                    //\n                    // In this cases, we'll treat the inner handler as having completed immediately -- as far as the\n                    // outer handler is concerned, the inner handler is a no-op. This means that when the outer handler\n                    // completes, `maybeAbort` will not send an abort signal to the inner handler.\n                    //\n                    // A concrete example: returning a value from cache immediately, but then calling the inner handler\n                    // as a side-effect to refresh the cache \"in the background.\"\n                    if (metadata?.isSideEffect) innerCompleted = true;\n\n                    // To help Handler authors out, we'll do some bookkeeping and cleanup for them – if they forget to\n                    // remove an abort event listener, we'll remove it for them when the Promise they return resolves.\n                    // Note: No need to proxy removeEventListener, since removing a non-existent listener just no-ops.\n                    const abortListeners: EventListenerOrEventListenerObject[] = [];\n                    signal.addEventListener = new Proxy(signal.addEventListener, {\n                        apply: (target, thisArg, args) => {\n                            abortListeners.push(args[1]);\n                            return Reflect.apply(target, thisArg, args);\n                        },\n                    });\n\n                    const cleanupAndMarkComplete = () => {\n                        // The only reason we listen to upstream aborts is to pass them to the inner handler – since the\n                        // inner handler has completed, we no longer need the listener.\n                        metadata?.signal?.removeEventListener(\"abort\", maybeAbort);\n                        abortListeners.forEach((listener) => signal.removeEventListener(\"abort\", listener));\n                        innerCompleted = true;\n                    };\n\n                    const innerResponse: ReturnType<typeof target> = Reflect.apply(target, thisArg, [\n                        req,\n                        // Side-effect state does not propagate down the handler chain -- each outer handler must set\n                        // this property on their own when calling their inner handler. One outer handler may treat its\n                        // inner handler as a side-effect, but that doesn't each subsequent handler in the chain should\n                        // be treated as a side-effect. In other words, passing isSideEffect is only relevant to the\n                        // HandlerChainBuilder (telling it not to abort the inner handler), and not to any subsequent\n                        // handlers in the chain.\n                        { ...metadata, isSideEffect: false, signal },\n                    ]);\n\n                    // Using `finally` is more idiomatic, but causes trouble in some environments (e.g. some testing\n                    // runtimes which detect uncaught rejected promises).\n                    innerResponse.catch(() => {}).then(cleanupAndMarkComplete);\n                    return innerResponse;\n                },\n            });\n\n            const outerResponse = outer(innerHandler)(req, metadata);\n            outerResponse.catch(() => {}).then(maybeAbort);\n            return outerResponse;\n        };\n        return new HandlerChainBuilder(outerHandler as Handler<PriorReq, PriorRes, Meta>);\n    }\n}\n"]}