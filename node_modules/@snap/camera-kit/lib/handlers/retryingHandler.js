import { __awaiter } from "tslib";
import { copyDefinedProperties } from "../common/copyDefinedProperties";
import { getLogger } from "../logger/logger";
const logger = getLogger("retryingHandler");
const logRetry = (responseOrError, sleep) => {
    logger.warn(`Retrying handler got failed response:`, responseOrError, `Waited ${sleep} millis, attempting retry now.`);
};
const sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
const randomInRange = (min, max) => Math.round(Math.random() * (max - min) + min);
const defaultOptions = {
    backoffMultiple: 3,
    baseSleep: 500,
    maxSleep: 5 * 1000,
    maxRetries: 10,
    // The Response type is very common, so our default predicate special-cases to retry all failed Responses.
    retryPredicate: (responseOrError) => (responseOrError instanceof Response ? !responseOrError.ok : true),
};
/**
 * Returns a cloned instance of Request if the input is of that type, otherwise returns the input unchanged.
 *
 * This is necessary when attempting to retry a request.
 * It is not possible to reuse the same Request instance that has already been sent.
 */
export function ensureClonedRequest(input) {
    return input instanceof Request ? input.clone() : input;
}
/**
 * Retry requests using an exponential backoff with jitter strategy.
 *
 * More about this approach to retries can be found
 * [here](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/). This implementation uses the
 * "Decorrelated jitter" algorithm described in that post. This offers a good tradeoff between call volume and latency,
 * and also allows for convenient configurability.
 *
 * @param options
 * @returns {@link ChainableHandler}, suitable for use in {@link HandlerChainBuilder.map}
 */
export const createRetryingHandler = (options = {}) => {
    const definedOptions = copyDefinedProperties(options);
    const { backoffMultiple, baseSleep, maxSleep, maxRetries, retryPredicate } = Object.assign(Object.assign({}, defaultOptions), definedOptions);
    let retryCount = -1;
    const jitterSleep = (priorSleep) => __awaiter(void 0, void 0, void 0, function* () {
        const nextSleep = Math.min(maxSleep, randomInRange(baseSleep, priorSleep * backoffMultiple));
        yield sleep(nextSleep);
        return nextSleep;
    });
    const makeRequestAttempt = (next, priorSleep = baseSleep) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        retryCount++;
        try {
            const response = yield next(ensureClonedRequest(req), metadata);
            if (retryCount < maxRetries && retryPredicate(response, retryCount)) {
                const nextSleep = yield jitterSleep(priorSleep);
                // The request may have been aborted while we were sleeping. In that case, we'll resolve
                // with the failed response. In many cases this will be ignored, because an AbortError has already
                // been returned to the caller of the Handler chain â€“ but this prevents us from doing
                // any extra work, and there may be edge cases where the caller could find the response useful.
                if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.aborted)
                    return response;
                logRetry(response, nextSleep);
                return makeRequestAttempt(next, nextSleep)(req, metadata);
            }
            return response;
        }
        catch (error) {
            if (!(error instanceof Error)) {
                throw new Error("Invalid type caught by retrying handler. Handlers may only throw Errors. Got " +
                    `${JSON.stringify(error)}`);
            }
            // If the request fails because it was aborted, we assume this was done intentionally and we can stop.
            if (error.name === "AbortError")
                throw error;
            if (retryCount < maxRetries && retryPredicate(error, retryCount)) {
                const nextSleep = yield jitterSleep(priorSleep);
                if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _b === void 0 ? void 0 : _b.aborted)
                    throw error;
                logRetry(error, nextSleep);
                return makeRequestAttempt(next, nextSleep)(req, metadata);
            }
            // If no retry is to be attempted, return the error to the caller.
            throw error;
        }
    });
    return (next) => makeRequestAttempt(next);
};
//# sourceMappingURL=retryingHandler.js.map