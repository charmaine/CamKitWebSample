export function isString(value) {
    return typeof value === "string";
}
/**
 * Ensures given value is a safe string.
 *
 * Safe strings allow to prevent CRLF attacks. We use encoding approach inspired by:
 * https://community.veracode.com/s/question/0D53n00007hJJV5CAO/is-cwe-id-117-intended-for-consolelog
 */
export function isSafeString(value) {
    return isString(value) && encodeURIComponent(value) === value;
}
export function isNumber(value) {
    return typeof value === "number";
}
export function isNotNull(value) {
    return value !== null;
}
export function isArrayOfType(elementTypeGuard, value) {
    return Array.isArray(value) && value.every((id) => elementTypeGuard(id));
}
export function isStringArray(value) {
    return isArrayOfType(isString, value);
}
export function isSafeStringArray(value) {
    return isArrayOfType(isSafeString, value);
}
/**
 * Guards given value is instance of ArrayBuffer.
 */
export function isArrayBuffer(value) {
    return value instanceof ArrayBuffer;
}
/**
 * Guards given value is a typed array.
 */
export function isTypedArray(value) {
    return value instanceof Object.getPrototypeOf(Uint8Array);
}
/**
 * Guards given object is not undefined.
 */
export function isUndefined(value) {
    return typeof value === "undefined";
}
/**
 * Narrow an unknown type to a Record (i.e. a non-null JS object). This holds true for class instances, not just
 * plain objects.
 */
export function isRecord(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}
/**
 * Check if the value is an arbitrary function
 */
export function isFunction(value) {
    return typeof value === "function";
}
/**
 * Apply a given type predicate asserting values are of type T to each value in a Record.
 *
 * @param predicate Any unary type predicate
 * @returns A type predicate which takes an UnknownRecord and tests that all its values are of type T
 */
export function predicateRecordValues(predicate) {
    return (value) => {
        for (const v of Object.values(value))
            if (!predicate(v))
                return false;
        return true;
    };
}
/**
 * Checks whether given value is undefined or a safe URL string.
 *
 * The function checks whether given string is a valid URL with https: protocol.
 *
 * @param urlString URL string to check.
 * @returns True if URL is valid.
 */
export function isEmptyOrSafeUrl(urlString) {
    if (!urlString)
        return true;
    try {
        const url = new URL(urlString);
        return url.protocol === "https:" || url.protocol === "http:";
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=typeguards.js.map