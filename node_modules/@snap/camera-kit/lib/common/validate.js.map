{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/common/validate.ts"],"names":[],"mappings":"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","sourcesContent":["import \"reflect-metadata\";\nimport { Guard } from \"./typeguards\";\n\nconst predicateMetadataKey = Symbol(\"validate\");\n\n// A map of primitive types accoring to\n/* eslint-disable max-len */\n// http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-4#3-basic-type-serialization_1\nconst primitiveMap: Record<string, StringConstructor | NumberConstructor | BooleanConstructor> = {\n    string: String,\n    number: Number,\n    boolean: Boolean,\n};\n\nconst ordinalSuffixMap: Record<number, string> = {\n    1: \"st\",\n    2: \"nd\",\n    3: \"rd\",\n};\n\nfunction getArgumentInfo(target: Object, methodName: string | symbol, argumentIndex: number, arg: unknown) {\n    let argString;\n    try {\n        argString = JSON.stringify(arg);\n    } catch {\n        argString = String(arg);\n    }\n    return {\n        argPosition: `${argumentIndex + 1}${ordinalSuffixMap[argumentIndex + 1] ?? \"th\"}`,\n        methodPath: `${getTypeName(target)}.${String(methodName)}()`,\n        argTypeName: getTypeName(arg),\n        argString,\n    };\n}\n\nexport function guard<T>(predicate: Guard<T>) {\n    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {\n        let existingPredicates: Array<Guard<any>> =\n            Reflect.getOwnMetadata(predicateMetadataKey, target, propertyKey) || [];\n        existingPredicates[parameterIndex] = predicate;\n        Reflect.defineMetadata(predicateMetadataKey, existingPredicates, target, propertyKey);\n    };\n}\n\nexport function validate(target: Object, key: string | symbol, descriptor: PropertyDescriptor): void {\n    const method = descriptor.value!;\n    const types = Reflect.getMetadata(\"design:paramtypes\", target, key);\n    const predicates = Reflect.getMetadata(predicateMetadataKey, target, key);\n    descriptor.value = function (...args: unknown[]) {\n        for (const [i, type] of types.entries()) {\n            let arg = Array.isArray(args) && args[i];\n\n            if (!!predicates && predicates[i] && !predicates[i](arg)) {\n                const { methodPath, argPosition, argString } = getArgumentInfo(target, key, i, arg);\n                throw new Error(\n                    `The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`\n                );\n            }\n            if (arg === undefined || arg === null) {\n                // TODO: is there a way to check for nullable parameter?\n                break;\n            }\n            if (!isValueOfType(arg, type)) {\n                const { methodPath, argPosition, argTypeName } = getArgumentInfo(target, key, i, arg);\n                throw new Error(\n                    `The ${argPosition} argument to ${methodPath} method is of type ` +\n                        `${argTypeName}, which is not assignable to parameter of type ${type.name}.`\n                );\n            }\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * Checks whether given value is assignable to provided type.\n */\nexport function isValueOfType(value: unknown, type: any) {\n    if (value instanceof type) {\n        return true;\n    }\n    // test for primitive value\n    const isPrimitive = value !== Object(value);\n    return isPrimitive && primitiveMap[typeof value] === type;\n}\n\n/* eslint-disable max-len */\n/**\n * Returns type string of a value. It mostly mimics the behavior of typeof, but for non-primitives\n * (i.e. objects and functions), it returns a more granular type name where possible. Source:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#custom_method_that_gets_a_more_specific_type\n */\nexport function getTypeName(value: unknown): string {\n    if (value === null) {\n        return \"null\";\n    }\n\n    const baseType = typeof value;\n    // Primitive types\n    if (![\"object\", \"function\"].includes(baseType)) {\n        return baseType;\n    }\n\n    // Safety: at this point null and undefined values are already handled\n    const nonNullValue = value!;\n\n    // Symbol.toStringTag often specifies the \"display name\" of the\n    // object's class. It's used in Object.prototype.toString().\n    // Safety: cast to an object with Symbol.toStringTag key in order to check for its existance.\n    const tag = (nonNullValue as { [Symbol.toStringTag]?: string })[Symbol.toStringTag];\n    if (typeof tag === \"string\") {\n        return tag;\n    }\n\n    // If it's a function whose source code starts with the \"class\" keyword\n    if (baseType === \"function\" && Function.prototype.toString.call(nonNullValue).startsWith(\"class\")) {\n        return \"class\";\n    }\n\n    // The name of the constructor; for example `Array`, `GeneratorFunction`,\n    // `Number`, `String`, `Boolean` or `MyCustomClass`\n    const className = nonNullValue.constructor.name;\n    if (typeof className === \"string\" && className !== \"\") {\n        return className;\n    }\n\n    // At this point there's no robust way to get the type of value,\n    // so we use the base implementation.\n    return baseType;\n}\n"]}