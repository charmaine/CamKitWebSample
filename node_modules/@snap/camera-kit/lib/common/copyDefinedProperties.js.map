{"version":3,"file":"copyDefinedProperties.js","sourceRoot":"","sources":["../../src/common/copyDefinedProperties.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,qBAAqB,CAAe,GAAM;IACtD,OAAO,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,KAAK,SAAS,CAAC,CAAM,CAAC;AACpG,CAAC","sourcesContent":["/**\n * Copy only those properties of an object which are not undefined.\n *\n * This can be useful when using `Object.assign(foo, bar)` or `{ ...foo, ...bar }` to copy values from one object to\n * another. There's a (rather annoying) difference between a property not existing in an object and that property\n * existing but having an undefined value. When copying values using either of the methods above, it's generally\n * expected that undefined properties won't overwrite defined properties. But that's not the behavior â€“ this helper\n * function is needed to ensure undefined properties in `bar` don't clobber corresponding properties in `foo`.\n *\n * @param obj Any object, possibly with properties whose values are undefined.\n * @returns A copy of the input object, without keys whose values were undefined.\n */\nexport function copyDefinedProperties<T extends {}>(obj: T): T {\n    return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== undefined)) as T;\n}\n"]}