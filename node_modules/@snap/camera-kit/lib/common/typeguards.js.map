{"version":3,"file":"typeguards.js","sourceRoot":"","sources":["../../src/common/typeguards.ts"],"names":[],"mappings":"AAGA,MAAM,UAAU,QAAQ,CAAC,KAAc;IACnC,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC;AACrC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAAC,KAAc;IACvC,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,kBAAkB,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC;AAClE,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,KAAc;IACnC,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC;AACrC,CAAC;AACD,MAAM,UAAU,SAAS,CAAI,KAAQ;IACjC,OAAO,KAAK,KAAK,IAAI,CAAC;AAC1B,CAAC;AACD,MAAM,UAAU,aAAa,CAAI,gBAA0B,EAAE,KAAc;IACvE,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7E,CAAC;AACD,MAAM,UAAU,aAAa,CAAI,KAAc;IAC3C,OAAO,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC1C,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAI,KAAc;IAC/C,OAAO,aAAa,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;AAC9C,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,KAAc;IACxC,OAAO,KAAK,YAAY,WAAW,CAAC;AACxC,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,YAAY,CAAI,KAAc;IAC1C,OAAO,KAAK,YAAY,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;AAC9D,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,WAAW,CAAI,KAAc;IACzC,OAAO,OAAO,KAAK,KAAK,WAAW,CAAC;AACxC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,KAAc;IACnC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAChF,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,UAAU,CAAC,KAAc;IACrC,OAAO,OAAO,KAAK,KAAK,UAAU,CAAC;AACvC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,qBAAqB,CAAI,SAAyC;IAC9E,OAAO,CAAC,KAAoB,EAA6B,EAAE;QACvD,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC;YAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBAAE,OAAO,KAAK,CAAC;QACtE,OAAO,IAAI,CAAC;IAChB,CAAC,CAAC;AACN,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,gBAAgB,CAAC,SAA6B;IAC1D,IAAI,CAAC,SAAS;QAAE,OAAO,IAAI,CAAC;IAC5B,IAAI;QACA,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC;QAC/B,OAAO,GAAG,CAAC,QAAQ,KAAK,QAAQ,IAAI,GAAG,CAAC,QAAQ,KAAK,OAAO,CAAC;KAChE;IAAC,WAAM;QACJ,OAAO,KAAK,CAAC;KAChB;AACL,CAAC","sourcesContent":["type UnknownRecord<T = unknown> = Record<string | number | symbol, T>;\nexport type Guard<T, U = unknown> = (value: U | T) => value is T;\n\nexport function isString(value: unknown): value is string {\n    return typeof value === \"string\";\n}\n\n/**\n * Ensures given value is a safe string.\n *\n * Safe strings allow to prevent CRLF attacks. We use encoding approach inspired by:\n * https://community.veracode.com/s/question/0D53n00007hJJV5CAO/is-cwe-id-117-intended-for-consolelog\n */\nexport function isSafeString(value: unknown): value is string {\n    return isString(value) && encodeURIComponent(value) === value;\n}\n\nexport function isNumber(value: unknown): value is number {\n    return typeof value === \"number\";\n}\nexport function isNotNull<T>(value: T): value is Exclude<T, null> {\n    return value !== null;\n}\nexport function isArrayOfType<T>(elementTypeGuard: Guard<T>, value: unknown): value is T[] {\n    return Array.isArray(value) && value.every((id) => elementTypeGuard(id));\n}\nexport function isStringArray<T>(value: unknown): value is T[] {\n    return isArrayOfType(isString, value);\n}\n\nexport function isSafeStringArray<T>(value: unknown): value is T[] {\n    return isArrayOfType(isSafeString, value);\n}\n\n/**\n * Guards given value is instance of ArrayBuffer.\n */\nexport function isArrayBuffer(value: unknown): value is ArrayBuffer {\n    return value instanceof ArrayBuffer;\n}\n\n/**\n * Guards given value is a typed array.\n */\nexport function isTypedArray<T>(value: unknown): value is T {\n    return value instanceof Object.getPrototypeOf(Uint8Array);\n}\n\n/**\n * Guards given object is not undefined.\n */\nexport function isUndefined<T>(value: unknown): value is T {\n    return typeof value === \"undefined\";\n}\n\n/**\n * Narrow an unknown type to a Record (i.e. a non-null JS object). This holds true for class instances, not just\n * plain objects.\n */\nexport function isRecord(value: unknown): value is UnknownRecord {\n    return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\n/**\n * Check if the value is an arbitrary function\n */\nexport function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n    return typeof value === \"function\";\n}\n\n/**\n * Apply a given type predicate asserting values are of type T to each value in a Record.\n *\n * @param predicate Any unary type predicate\n * @returns A type predicate which takes an UnknownRecord and tests that all its values are of type T\n */\nexport function predicateRecordValues<T>(predicate: (value: unknown) => value is T) {\n    return (value: UnknownRecord): value is UnknownRecord<T> => {\n        for (const v of Object.values(value)) if (!predicate(v)) return false;\n        return true;\n    };\n}\n\n/**\n * Checks whether given value is undefined or a safe URL string.\n *\n * The function checks whether given string is a valid URL with https: protocol.\n *\n * @param urlString URL string to check.\n * @returns True if URL is valid.\n */\nexport function isEmptyOrSafeUrl(urlString: string | undefined): boolean {\n    if (!urlString) return true;\n    try {\n        const url = new URL(urlString);\n        return url.protocol === \"https:\" || url.protocol === \"http:\";\n    } catch {\n        return false;\n    }\n}\n"]}