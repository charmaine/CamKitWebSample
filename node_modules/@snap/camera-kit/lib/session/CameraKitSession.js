import { __awaiter, __decorate, __metadata, __param } from "tslib";
/* eslint-disable @typescript-eslint/member-ordering */
import { filter, firstValueFrom, map, of, takeUntil, tap } from "rxjs";
import { dispatch, forActions, inStates, isAction, isState } from "@snap/state-management";
import { isLens } from "../lens";
import { Injectable } from "../dependency-injection/Injectable";
import { lensCoreFactory } from "../lens-core-module/loader/lensCoreFactory";
import { getTypeName, guard, validate } from "../common/validate";
import { TypedEventTarget } from "../events/TypedEventTarget";
import { TypedCustomEvent } from "../events/TypedCustomEvent";
import { cameraKitSourceError } from "../namedErrors";
import { createMediaStreamSource } from "../media-sources/MediaStreamSource";
import { createVideoSource } from "../media-sources/VideoSource";
import { getLogger } from "../logger/logger";
import { errorLoggingDecorator } from "../logger/errorLoggingDecorator";
import { logEntriesFactory } from "../logger/logEntries";
import { pageVisibilityFactory } from "../common/pageVisibility";
import { LensPerformanceMetrics } from "./LensPerformanceMetrics";
import { lensStateFactory } from "./lensState";
import { sessionStateFactory } from "./sessionState";
import { lensKeyboardFactory } from "./LensKeyboard";
import { isPublicLensError, isSessionError } from "./CameraKitSessionEvents";
const logger = getLogger("CameraKitSession");
const log = errorLoggingDecorator(logger);
function isOptionalRenderTarget(value) {
    return value === "live" || value === "capture" || value === undefined;
}
/**
 * A CameraKitSession represents a single rendering pipeline connecting an input media source to output `<canvas>`
 * elements. When a Lens is applied to the session, CameraKit uses the Lens to transform the input media into rendered
 * output.
 *
 * CameraKitSession is the primary object that applications interact with when integrating the CameraKit SDK.
 *
 * A CameraKitSession instance is obtained by calling {@link CameraKit.createSession}.
 *
 * @example
 * ```ts
 * const cameraKit = await bootstrapCameraKit(config)
 * const session = await cameraKit.createSession()
 * ```
 *
 * @category Rendering
 * @category Lenses
 */
export class CameraKitSession {
    /**
     * @internal
     */
    constructor(
    /**
     * Use this to interact with lenses which require text input.
     */
    keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility) {
        this.keyboard = keyboard;
        this.lensCore = lensCore;
        this.sessionState = sessionState;
        this.lensState = lensState;
        /**
         * Add event listeners here to handle events which occur during the CameraKitSession.
         *
         * **Note:** Applications may want to handle the `error` event, and check the contained error type -- if the type
         * is {@link LensExecutionError}, this means the current lens was unable to render and CameraKit will automatically
         * remove the lens.
         *
         * @example
         * ```ts
         * cameraKitSession.events.addEventListener('error', ({ detail }) => {
         *   if (detail.error.name === 'LensExecutionError') {
         *     console.log(`Lens ${detail.lens.name} encountered an error and was removed. Please pick a different lens.`)
         *   }
         * })
         * ```
         */
        this.events = new TypedEventTarget();
        const outputs = this.lensCore.getOutputCanvases();
        this.output = {
            live: outputs[this.lensCore.CanvasType.Preview.value],
            capture: outputs[this.lensCore.CanvasType.Capture.value],
        };
        this.playing = false;
        this.metrics = new LensPerformanceMetrics(this.lensCore);
        const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch("suspend", this));
        const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch("resume", this));
        this.removePageVisibilityHandlers = () => {
            removeOnHidden();
            removeOnVisible();
        };
        const sessionErrors = logEntries.pipe(filter((entry) => entry.level === "error"), map((entry) => entry.messages.find((e) => e instanceof Error)), filter(isSessionError));
        this.subscriptions = [
            // In case of an abort error, the only option is to destroy the current session,
            // as it becomes inoperable.
            sessionErrors.pipe(filter((error) => error.name === "LensAbortError")).subscribe(() => this.destroy()),
            // In case of LensCore lens execution error, we must remove the lens from rendering
            // NOTE: LensCore doesn't differentiate recoverable vs non-recoverable errors and
            // it is recommened to always remove the lens.
            sessionErrors
                .pipe(filter((error) => error.name === "LensExecutionError"))
                .subscribe(() => this.removeLens()),
            // Report public session errors to apps
            sessionErrors.pipe(filter(isPublicLensError)).subscribe((error) => {
                const state = lensState.getState();
                if (!isState(state, "noLensApplied")) {
                    this.events.dispatchEvent(new TypedCustomEvent("error", { error, lens: state.data }));
                }
                else {
                    // NOTE: at this point the error is already reported, so we can just log a warning
                    logger.warn(new Error("Lens error occurred even though there is no active lens.", {
                        cause: error,
                    }));
                }
            }),
        ];
    }
    /**
     * Apply a Lens to this session.
     *
     * This method will download (and cache) the Lens executable, and then use that Lens for rendering. If the session
     * is currently playing, this will immediately update the rendered output. Otherwise, the new Lens will be used
     * when session playback in resumed.
     *
     * Calling `applyLens` replaces any prior Lens – only one Lens is allowed at a time (per session).
     *
     * **NOTE**: Errors may occur after the Lens is applied. If the Lens encounters errors while rendering,
     * Camera Kit will automatically remove the Lens from the session and emit a {@link LensExecutionError} event.
     * Applications may want to listen for this error and, for example,
     * prevent the Lens from being selected again by the user.
     *
     * ```ts
     * session.events.addEventListener("error", ({ detail }) => {
     *   if (detail.error.name === "LensExecutionError") {
     *     preventFutureLensSelection(detail.lens);
     *     showMessage("We're sorry, but the Lens you selected encountered an error. Please choose a different Lens.");
     *   }
     * });
     * ```
     *
     * @param lens The Lens to apply to this session.
     * @param launchParams: This can optionally be provided to pass some initial data to the lens – only certain lenses
     * expect launch data.
     * @returns A promise which can have the following results:
     * 1. Resolved with `true`: the lens has been applied.
     * 2. Resolved with `false`: the lens has not been applied, but no error occurred – this can happen if a
     * subsequent call to `applyLens` interrupted the lens application.
     * 3. Rejected: the lens has not been applied because an error occurred. This can happen if:
     *   - The lens ID cannot be found in the LensRepository (use LensRepository to load the lens before calling this
     *     method)
     *   - Lens content download fails, or the download of any required lens assets fails.
     *   - An internal failure occurs in the Lens rendering engine when attempting to apply the lens.
     */
    applyLens(lens, launchParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const action = this.lensState.actions.applyLens({ lens, launchParams });
            return firstValueFrom(of(action).pipe(dispatch(this.lensState), 
            // If another applyLens occurs while we're waiting, resolve this applyLens promise early – we're no
            // longer waiting for the requested lens to be applied.
            takeUntil(this.lensState.events.pipe(forActions("applyLens"), filter(([a]) => a !== action))), 
            // If lens application failed, convert this into a rejected promise by throwing the error.
            tap(([a]) => {
                if (isAction(a, "applyLensFailed") && a.data.lens.id === lens.id)
                    throw a.data.error;
            }), inStates("lensApplied"), map(() => true)), 
            // The default value is used if `takeUntil` completes the Observable early – i.e. the lens was not
            // applied (application was interrupted by a new call to `applyLens`), so we'll resolve with `false`.
            { defaultValue: false });
        });
    }
    /**
     * Remove a Lens from this session.
     *
     * When a Lens is removed, rendering continues if the session is playing. It will just render the session input
     * directly to the outputs without any image processing.
     *
     * @returns A promise which can have the following results:
     * 1. Resolved with `true`: the session's rendered output has no lens applied.
     * 2. Resolved with `false`: the current lens has been removed, but a subsequent call to `applyLens` means that the
     * session's rendered output will still have a (new) lens applied.
     * 3. Rejected: the lens has failed to be removed. This can happen if an internal failure occurs in the Lens
     * rendering engine when attempting to remove the lens.
     */
    removeLens() {
        return __awaiter(this, void 0, void 0, function* () {
            if (isState(this.lensState.getState(), "noLensApplied"))
                return true;
            return firstValueFrom(of(this.lensState.actions.removeLens()).pipe(dispatch(this.lensState), 
            // If lens removal failed, convert this into a rejected promise by throwing the error.
            tap(([a]) => {
                if (isAction(a, "removeLensFailed"))
                    throw a.data;
            }), inStates("noLensApplied"), 
            // If applyLens is called while we're waiting for removal, complete immediately – applying the next lens
            // will replace the current one.
            takeUntil(this.lensState.events.pipe(forActions("applyLens"))), map(() => true)), 
            // The default value is used if `takeUntil` completes the Observable early (otherwise firstValueFrom will
            // return a rejected Promise).
            { defaultValue: false });
        });
    }
    /**
     * Start/resume session playback – LensCore will begin rendering frames to the output.
     *
     * If no source has been set for the session, calling `play()` will update the playing state, but no actual image
     * processing will occur until `setSource()` is called.
     *
     * @example
     * ```ts
     * const cameraKitSession = await cameraKit.createSession()
     * await cameraKitSession.setSource(mySource)
     * await cameraKitSession.play()
     *
     * // If you call `play` before `setSource`, the call to `play` will resolve but playback will only begin once a
     * // media source has been set.
     * ```
     *
     * @param target Specify the {@link RenderTarget} to render. Defaults to the `live` RenderTarget.
     * @returns Promise resolves when playback state has been updated. If no source has been set, this means `play` will
     * resolve before any frames are processed -- but once a source is set, frames will immediately begin processing.
     */
    play(target = "live") {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.playing)
                return;
            this.playing = target;
            const type = this.renderTargetToCanvasType(target);
            return this.lensCore.playCanvas({ type }).catch((error) => {
                this.playing = false;
                throw error;
            });
        });
    }
    /**
     * Pause session playback – LensCore will stop rendering frames to the output.
     *
     * @param target Specify the RenderTarget to pause playback. May be either `'live'` or `'capture'`.
     * Default is `'live'`.
     * @returns Promise resolves when playback has stopped.
     */
    pause(target = "live") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.playing)
                return;
            const priorPlayingState = this.playing;
            this.playing = false;
            const type = this.renderTargetToCanvasType(target);
            return this.lensCore.pauseCanvas({ type }).catch((error) => {
                this.playing = priorPlayingState;
                throw error;
            });
        });
    }
    /**
     * Mute all sounds (default SDK state is unmuted).
     *
     * @param fade Do we want audio to fade out?
     */
    mute(fade = false) {
        this.lensCore.setAllSoundsMuted({
            muted: true,
            fade,
        });
    }
    /**
     * Unmute all sounds.
     *
     * @param fade Do we want audio to fade in?
     */
    unmute(fade = false) {
        this.lensCore.setAllSoundsMuted({
            muted: false,
            fade,
        });
    }
    setSource(source, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.safelyDetachSource();
            // For convenience, we allow callers to pass in native objects (e.g. MediaStream) as well as CameraKitSource.
            // Native objects are wrapped in corresponding CameraKitSource classes with default options.
            const cameraKitSource = source instanceof MediaStream
                ? createMediaStreamSource(source, options)
                : source instanceof HTMLVideoElement
                    ? createVideoSource(source, options)
                    : source;
            const priorPlayingState = this.playing;
            this.playing = false;
            // The source will provide its data to LensCore, and use other LensCore APIs (e.g. setRenderSize,
            // setInputTransform) to render the source correctly.
            yield cameraKitSource.attach(this.lensCore, (error) => {
                logger.error(cameraKitSourceError("Error occurred during source attachment.", error));
            });
            // If attachment is successful, we'll update our source so that we can detach it later.
            this.source = cameraKitSource;
            // Finally we'll resume playback, if appropriate.
            if (priorPlayingState) {
                yield this.play(priorPlayingState);
            }
            return cameraKitSource;
        });
    }
    /**
     * Set an FPS limit.
     *
     * This may be useful to reduce CPU/GPU resource usage by CameraKit if, for example, the input
     * media source has a low FPS – CameraKit would then not try to render more frequently than the source produces
     * new frames.
     *
     * This may also be useful to gracefully degrade performance in situations where lowering FPS is preferable over
     * alternatives.
     *
     * @param fpsLimit A maximum FPS, rendering will not exceed this limit
     * @returns Promise is resolved when the limit is successfully set.
     */
    setFPSLimit(fpsLimit) {
        return __awaiter(this, void 0, void 0, function* () {
            // LensCore uses 0 to remove the limit.
            const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;
            return this.lensCore.setFPSLimit({ fps });
        });
    }
    /**
     * Destroy the session.
     *
     * The session will become inoperable. Frame processing stops, and any session-scoped graphical resources are freed.
     */
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.lensCore.clearAllLenses();
                yield this.lensCore.teardown();
            }
            catch (error) {
                // If a LensCore is in an aborted state, the above lines may throw an error.
                // In such cases, we should continue with the cleanup process.
                // We are also not interested in reporting these errors to our backend.
                logger.warn("An error occurred in LensCore during the session termination process.", error);
            }
            this.subscriptions.forEach((sub) => sub.unsubscribe());
            yield this.safelyDetachSource();
            this.removePageVisibilityHandlers();
            this.sessionState.dispatch("destroy", undefined);
        });
    }
    renderTargetToCanvasType(target) {
        return target === "capture" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;
    }
    safelyDetachSource() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.source) {
                try {
                    yield this.source.detach((error) => {
                        logger.error(cameraKitSourceError("Error occurred during source detachment.", error));
                    });
                    // If there's a failure to detach, we will report the error and proceed. Failure to detach may lead to a
                    // memory leak, but it shouldn't prevent us from switching to the new source.
                }
                catch (error) {
                    logger.error(cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error));
                }
            }
        });
    }
}
__decorate([
    validate,
    log,
    __param(0, guard(isLens)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "applyLens", null);
__decorate([
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "removeLens", null);
__decorate([
    validate,
    log,
    __param(0, guard(isOptionalRenderTarget)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "play", null);
__decorate([
    validate,
    log,
    __param(0, guard(isOptionalRenderTarget)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "pause", null);
__decorate([
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], CameraKitSession.prototype, "mute", null);
__decorate([
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], CameraKitSession.prototype, "unmute", null);
__decorate([
    validate,
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "setSource", null);
__decorate([
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "setFPSLimit", null);
__decorate([
    log,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "destroy", null);
/**
 * @internal
 */
export const cameraKitSessionFactory = Injectable("CameraKitSession", [
    lensCoreFactory.token,
    logEntriesFactory.token,
    lensKeyboardFactory.token,
    sessionStateFactory.token,
    lensStateFactory.token,
    pageVisibilityFactory.token,
], (lensCore, logEntries, keyboard, sessionState, lensState, pageVisibility) => new CameraKitSession(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility));
//# sourceMappingURL=CameraKitSession.js.map