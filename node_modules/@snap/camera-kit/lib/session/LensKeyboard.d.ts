import { TypedCustomEvent } from "../events/TypedCustomEvent";
import { TypedEventListener, TypedEventListenerOptions } from "../events/TypedEventTarget";
import { UriHandler } from "../extensions/UriHandlers";
import { Lens } from "../lens/Lens";
import { LensState } from "./lensState";
/**
 * Events emitted by {@link Keyboard}.
 */
export type KeyboardEvents = TypedCustomEvent<"active", {
    element: HTMLTextAreaElement;
    active: boolean;
    lens?: Lens;
}>;
/**
 * Keyboard is an API enabling lenses to consume and render user-generated text.
 *
 * Applications that wish to use lenses that expect user-generated text will need to use this API to integrate text
 * input into their user experience.
 *
 * There are two ways to do this:
 * 1. Add the provided DOM element (an HTMLTextAreaElement) to the page. When the user updates this element with text,
 * that text will be sent to the currently active lens.
 * 2. Use the {@link sendInputToLens} method to send text strings to the currently active lens directly.
 *
 * Lenses will also signal to the application when text input is expected -- applications should add an event listener
 * and ensure the user is able to input text when the `active` event is received.
 *
 * @example
 * ```ts
 * cameraKitSession.keyboard.addEventListener('active', ({ detail }) => {
 *   const { element, active } = detail
 *   if (active) document.body.appendChild(element)
 *   else element.remove()
 * })
 * ```
 *
 * @category Lenses
 */
export type Keyboard = {
    addEventListener: (type: "active", callback: TypedEventListener<KeyboardEvents>, options?: TypedEventListenerOptions) => void;
    removeEventListener: (type: "active", callback: TypedEventListener<KeyboardEvents>) => void;
    /**
     * Get an HTMLTextAreaElement that communicates text to the active Lens.
     */
    getElement: () => HTMLTextAreaElement;
    /**
     * Send text to the active Lens. Also updates the provided HTMLTextAreaElement.
     *
     * @param text String to render. This can include escape sequences, such as the newline character ( \n ) for
     * multi-line input.
     */
    sendInputToLens: (text: string) => void;
    /**
     * Clears the provided HTMLTextAreaElement, and emits the "active" event with `active == false`, allowing the
     * application to e.g. remove relevant text input elements from the DOM.
     */
    dismiss: () => void;
};
/** @internal */
export declare class LensKeyboard {
    private readonly lensState;
    readonly uriHandler: UriHandler;
    private readonly events;
    private readonly element;
    private active;
    private handleReply;
    constructor(lensState: LensState);
    dismiss(): void;
    getElement(): HTMLTextAreaElement;
    sendInputToLens(text: string): void;
    addEventListener(type: "active", callback: TypedEventListener<KeyboardEvents>, options?: TypedEventListenerOptions): void;
    removeEventListener(type: "active", callback: TypedEventListener<KeyboardEvents>): void;
    toPublicInterface(): Keyboard;
    private updateStatus;
}
/**
 * @internal
 */
export declare const lensKeyboardFactory: {
    (args_0: import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"applyLens", {
        lens: Lens;
        launchParams?: import("..").LensLaunchParams | undefined;
    }> | import("@snap/state-management").Action<"downloadComplete", Lens> | import("@snap/state-management").Action<"turnedOn", Lens> | import("@snap/state-management").Action<"resourcesLoaded", Lens> | import("@snap/state-management").Action<"firstFrameProcessed", Lens> | import("@snap/state-management").Action<"applyLensComplete", Lens> | import("@snap/state-management").Action<"applyLensFailed", {
        error: import("./lensState").LensErrors;
        lens: Lens;
    }> | import("@snap/state-management").Action<"applyLensAborted", Lens> | import("@snap/state-management").Action<"removeLens", undefined> | import("@snap/state-management").Action<"turnedOff", Lens> | import("@snap/state-management").Action<"removeLensComplete", undefined> | import("@snap/state-management").Action<"removeLensFailed", Error>, import("@snap/state-management").State<"noLensApplied", undefined> | import("@snap/state-management").State<"applyingLens", Lens> | import("@snap/state-management").State<"lensApplied", Lens>>): LensKeyboard;
    token: "lensKeyboard";
    dependencies: readonly ["lensState"];
};
