{"version":3,"file":"lensState.js","sourceRoot":"","sources":["../../src/session/lensState.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Actions,\n    defineAction,\n    defineActions,\n    defineState,\n    defineStates,\n    dispatch,\n    forActions,\n    inStates,\n    StateMachine,\n} from \"@snap/state-management\";\nimport {\n    catchError,\n    exhaustMap,\n    from,\n    map,\n    merge,\n    mergeMap,\n    Observable,\n    of,\n    switchMap,\n    take,\n    takeUntil,\n    tap,\n} from \"rxjs\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { Lens } from \"../lens/Lens\";\nimport { LensRepository, lensRepositoryFactory } from \"../lens/LensRepository\";\nimport { lensCoreFactory, LensCore } from \"../lens-core-module\";\nimport { AddLensInput } from \"../lens-core-module/generated-types\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport { lensPersistenceStoreFactory } from \"../lens/LensPersistenceStore\";\nimport { createLaunchData, LensLaunchParams } from \"../lens/LensLaunchParams\";\nimport { LegalState, legalStateFactory } from \"../legal/legalState\";\nimport { LensAssetRepository, lensAssetRepositoryFactory } from \"../lens/assets/LensAssetRepository\";\nimport {\n    legalError,\n    LegalError,\n    lensContentValidationError,\n    LensContentValidationError,\n    lensError,\n    LensError,\n} from \"../namedErrors\";\nimport { getLogger } from \"../logger/logger\";\nimport { Timer } from \"../metrics/operational/Timer\";\nimport {\n    operationalMetricReporterFactory,\n    OperationalMetricsReporter,\n} from \"../metrics/operational/operationalMetricsReporter\";\nimport { unsubscribed } from \"../observable-operators/unsubscribed\";\n\nconst logger = getLogger(\"LensState\");\n\nconst createLensState = () => {\n    const actions = defineActions(\n        defineAction(\"applyLens\")<{ lens: Lens; launchParams?: LensLaunchParams }>(),\n        defineAction(\"downloadComplete\")<Lens>(),\n        defineAction(\"turnedOn\")<Lens>(),\n        defineAction(\"resourcesLoaded\")<Lens>(),\n        defineAction(\"firstFrameProcessed\")<Lens>(),\n        defineAction(\"applyLensComplete\")<Lens>(),\n        defineAction(\"applyLensFailed\")<{ error: LensErrors; lens: Lens }>(),\n        defineAction(\"applyLensAborted\")<Lens>(),\n\n        defineAction(\"removeLens\")(),\n        defineAction(\"turnedOff\")<Lens>(),\n        defineAction(\"removeLensComplete\")(),\n        defineAction(\"removeLensFailed\")<Error>()\n    );\n\n    const states = defineStates(\n        defineState(\"noLensApplied\")(),\n        defineState(\"applyingLens\")<Lens>(),\n        defineState(\"lensApplied\")<Lens>()\n    );\n\n    return new StateMachine(actions, states, states.noLensApplied(), (events) =>\n        merge(\n            events.pipe(\n                // We allow a new lens to be applied at any time, no matter the state.\n                inStates(\"noLensApplied\", \"applyingLens\", \"lensApplied\"),\n                forActions(\"applyLens\"),\n                map(([a]) => states.applyingLens(a.data.lens))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensComplete\"),\n                map(([a]) => states.lensApplied(a.data))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensFailed\"),\n                map(() => states.noLensApplied())\n            ),\n            events.pipe(\n                inStates(\"lensApplied\"),\n                forActions(\"removeLensComplete\"),\n                map(() => states.noLensApplied())\n            )\n        )\n    );\n};\n\nexport type LensErrors = LegalError | LensContentValidationError | LensError;\n\nexport type LensState = ReturnType<typeof createLensState>;\n\nexport const lensStateFactory = Injectable(\n    \"lensState\",\n    [\n        lensCoreFactory.token,\n        lensRepositoryFactory.token,\n        lensAssetRepositoryFactory.token,\n        lensPersistenceStoreFactory.token,\n        legalStateFactory.token,\n        operationalMetricReporterFactory.token,\n    ] as const,\n    (\n        lensCore: LensCore,\n        lensRepository: LensRepository,\n        lensAssetRepository: LensAssetRepository,\n        lensPersistence: IndexedDBPersistence<ArrayBuffer>,\n        legalState: LegalState,\n        operationalMetricsReporter: OperationalMetricsReporter\n    ): LensState => {\n        const lensState = createLensState();\n        let firstLensApply = true;\n\n        /**\n         * Apply lens\n         */\n        lensState.events\n            .pipe(\n                forActions(\"applyLens\"),\n\n                // Determine the legal state (e.g. terms have been accepted). Using exhaustMap means while we are\n                // ascertaining legal status (which may include prompting the end user to accept terms), we will ignore\n                // any new applyLens actions.\n                exhaustMap(([a]) =>\n                    of(legalState.actions.requestLegalPrompt()).pipe(\n                        dispatch(legalState),\n                        inStates(\"accepted\", \"rejected\"),\n                        take(1),\n                        map(([, { name }]) => {\n                            if (name === \"accepted\") return a;\n                            return lensState.actions.applyLensFailed({\n                                error: legalError(\n                                    `Failed to apply lens ${a.data.lens.id}. Required legal terms were not accepted.`\n                                ),\n                                lens: a.data.lens,\n                            });\n                        })\n                    )\n                ),\n\n                // The use of switchMap is important so that if we get a new applyLens action while we're still\n                // downloading lens content for a previously-requested lens, we can cancel those requests and ensure\n                // that lenses are applied in the order they're requested.\n                switchMap((a) => {\n                    if (a.name === \"applyLensFailed\") return of(a);\n\n                    const { lens } = a.data;\n                    // Convenience method making dispatching an action with Lens data less verbose.\n                    const dispatch = (action: Extract<Actions<LensState>, { data: Lens }>[\"name\"]) => {\n                        lensState.dispatch(action, lens);\n                    };\n\n                    // We record if this was the first lens apply for this page load, since there may be additional\n                    // sources of latency (e.g. remote configuration that needs to be loaded) on the first apply that\n                    // are not present for subsequent applies.\n                    const applyTimer = new Timer(\"lens\").mark(\"apply\", { first: `${firstLensApply}` });\n                    firstLensApply = false;\n\n                    return of(a.data).pipe(\n                        mergeMap(({ lens, launchParams }) =>\n                            // If retrieval throws an error, we still want to proceed with the lens\n                            // because persisted data is not a necessity.\n                            from(lensPersistence.retrieve(lens.id).catch(() => undefined)).pipe(\n                                map((persistentStore) => ({ lens, launchParams, persistentStore }))\n                            )\n                        ),\n\n                        map(({ lens, launchParams, persistentStore }) => {\n                            const launchData = createLaunchData({\n                                launchParams,\n                                persistentStore,\n                            });\n\n                            const lensDetails = lensRepository.getLensMetadata(lens.id);\n                            if (!lensDetails) {\n                                throw new Error(\n                                    `Cannot apply lens ${lens.id}. It has not been loaded by the Lens ` +\n                                        `repository. Use CameraKit.lensRepository.loadLens (or loadLensGroups) ` +\n                                        `to load lens metadata before calling CameraKitSession.applyLens.`\n                                );\n                            }\n\n                            const { content } = lensDetails;\n                            if (!content) {\n                                throw new Error(\n                                    `Cannot apply lens ${lens.id}. Metadata retrieved for this lens does not ` +\n                                        `include the lens content URL.`\n                                );\n                            }\n\n                            return { lens, launchData, content };\n                        }),\n\n                        // Load lens assets and the lens itself in parallel. Both count toward lens download time.\n                        // TODO: use RxJS fetch utilities so that these requests can be cancelled on unsubscribe.\n                        mergeMap(({ lens, launchData, content }) => {\n                            const networkTimer = applyTimer.mark(\"network\");\n\n                            return from(\n                                Promise.all([\n                                    lensRepository.getLensContent(lens).finally(() => networkTimer.measure(\"lens\")),\n                                    content.assetManifest.length > 0\n                                        ? lensAssetRepository\n                                              .cacheAssets(content.assetManifest, lens)\n                                              .finally(() => networkTimer.measure(\"assets\"))\n                                        : Promise.resolve(),\n                                ])\n                            ).pipe(\n                                tap(() => {\n                                    networkTimer.measure();\n                                    lensState.dispatch(\"downloadComplete\", lens);\n                                }),\n                                map(([{ lensBuffer, lensChecksum }]): AddLensInput => {\n                                    // NOTE: cached array buffer has to be copied each time in order to be reused,\n                                    // otherwise the original cached copy would be detached by LensCore\n                                    // One optimization can be done here: do not copy the array if getLensContent()\n                                    // returned uncached buffer\n                                    const lensDataBuffer = lensBuffer.slice(0);\n                                    // LensCore chokes trying if launchData is set to undefined; we must omit it.\n                                    return launchData === undefined\n                                        ? { lensId: lens.id, lensDataBuffer, lensChecksum }\n                                        : { lensId: lens.id, lensDataBuffer, lensChecksum, launchData };\n                                })\n                            );\n                        }),\n\n                        // If removeLens is dispatched while downloading, cancel download, don't apply the lens.\n                        takeUntil(lensState.events.pipe(forActions(\"removeLens\"))),\n\n                        // Once the lens has downloaded, we can call replaceLenses. We're not concerned about\n                        // waiting for prior in-progress calls to replaceLenses to complete, because LensCore\n                        // guarantees that calls to replaceLenses will always be processed sequentially in the order\n                        // they are received.\n                        mergeMap(\n                            (lensInput) =>\n                                new Observable<Actions<LensState>>((subscriber) => {\n                                    const coreTimer = applyTimer.mark(\"core\");\n\n                                    // replaceLenses has the property that if it fails, LensCore guarantees that no\n                                    // lenses are active – so we can safely dispatch applyLensFailed and transition\n                                    // to noLensApplied state.\n                                    lensCore\n                                        .replaceLenses({\n                                            lenses: [\n                                                {\n                                                    ...lensInput,\n                                                    onTurnOn: () => dispatch(\"turnedOn\"),\n                                                    onResourcesLoaded: () => dispatch(\"resourcesLoaded\"),\n\n                                                    // onFirstFrameProcessed marks the end of the lens application for\n                                                    // the end-user -- this is when they see the newly applied lens\n                                                    // begin to render. As such, this is where we stop our overall\n                                                    // latency measurement and report latency metrics.\n                                                    onFirstFrameProcessed: () => {\n                                                        coreTimer.measure(\"first-frame\");\n                                                        applyTimer.measure(\"success\");\n                                                        applyTimer.stopAndReport(operationalMetricsReporter);\n                                                        dispatch(\"firstFrameProcessed\");\n                                                    },\n                                                    onTurnOff: () => dispatch(\"turnedOff\"),\n                                                },\n                                            ],\n                                        })\n                                        .then(() => {\n                                            coreTimer.measure(\"success\");\n\n                                            // We emit applyLensComplete (and applyLensFailed, below) on an\n                                            // Observable, which is piped to `dispatch` – this allows `switchMap` to\n                                            // properly cancel the dispatch of these actions if a new applyLens\n                                            // arrives while we're waiting for onSuccess/onFailure.\n                                            //\n                                            // That's desirable behavior, because we don't want the applyingLens\n                                            // state due to a *subsequent applyLens action* to be transitioned to\n                                            // lensApplied by this action.\n                                            subscriber.next(lensState.actions.applyLensComplete(lens));\n                                            subscriber.complete();\n                                        })\n                                        .catch((lensCoreError) => {\n                                            coreTimer.measure(\"failure\");\n                                            applyTimer.measure(\"failure\");\n                                            applyTimer.stopAndReport(operationalMetricsReporter);\n\n                                            const message = `Failed to apply lens ${lensInput.lensId}.`;\n                                            const error = /validation failed/.test(lensCoreError.message)\n                                                ? lensContentValidationError(message, lensCoreError)\n                                                : lensError(message, lensCoreError);\n\n                                            subscriber.next(lensState.actions.applyLensFailed({ error, lens }));\n                                            subscriber.complete();\n                                        });\n                                })\n                        ),\n                        catchError((error: LensErrors) => {\n                            applyTimer.measure(\"failure\");\n                            applyTimer.stopAndReport(operationalMetricsReporter);\n                            return of(lensState.actions.applyLensFailed({ error, lens }));\n                        }),\n\n                        // If a new applyLens is received, `switchMap` will unsubscribe from this inner observable,\n                        // which stops the current lens application. When this happens we can record a separate metric\n                        // to measure aborted lens applications.\n                        unsubscribed(() => {\n                            applyTimer.measure(\"abort\");\n                            applyTimer.stopAndReport(operationalMetricsReporter);\n                        })\n                    );\n                }),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        /**\n         * Remove lens\n         */\n        lensState.events\n            .pipe(\n                inStates(\"lensApplied\", \"noLensApplied\"),\n                forActions(\"removeLens\"),\n                mergeMap(\n                    () =>\n                        new Observable<Actions<LensState>>((subscriber) => {\n                            lensCore\n                                .clearAllLenses()\n                                .then(() => {\n                                    subscriber.next(lensState.actions.removeLensComplete());\n                                    subscriber.complete();\n                                })\n                                .catch((lensCoreError) => {\n                                    const error = new Error(\"Failed to remove lenses.\", { cause: lensCoreError });\n                                    subscriber.next(lensState.actions.removeLensFailed(error));\n                                    subscriber.complete();\n                                });\n                        })\n                ),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        lensState.events\n            .pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"removeLens\"),\n                switchMap(([a]) =>\n                    lensState.events.pipe(\n                        // Wait to remove the lens until it has been applied.\n                        inStates(\"lensApplied\"),\n                        // But cancel the removal if a new applyLens supercedes the current lens. The goal here is to\n                        // make sure the latest apply/remove pre-empts any previous request to apply/remove.\n                        takeUntil(lensState.events.pipe(forActions(\"applyLens\"))),\n                        map(() => a)\n                    )\n                ),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        // Log transitions\n        lensState.events.subscribe(([a, s]) => logger.debug(`Action: \"${a.name}\", state: \"${s.name}\"`));\n\n        return lensState;\n    }\n);\n"]}