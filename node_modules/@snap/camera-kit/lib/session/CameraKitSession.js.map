{"version":3,"file":"CameraKitSession.js","sourceRoot":"","sources":["../../src/session/CameraKitSession.ts"],"names":[],"mappings":";AAAA,uDAAuD;AACvD,OAAO,EAAE,MAAM,EAAE,cAAc,EAAE,GAAG,EAAc,EAAE,EAAgB,SAAS,EAAE,GAAG,EAAE,MAAM,MAAM,CAAC;AACjG,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,wBAAwB,CAAC;AAC3F,OAAO,EAAQ,MAAM,EAAE,MAAM,SAAS,CAAC;AAEvC,OAAO,EAAE,UAAU,EAAE,MAAM,oCAAoC,CAAC;AAChE,OAAO,EAAE,eAAe,EAAE,MAAM,4CAA4C,CAAC;AAE7E,OAAO,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAClE,OAAO,EAAE,gBAAgB,EAAE,MAAM,4BAA4B,CAAC;AAC9D,OAAO,EAAE,gBAAgB,EAAE,MAAM,4BAA4B,CAAC;AAE9D,OAAO,EAAE,oBAAoB,EAAsB,MAAM,gBAAgB,CAAC;AAC1E,OAAO,EAAE,uBAAuB,EAAE,MAAM,oCAAoC,CAAC;AAC7E,OAAO,EAAE,iBAAiB,EAAE,MAAM,8BAA8B,CAAC;AACjE,OAAO,EAAE,SAAS,EAAY,MAAM,kBAAkB,CAAC;AACvD,OAAO,EAAE,qBAAqB,EAAE,MAAM,iCAAiC,CAAC;AACxE,OAAO,EAAE,iBAAiB,EAAE,MAAM,sBAAsB,CAAC;AACzD,OAAO,EAAkB,qBAAqB,EAAE,MAAM,0BAA0B,CAAC;AACjF,OAAO,EAAE,sBAAsB,EAAE,MAAM,0BAA0B,CAAC;AAClE,OAAO,EAAE,gBAAgB,EAAa,MAAM,aAAa,CAAC;AAC1D,OAAO,EAAgB,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;AACnE,OAAO,EAAY,mBAAmB,EAAgB,MAAM,gBAAgB,CAAC;AAC7E,OAAO,EAA0B,iBAAiB,EAAE,cAAc,EAAE,MAAM,0BAA0B,CAAC;AAErG,MAAM,MAAM,GAAG,SAAS,CAAC,kBAAkB,CAAC,CAAC;AAC7C,MAAM,GAAG,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC;AAE1C,SAAS,sBAAsB,CAAC,KAAc;IAC1C,OAAO,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,CAAC;AAC1E,CAAC;AAaD;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,OAAO,gBAAgB;IAkDzB;;OAEG;IACH;IACI;;OAEG;IACa,QAAkB,EAEjB,QAAkB,EAClB,YAA0B,EAC1B,SAAoB,EACrC,UAAgC,EAChC,cAA8B;QANd,aAAQ,GAAR,QAAQ,CAAU;QAEjB,aAAQ,GAAR,QAAQ,CAAU;QAClB,iBAAY,GAAZ,YAAY,CAAc;QAC1B,cAAS,GAAT,SAAS,CAAW;QAtCzC;;;;;;;;;;;;;;;WAeG;QACM,WAAM,GAAG,IAAI,gBAAgB,EAA0B,CAAC;QA0B7D,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE,CAAC;QAClD,IAAI,CAAC,MAAM,GAAG;YACV,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC;YACrD,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC;SAC3D,CAAC;QACF,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEzD,MAAM,cAAc,GAAG,cAAc,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;QACtG,MAAM,eAAe,GAAG,cAAc,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;QACvG,IAAI,CAAC,4BAA4B,GAAG,GAAG,EAAE;YACrC,cAAc,EAAE,CAAC;YACjB,eAAe,EAAE,CAAC;QACtB,CAAC,CAAC;QAEF,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CACjC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,KAAK,OAAO,CAAC,EAC1C,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,YAAY,KAAK,CAAC,CAAC,EAC9D,MAAM,CAAC,cAAc,CAAC,CACzB,CAAC;QAEF,IAAI,CAAC,aAAa,GAAG;YACjB,gFAAgF;YAChF,4BAA4B;YAC5B,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,gBAAgB,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YAEtG,mFAAmF;YACnF,iFAAiF;YACjF,8CAA8C;YAC9C,aAAa;iBACR,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,oBAAoB,CAAC,CAAC;iBAC5D,SAAS,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YAEvC,uCAAuC;YACvC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC9D,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;gBACnC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,eAAe,CAAC,EAAE;oBAClC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,gBAAgB,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;iBACzF;qBAAM;oBACH,kFAAkF;oBAClF,MAAM,CAAC,IAAI,CACP,IAAI,KAAK,CAAC,0DAA0D,EAAE;wBAClE,KAAK,EAAE,KAAK;qBACf,CAAC,CACL,CAAC;iBACL;YACL,CAAC,CAAC;SACL,CAAC;IACN,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IAGG,SAAS,CAAgB,IAAU,EAAE,YAA+B;;YACtE,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;YACxE,OAAO,cAAc,CACjB,EAAE,CAAC,MAAM,CAAC,CAAC,IAAI,CACX,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;YAExB,mGAAmG;YACnG,uDAAuD;YACvD,SAAS,CACL,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CACtB,UAAU,CAAC,WAAW,CAAC,EACvB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,MAAM,CAAC,CAChC,CACJ;YAED,0FAA0F;YAC1F,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;gBACR,IAAI,QAAQ,CAAC,CAAC,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE;oBAAE,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;YACzF,CAAC,CAAC,EAEF,QAAQ,CAAC,aAAa,CAAC,EAEvB,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAClB;YACD,kGAAkG;YAClG,qGAAqG;YACrG,EAAE,YAAY,EAAE,KAAK,EAAE,CAC1B,CAAC;QACN,CAAC;KAAA;IAED;;;;;;;;;;;;OAYG;IAEG,UAAU;;YACZ,IAAI,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,eAAe,CAAC;gBAAE,OAAO,IAAI,CAAC;YACrE,OAAO,cAAc,CACjB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,IAAI,CACxC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;YACxB,sFAAsF;YACtF,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;gBACR,IAAI,QAAQ,CAAC,CAAC,EAAE,kBAAkB,CAAC;oBAAE,MAAM,CAAC,CAAC,IAAI,CAAC;YACtD,CAAC,CAAC,EACF,QAAQ,CAAC,eAAe,CAAC;YAEzB,wGAAwG;YACxG,gCAAgC;YAChC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,EAC9D,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAClB;YACD,yGAAyG;YACzG,8BAA8B;YAC9B,EAAE,YAAY,EAAE,KAAK,EAAE,CAC1B,CAAC;QACN,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IAGG,IAAI,CAAgC,SAAuB,MAAM;;YACnE,IAAI,IAAI,CAAC,OAAO;gBAAE,OAAO;YACzB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YAEtB,MAAM,IAAI,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC;YACnD,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACtD,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBACrB,MAAM,KAAK,CAAC;YAChB,CAAC,CAAC,CAAC;QACP,CAAC;KAAA;IAED;;;;;;OAMG;IAGG,KAAK,CAAgC,SAAuB,MAAM;;YACpE,IAAI,CAAC,IAAI,CAAC,OAAO;gBAAE,OAAO;YAC1B,MAAM,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC;YACvC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YAErB,MAAM,IAAI,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC;YACnD,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;gBACvD,IAAI,CAAC,OAAO,GAAG,iBAAiB,CAAC;gBACjC,MAAM,KAAK,CAAC;YAChB,CAAC,CAAC,CAAC;QACP,CAAC;KAAA;IAED;;;;OAIG;IAEH,IAAI,CAAC,OAAgB,KAAK;QACtB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC;YAC5B,KAAK,EAAE,IAAI;YACX,IAAI;SACP,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IAEH,MAAM,CAAC,OAAgB,KAAK;QACxB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC;YAC5B,KAAK,EAAE,KAAK;YACZ,IAAI;SACP,CAAC,CAAC;IACP,CAAC;IAqCK,SAAS,CACX,MAAwD,EACxD,UAAiE,EAAE;;YAEnE,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAEhC,6GAA6G;YAC7G,4FAA4F;YAC5F,MAAM,eAAe,GACjB,MAAM,YAAY,WAAW;gBACzB,CAAC,CAAC,uBAAuB,CAAC,MAAM,EAAE,OAAO,CAAC;gBAC1C,CAAC,CAAC,MAAM,YAAY,gBAAgB;oBACpC,CAAC,CAAC,iBAAiB,CAAC,MAAM,EAAE,OAAO,CAAC;oBACpC,CAAC,CAAC,MAAM,CAAC;YAEjB,MAAM,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC;YACvC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YAErB,iGAAiG;YACjG,qDAAqD;YACrD,MAAM,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,EAAE;gBAClD,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,0CAA0C,EAAE,KAAK,CAAC,CAAC,CAAC;YAC1F,CAAC,CAAC,CAAC;YAEH,uFAAuF;YACvF,IAAI,CAAC,MAAM,GAAG,eAAe,CAAC;YAE9B,iDAAiD;YACjD,IAAI,iBAAiB,EAAE;gBACnB,MAAM,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;aACtC;YAED,OAAO,eAAe,CAAC;QAC3B,CAAC;KAAA;IAED;;;;;;;;;;;;OAYG;IAEG,WAAW,CAAC,QAAgB;;YAC9B,uCAAuC;YACvC,MAAM,GAAG,GAAG,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/D,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;QAC9C,CAAC;KAAA;IAED;;;;OAIG;IAEG,OAAO;;YACT,IAAI;gBACA,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,CAAC;gBACrC,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;aAClC;YAAC,OAAO,KAAK,EAAE;gBACZ,4EAA4E;gBAC5E,8DAA8D;gBAC9D,uEAAuE;gBACvE,MAAM,CAAC,IAAI,CAAC,uEAAuE,EAAE,KAAK,CAAC,CAAC;aAC/F;YACD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;YACvD,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAChC,IAAI,CAAC,4BAA4B,EAAE,CAAC;YACpC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QACrD,CAAC;KAAA;IAEO,wBAAwB,CAAC,MAAoB;QACjD,OAAO,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC;IACtG,CAAC;IAEa,kBAAkB;;YAC5B,IAAI,IAAI,CAAC,MAAM,EAAE;gBACb,IAAI;oBACA,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;wBAC/B,MAAM,CAAC,KAAK,CAAC,oBAAoB,CAAC,0CAA0C,EAAE,KAAK,CAAC,CAAC,CAAC;oBAC1F,CAAC,CAAC,CAAC;oBACH,wGAAwG;oBACxG,6EAA6E;iBAChF;gBAAC,OAAO,KAAK,EAAE;oBACZ,MAAM,CAAC,KAAK,CACR,oBAAoB,CAAC,kCAAkC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,KAAK,CAAC,CACpG,CAAC;iBACL;aACJ;QACL,CAAC;KAAA;CACJ;AArRS;IAFL,QAAQ;IACR,GAAG;IACa,WAAA,KAAK,CAAC,MAAM,CAAC,CAAA;;;;iDA4B7B;AAgBK;IADL,GAAG;;;;kDAqBH;AAwBK;IAFL,QAAQ;IACR,GAAG;IACQ,WAAA,KAAK,CAAC,sBAAsB,CAAC,CAAA;;;;4CASxC;AAWK;IAFL,QAAQ;IACR,GAAG;IACS,WAAA,KAAK,CAAC,sBAAsB,CAAC,CAAA;;;;6CAUzC;AAQD;IADC,GAAG;;;;4CAMH;AAQD;IADC,GAAG;;;;8CAMH;AAqCK;IAFL,QAAQ;IACR,GAAG;;;;iDAkCH;AAgBK;IADL,GAAG;;;;mDAKH;AAQK;IADL,GAAG;;;;+CAeH;AAuBL;;GAEG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,UAAU,CAC7C,kBAAkB,EAClB;IACI,eAAe,CAAC,KAAK;IACrB,iBAAiB,CAAC,KAAK;IACvB,mBAAmB,CAAC,KAAK;IACzB,mBAAmB,CAAC,KAAK;IACzB,gBAAgB,CAAC,KAAK;IACtB,qBAAqB,CAAC,KAAK;CACrB,EACV,CACI,QAAkB,EAClB,UAAgC,EAChC,QAAsB,EACtB,YAA0B,EAC1B,SAAoB,EACpB,cAA8B,EAChC,EAAE,CAAC,IAAI,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,cAAc,CAAC,CACrG,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\nimport { filter, firstValueFrom, map, Observable, of, Subscription, takeUntil, tap } from \"rxjs\";\nimport { dispatch, forActions, inStates, isAction, isState } from \"@snap/state-management\";\nimport { Lens, isLens } from \"../lens\";\nimport { CanvasType, LensCore } from \"../lens-core-module\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { lensCoreFactory } from \"../lens-core-module/loader/lensCoreFactory\";\nimport { LensLaunchParams } from \"../lens/LensLaunchParams\";\nimport { getTypeName, guard, validate } from \"../common/validate\";\nimport { TypedEventTarget } from \"../events/TypedEventTarget\";\nimport { TypedCustomEvent } from \"../events/TypedCustomEvent\";\nimport { CameraKitDeviceInfo, CameraKitDeviceOptions, CameraKitSource } from \"../media-sources/CameraKitSource\";\nimport { cameraKitSourceError, LensExecutionError } from \"../namedErrors\";\nimport { createMediaStreamSource } from \"../media-sources/MediaStreamSource\";\nimport { createVideoSource } from \"../media-sources/VideoSource\";\nimport { getLogger, LogEntry } from \"../logger/logger\";\nimport { errorLoggingDecorator } from \"../logger/errorLoggingDecorator\";\nimport { logEntriesFactory } from \"../logger/logEntries\";\nimport { PageVisibility, pageVisibilityFactory } from \"../common/pageVisibility\";\nimport { LensPerformanceMetrics } from \"./LensPerformanceMetrics\";\nimport { lensStateFactory, LensState } from \"./lensState\";\nimport { SessionState, sessionStateFactory } from \"./sessionState\";\nimport { Keyboard, lensKeyboardFactory, LensKeyboard } from \"./LensKeyboard\";\nimport { CameraKitSessionEvents, isPublicLensError, isSessionError } from \"./CameraKitSessionEvents\";\n\nconst logger = getLogger(\"CameraKitSession\");\nconst log = errorLoggingDecorator(logger);\n\nfunction isOptionalRenderTarget(value: unknown): value is RenderTarget | undefined {\n    return value === \"live\" || value === \"capture\" || value === undefined;\n}\n\n/**\n * Enumerates the supported render targets.\n *\n * Lenses may render to different render targets, as designed by the lens creator. In CameraKit, it's possible to choose\n * which render target to render, and the result for each target is available as a separate `<canvas>` element.\n *\n * @category Rendering\n * @category Lenses\n */\nexport type RenderTarget = \"live\" | \"capture\";\n\n/**\n * A CameraKitSession represents a single rendering pipeline connecting an input media source to output `<canvas>`\n * elements. When a Lens is applied to the session, CameraKit uses the Lens to transform the input media into rendered\n * output.\n *\n * CameraKitSession is the primary object that applications interact with when integrating the CameraKit SDK.\n *\n * A CameraKitSession instance is obtained by calling {@link CameraKit.createSession}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(config)\n * const session = await cameraKit.createSession()\n * ```\n *\n * @category Rendering\n * @category Lenses\n */\nexport class CameraKitSession {\n    /**\n     * CameraKitSession renders video output to a `<canvas>` element. In fact, each session contains two canvas outputs\n     * corresponding to the RenderTargets used by Lens creators, when using LensStudio to create a Lens.\n     *\n     * The `live` output renders content suitable for the Lens user (e.g. it may contain additional UI elements\n     * applicable only to the person applying the lens). The `capture` output renders content suitable for sharing with\n     * other users (e.g. sent to the other members of a video call, or saved to disk for sharing later).\n     *\n     * For many lenses, these outputs are identical – but each lens is free to render differently, based on its own\n     * use-case.\n     */\n    readonly output: {\n        live: HTMLCanvasElement;\n        capture: HTMLCanvasElement;\n    };\n\n    /**\n     * Indicates whether or not the session is currently rendering. If `false`, rendering is stopped. Otherwise the\n     * value indicates which output is being rendered.\n     */\n    playing: false | RenderTarget;\n\n    /**\n     * Add event listeners here to handle events which occur during the CameraKitSession.\n     *\n     * **Note:** Applications may want to handle the `error` event, and check the contained error type -- if the type\n     * is {@link LensExecutionError}, this means the current lens was unable to render and CameraKit will automatically\n     * remove the lens.\n     *\n     * @example\n     * ```ts\n     * cameraKitSession.events.addEventListener('error', ({ detail }) => {\n     *   if (detail.error.name === 'LensExecutionError') {\n     *     console.log(`Lens ${detail.lens.name} encountered an error and was removed. Please pick a different lens.`)\n     *   }\n     * })\n     * ```\n     */\n    readonly events = new TypedEventTarget<CameraKitSessionEvents>();\n\n    /**\n     * Use this to measure current lens performance.\n     */\n    readonly metrics: LensPerformanceMetrics;\n\n    private readonly removePageVisibilityHandlers: () => void;\n    private source?: CameraKitSource;\n    private subscriptions: Subscription[];\n\n    /**\n     * @internal\n     */\n    constructor(\n        /**\n         * Use this to interact with lenses which require text input.\n         */\n        public readonly keyboard: Keyboard,\n\n        private readonly lensCore: LensCore,\n        private readonly sessionState: SessionState,\n        private readonly lensState: LensState,\n        logEntries: Observable<LogEntry>,\n        pageVisibility: PageVisibility\n    ) {\n        const outputs = this.lensCore.getOutputCanvases();\n        this.output = {\n            live: outputs[this.lensCore.CanvasType.Preview.value],\n            capture: outputs[this.lensCore.CanvasType.Capture.value],\n        };\n        this.playing = false;\n\n        this.metrics = new LensPerformanceMetrics(this.lensCore);\n\n        const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch(\"suspend\", this));\n        const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch(\"resume\", this));\n        this.removePageVisibilityHandlers = () => {\n            removeOnHidden();\n            removeOnVisible();\n        };\n\n        const sessionErrors = logEntries.pipe(\n            filter((entry) => entry.level === \"error\"),\n            map((entry) => entry.messages.find((e) => e instanceof Error)),\n            filter(isSessionError)\n        );\n\n        this.subscriptions = [\n            // In case of an abort error, the only option is to destroy the current session,\n            // as it becomes inoperable.\n            sessionErrors.pipe(filter((error) => error.name === \"LensAbortError\")).subscribe(() => this.destroy()),\n\n            // In case of LensCore lens execution error, we must remove the lens from rendering\n            // NOTE: LensCore doesn't differentiate recoverable vs non-recoverable errors and\n            // it is recommened to always remove the lens.\n            sessionErrors\n                .pipe(filter((error) => error.name === \"LensExecutionError\"))\n                .subscribe(() => this.removeLens()),\n\n            // Report public session errors to apps\n            sessionErrors.pipe(filter(isPublicLensError)).subscribe((error) => {\n                const state = lensState.getState();\n                if (!isState(state, \"noLensApplied\")) {\n                    this.events.dispatchEvent(new TypedCustomEvent(\"error\", { error, lens: state.data }));\n                } else {\n                    // NOTE: at this point the error is already reported, so we can just log a warning\n                    logger.warn(\n                        new Error(\"Lens error occurred even though there is no active lens.\", {\n                            cause: error,\n                        })\n                    );\n                }\n            }),\n        ];\n    }\n\n    /**\n     * Apply a Lens to this session.\n     *\n     * This method will download (and cache) the Lens executable, and then use that Lens for rendering. If the session\n     * is currently playing, this will immediately update the rendered output. Otherwise, the new Lens will be used\n     * when session playback in resumed.\n     *\n     * Calling `applyLens` replaces any prior Lens – only one Lens is allowed at a time (per session).\n     *\n     * **NOTE**: Errors may occur after the Lens is applied. If the Lens encounters errors while rendering,\n     * Camera Kit will automatically remove the Lens from the session and emit a {@link LensExecutionError} event.\n     * Applications may want to listen for this error and, for example,\n     * prevent the Lens from being selected again by the user.\n     *\n     * ```ts\n     * session.events.addEventListener(\"error\", ({ detail }) => {\n     *   if (detail.error.name === \"LensExecutionError\") {\n     *     preventFutureLensSelection(detail.lens);\n     *     showMessage(\"We're sorry, but the Lens you selected encountered an error. Please choose a different Lens.\");\n     *   }\n     * });\n     * ```\n     *\n     * @param lens The Lens to apply to this session.\n     * @param launchParams: This can optionally be provided to pass some initial data to the lens – only certain lenses\n     * expect launch data.\n     * @returns A promise which can have the following results:\n     * 1. Resolved with `true`: the lens has been applied.\n     * 2. Resolved with `false`: the lens has not been applied, but no error occurred – this can happen if a\n     * subsequent call to `applyLens` interrupted the lens application.\n     * 3. Rejected: the lens has not been applied because an error occurred. This can happen if:\n     *   - The lens ID cannot be found in the LensRepository (use LensRepository to load the lens before calling this\n     *     method)\n     *   - Lens content download fails, or the download of any required lens assets fails.\n     *   - An internal failure occurs in the Lens rendering engine when attempting to apply the lens.\n     */\n    @validate\n    @log\n    async applyLens(@guard(isLens) lens: Lens, launchParams?: LensLaunchParams): Promise<boolean> {\n        const action = this.lensState.actions.applyLens({ lens, launchParams });\n        return firstValueFrom(\n            of(action).pipe(\n                dispatch(this.lensState),\n\n                // If another applyLens occurs while we're waiting, resolve this applyLens promise early – we're no\n                // longer waiting for the requested lens to be applied.\n                takeUntil(\n                    this.lensState.events.pipe(\n                        forActions(\"applyLens\"),\n                        filter(([a]) => a !== action)\n                    )\n                ),\n\n                // If lens application failed, convert this into a rejected promise by throwing the error.\n                tap(([a]) => {\n                    if (isAction(a, \"applyLensFailed\") && a.data.lens.id === lens.id) throw a.data.error;\n                }),\n\n                inStates(\"lensApplied\"),\n\n                map(() => true)\n            ),\n            // The default value is used if `takeUntil` completes the Observable early – i.e. the lens was not\n            // applied (application was interrupted by a new call to `applyLens`), so we'll resolve with `false`.\n            { defaultValue: false }\n        );\n    }\n\n    /**\n     * Remove a Lens from this session.\n     *\n     * When a Lens is removed, rendering continues if the session is playing. It will just render the session input\n     * directly to the outputs without any image processing.\n     *\n     * @returns A promise which can have the following results:\n     * 1. Resolved with `true`: the session's rendered output has no lens applied.\n     * 2. Resolved with `false`: the current lens has been removed, but a subsequent call to `applyLens` means that the\n     * session's rendered output will still have a (new) lens applied.\n     * 3. Rejected: the lens has failed to be removed. This can happen if an internal failure occurs in the Lens\n     * rendering engine when attempting to remove the lens.\n     */\n    @log\n    async removeLens(): Promise<boolean> {\n        if (isState(this.lensState.getState(), \"noLensApplied\")) return true;\n        return firstValueFrom(\n            of(this.lensState.actions.removeLens()).pipe(\n                dispatch(this.lensState),\n                // If lens removal failed, convert this into a rejected promise by throwing the error.\n                tap(([a]) => {\n                    if (isAction(a, \"removeLensFailed\")) throw a.data;\n                }),\n                inStates(\"noLensApplied\"),\n\n                // If applyLens is called while we're waiting for removal, complete immediately – applying the next lens\n                // will replace the current one.\n                takeUntil(this.lensState.events.pipe(forActions(\"applyLens\"))),\n                map(() => true)\n            ),\n            // The default value is used if `takeUntil` completes the Observable early (otherwise firstValueFrom will\n            // return a rejected Promise).\n            { defaultValue: false }\n        );\n    }\n\n    /**\n     * Start/resume session playback – LensCore will begin rendering frames to the output.\n     *\n     * If no source has been set for the session, calling `play()` will update the playing state, but no actual image\n     * processing will occur until `setSource()` is called.\n     *\n     * @example\n     * ```ts\n     * const cameraKitSession = await cameraKit.createSession()\n     * await cameraKitSession.setSource(mySource)\n     * await cameraKitSession.play()\n     *\n     * // If you call `play` before `setSource`, the call to `play` will resolve but playback will only begin once a\n     * // media source has been set.\n     * ```\n     *\n     * @param target Specify the {@link RenderTarget} to render. Defaults to the `live` RenderTarget.\n     * @returns Promise resolves when playback state has been updated. If no source has been set, this means `play` will\n     * resolve before any frames are processed -- but once a source is set, frames will immediately begin processing.\n     */\n    @validate\n    @log\n    async play(@guard(isOptionalRenderTarget) target: RenderTarget = \"live\"): Promise<void> {\n        if (this.playing) return;\n        this.playing = target;\n\n        const type = this.renderTargetToCanvasType(target);\n        return this.lensCore.playCanvas({ type }).catch((error) => {\n            this.playing = false;\n            throw error;\n        });\n    }\n\n    /**\n     * Pause session playback – LensCore will stop rendering frames to the output.\n     *\n     * @param target Specify the RenderTarget to pause playback. May be either `'live'` or `'capture'`.\n     * Default is `'live'`.\n     * @returns Promise resolves when playback has stopped.\n     */\n    @validate\n    @log\n    async pause(@guard(isOptionalRenderTarget) target: RenderTarget = \"live\"): Promise<void> {\n        if (!this.playing) return;\n        const priorPlayingState = this.playing;\n        this.playing = false;\n\n        const type = this.renderTargetToCanvasType(target);\n        return this.lensCore.pauseCanvas({ type }).catch((error) => {\n            this.playing = priorPlayingState;\n            throw error;\n        });\n    }\n\n    /**\n     * Mute all sounds (default SDK state is unmuted).\n     *\n     * @param fade Do we want audio to fade out?\n     */\n    @log\n    mute(fade: boolean = false): void {\n        this.lensCore.setAllSoundsMuted({\n            muted: true,\n            fade,\n        });\n    }\n\n    /**\n     * Unmute all sounds.\n     *\n     * @param fade Do we want audio to fade in?\n     */\n    @log\n    unmute(fade: boolean = false): void {\n        this.lensCore.setAllSoundsMuted({\n            muted: false,\n            fade,\n        });\n    }\n\n    /**\n     * Set the media source for this session.\n     *\n     * Sessions may only have one source at a time - if `setSource` is called multiple times, subsequent calls replace\n     * the prior source. Setting the source does not trigger rendering (that’s done by `session.play()`). If the session\n     * is already playing, setting the source will immediately begin rendering the new source.\n     *\n     * The CameraKit SDK provides implementations for various common sources, which applications can create using the\n     * following functions:\n     * - {@link createMediaStreamSource}\n     * - {@link createVideoSource}\n     * - {@link createImageSource}\n     *\n     * @param source A CameraKitSource object representing input media (e.g. a webcam stream, video, or some other\n     * source of image data), which CameraKit will supply to Lenses in order for them to render effects on top of that\n     * source.\n     * @returns Promise is resolved when the source has successfully be set. If the session was already in the playing\n     * state, the Promise resolves when the first frame from the new source has been rendered. The resolved value is\n     * the {@link CameraKitSource} object attached to the session.\n     */\n    async setSource(source: CameraKitSource): Promise<CameraKitSource>;\n    /** Deprecated: Support for CameraKitDeviceInfo will be removed in future releases.\n     * Please use CameraKitDeviceOptions instead which accepts the \"environment\" and \"user\" cameraType\n     * @deprecated\n     */\n    async setSource(\n        source: MediaStream | HTMLVideoElement,\n        options?: Partial<CameraKitDeviceInfo>\n    ): Promise<CameraKitSource>;\n    async setSource(\n        source: MediaStream | HTMLVideoElement,\n        options?: Partial<CameraKitDeviceOptions>\n    ): Promise<CameraKitSource>;\n    @validate\n    @log\n    async setSource(\n        source: CameraKitSource | MediaStream | HTMLVideoElement,\n        options: Partial<CameraKitDeviceInfo | CameraKitDeviceOptions> = {}\n    ): Promise<CameraKitSource> {\n        await this.safelyDetachSource();\n\n        // For convenience, we allow callers to pass in native objects (e.g. MediaStream) as well as CameraKitSource.\n        // Native objects are wrapped in corresponding CameraKitSource classes with default options.\n        const cameraKitSource =\n            source instanceof MediaStream\n                ? createMediaStreamSource(source, options)\n                : source instanceof HTMLVideoElement\n                ? createVideoSource(source, options)\n                : source;\n\n        const priorPlayingState = this.playing;\n        this.playing = false;\n\n        // The source will provide its data to LensCore, and use other LensCore APIs (e.g. setRenderSize,\n        // setInputTransform) to render the source correctly.\n        await cameraKitSource.attach(this.lensCore, (error) => {\n            logger.error(cameraKitSourceError(\"Error occurred during source attachment.\", error));\n        });\n\n        // If attachment is successful, we'll update our source so that we can detach it later.\n        this.source = cameraKitSource;\n\n        // Finally we'll resume playback, if appropriate.\n        if (priorPlayingState) {\n            await this.play(priorPlayingState);\n        }\n\n        return cameraKitSource;\n    }\n\n    /**\n     * Set an FPS limit.\n     *\n     * This may be useful to reduce CPU/GPU resource usage by CameraKit if, for example, the input\n     * media source has a low FPS – CameraKit would then not try to render more frequently than the source produces\n     * new frames.\n     *\n     * This may also be useful to gracefully degrade performance in situations where lowering FPS is preferable over\n     * alternatives.\n     *\n     * @param fpsLimit A maximum FPS, rendering will not exceed this limit\n     * @returns Promise is resolved when the limit is successfully set.\n     */\n    @log\n    async setFPSLimit(fpsLimit: number): Promise<void> {\n        // LensCore uses 0 to remove the limit.\n        const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;\n        return this.lensCore.setFPSLimit({ fps });\n    }\n\n    /**\n     * Destroy the session.\n     *\n     * The session will become inoperable. Frame processing stops, and any session-scoped graphical resources are freed.\n     */\n    @log\n    async destroy(): Promise<void> {\n        try {\n            await this.lensCore.clearAllLenses();\n            await this.lensCore.teardown();\n        } catch (error) {\n            // If a LensCore is in an aborted state, the above lines may throw an error.\n            // In such cases, we should continue with the cleanup process.\n            // We are also not interested in reporting these errors to our backend.\n            logger.warn(\"An error occurred in LensCore during the session termination process.\", error);\n        }\n        this.subscriptions.forEach((sub) => sub.unsubscribe());\n        await this.safelyDetachSource();\n        this.removePageVisibilityHandlers();\n        this.sessionState.dispatch(\"destroy\", undefined);\n    }\n\n    private renderTargetToCanvasType(target: RenderTarget): CanvasType {\n        return target === \"capture\" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;\n    }\n\n    private async safelyDetachSource(): Promise<void> {\n        if (this.source) {\n            try {\n                await this.source.detach((error) => {\n                    logger.error(cameraKitSourceError(\"Error occurred during source detachment.\", error));\n                });\n                // If there's a failure to detach, we will report the error and proceed. Failure to detach may lead to a\n                // memory leak, but it shouldn't prevent us from switching to the new source.\n            } catch (error) {\n                logger.error(\n                    cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error)\n                );\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nexport const cameraKitSessionFactory = Injectable(\n    \"CameraKitSession\",\n    [\n        lensCoreFactory.token,\n        logEntriesFactory.token,\n        lensKeyboardFactory.token,\n        sessionStateFactory.token,\n        lensStateFactory.token,\n        pageVisibilityFactory.token,\n    ] as const,\n    (\n        lensCore: LensCore,\n        logEntries: Observable<LogEntry>,\n        keyboard: LensKeyboard,\n        sessionState: SessionState,\n        lensState: LensState,\n        pageVisibility: PageVisibility\n    ) => new CameraKitSession(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility)\n);\n"]}