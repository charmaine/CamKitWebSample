{"version":3,"file":"LensKeyboard.js","sourceRoot":"","sources":["../../src/session/LensKeyboard.ts"],"names":[],"mappings":"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","sourcesContent":["import { isState, forActions } from \"@snap/state-management\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { TypedCustomEvent } from \"../events/TypedCustomEvent\";\nimport { TypedEventListener, TypedEventListenerOptions, TypedEventTarget } from \"../events/TypedEventTarget\";\nimport { UriHandler } from \"../extensions/UriHandlers\";\nimport { Lens } from \"../lens/Lens\";\nimport { LensState, lensStateFactory } from \"./lensState\";\n\n/**\n * Events emitted by {@link Keyboard}.\n */\nexport type KeyboardEvents = TypedCustomEvent<\n    \"active\",\n    {\n        element: HTMLTextAreaElement;\n        active: boolean;\n        lens?: Lens;\n    }\n>;\n\n/**\n * Keyboard is an API enabling lenses to consume and render user-generated text.\n *\n * Applications that wish to use lenses that expect user-generated text will need to use this API to integrate text\n * input into their user experience.\n *\n * There are two ways to do this:\n * 1. Add the provided DOM element (an HTMLTextAreaElement) to the page. When the user updates this element with text,\n * that text will be sent to the currently active lens.\n * 2. Use the {@link sendInputToLens} method to send text strings to the currently active lens directly.\n *\n * Lenses will also signal to the application when text input is expected -- applications should add an event listener\n * and ensure the user is able to input text when the `active` event is received.\n *\n * @example\n * ```ts\n * cameraKitSession.keyboard.addEventListener('active', ({ detail }) => {\n *   const { element, active } = detail\n *   if (active) document.body.appendChild(element)\n *   else element.remove()\n * })\n * ```\n *\n * @category Lenses\n */\nexport type Keyboard = {\n    addEventListener: (\n        type: \"active\",\n        callback: TypedEventListener<KeyboardEvents>,\n        options?: TypedEventListenerOptions\n    ) => void;\n    removeEventListener: (type: \"active\", callback: TypedEventListener<KeyboardEvents>) => void;\n\n    /**\n     * Get an HTMLTextAreaElement that communicates text to the active Lens.\n     */\n    getElement: () => HTMLTextAreaElement;\n\n    /**\n     * Send text to the active Lens. Also updates the provided HTMLTextAreaElement.\n     *\n     * @param text String to render. This can include escape sequences, such as the newline character ( \\n ) for\n     * multi-line input.\n     */\n    sendInputToLens: (text: string) => void;\n\n    /**\n     * Clears the provided HTMLTextAreaElement, and emits the \"active\" event with `active == false`, allowing the\n     * application to e.g. remove relevant text input elements from the DOM.\n     */\n    dismiss: () => void;\n};\n\n/** @internal */\nexport class LensKeyboard {\n    public readonly uriHandler: UriHandler;\n    private readonly events: TypedEventTarget<KeyboardEvents>;\n    private readonly element: HTMLTextAreaElement;\n    private active: boolean;\n    private handleReply: (text: string) => void;\n\n    constructor(private readonly lensState: LensState) {\n        this.active = false;\n        this.element = document.createElement(\"textarea\");\n        this.element.addEventListener(\"keypress\", (event: KeyboardEvent) => {\n            if (event.code === \"Enter\" && !event.shiftKey) {\n                event.preventDefault();\n                this.handleReply(this.element.value);\n            }\n        });\n        this.events = new TypedEventTarget<KeyboardEvents>();\n        this.handleReply = () => {};\n        this.uriHandler = {\n            uri: \"app://textInput/requestKeyboard\",\n            handleRequest: (_request, reply) => {\n                this.element.autofocus = true;\n                this.handleReply = (text: string) => {\n                    const opt = {\n                        text: text,\n                        start: text.length,\n                        end: text.length,\n                        done: true,\n                        shouldNotify: true,\n                    };\n                    const output = new TextEncoder().encode(JSON.stringify(opt));\n                    reply({\n                        code: 200,\n                        description: \"\",\n                        contentType: \"application/json\",\n                        data: output,\n                    });\n                };\n                this.active = true;\n                this.updateStatus();\n                this.element.focus();\n            },\n        };\n        lensState.events.pipe(forActions(\"turnedOff\")).subscribe(() => {\n            this.dismiss();\n        });\n    }\n\n    dismiss(): void {\n        if (this.active) {\n            this.active = false;\n            this.element.value = \"\";\n            this.updateStatus();\n        }\n    }\n\n    getElement(): HTMLTextAreaElement {\n        return this.element;\n    }\n\n    sendInputToLens(text: string): void {\n        this.element.value = text;\n        this.handleReply(text);\n    }\n\n    addEventListener(\n        type: \"active\",\n        callback: TypedEventListener<KeyboardEvents>,\n        options?: TypedEventListenerOptions\n    ): void {\n        this.events.addEventListener(type, callback, options);\n    }\n\n    removeEventListener(type: \"active\", callback: TypedEventListener<KeyboardEvents>): void {\n        this.events.removeEventListener(type, callback);\n    }\n\n    toPublicInterface(): Keyboard {\n        return {\n            addEventListener: this.addEventListener.bind(this),\n            removeEventListener: this.removeEventListener.bind(this),\n            getElement: this.getElement.bind(this),\n            sendInputToLens: this.sendInputToLens.bind(this),\n            dismiss: this.dismiss.bind(this),\n        };\n    }\n\n    private updateStatus(): void {\n        const state = this.lensState.getState();\n        // If lens keyboard status is changing, we know a lens must be applied.\n        if (isState(state, \"noLensApplied\")) return;\n        this.events.dispatchEvent(\n            new TypedCustomEvent(\"active\", {\n                element: this.element,\n                active: this.active,\n                // If the keyboard is up, it has been triggered by an active lens.\n                lens: state.data,\n            })\n        );\n    }\n}\n\n/**\n * @internal\n */\nexport const lensKeyboardFactory = Injectable(\n    \"lensKeyboard\",\n    [lensStateFactory.token] as const,\n    (lensState: LensState) => new LensKeyboard(lensState)\n);\n"]}