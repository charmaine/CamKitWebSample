import { memoize } from "../common/memoize";
import { isRecord } from "../common/typeguards";
import environment from "../environment.json";
import lensCoreWasm from "../lensCoreWasmVersions.json";
/**
 * Some user agents may not properly implement the NavigatorUAData interface, so we have to do our own validation here
 * to make sure we're dealing with a well-formed value.
 */
function isNavigatorUAData(value) {
    return (isRecord(value) &&
        Array.isArray(value["brands"]) &&
        value["brands"].every((brand) => {
            return isRecord(brand) && typeof brand["brand"] === "string" && typeof brand["version"] === "string";
        }) &&
        typeof value["mobile"] === "boolean" &&
        typeof value["platform"] === "string");
}
/**
 * In the future, we may invest in more robust device-detection (e.g. a UA string database), but for now this will give
 * us some sense of device usage.
 */
function parseDeviceModel(userAgent) {
    // from user agent like "(Linux; Android 11; Pixel 2)" extact "Pixel 2"
    const userAgentWithModel = userAgent.match(/;[^;]+?;([^\)]+?)\)/);
    if (userAgentWithModel) {
        return userAgentWithModel[1].trim();
    }
    // from user agent like "... (iPad; CPU OS 15_1 like Mac OS X) ..." extract "IPad"
    const userAgentWithModel2 = userAgent.match(/\(([^;]+);/);
    if (userAgentWithModel2) {
        return userAgentWithModel2[1].trim();
    }
    return "unknown";
}
/**
 * The origin may be useful to identify the running application (e.g. to attribute metrics).
 *
 * We need to handle cases in which we run inside a child browsing context (e.g. an iframe), which may not have a
 * hostname – in this case we'll check each ancestor context until we find a valid hostname.
 */
function parseOrigin() {
    var _a, _b, _c;
    if (location.hostname !== "")
        return location.hostname;
    // Firefox does not implement ancestorOrigins, so we need a fallback.
    // Context here: https://github.com/whatwg/html/issues/1918
    const possibleOrigins = location.ancestorOrigins === undefined && typeof window !== "undefined"
        ? [window.parent.origin, (_b = (_a = window.top) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : ""]
        : (_c = location.ancestorOrigins) !== null && _c !== void 0 ? _c : [];
    for (let origin of possibleOrigins) {
        try {
            origin = new URL(origin).hostname;
            if (origin)
                return origin;
        }
        catch (_) { }
    }
    return "unknown";
}
function parseOSName(userAgent) {
    const knownPlatforms = new Map([
        ["android", "android"],
        ["linux", "linux"],
        ["iphone os", "ios"],
        ["ipad", "ipados"],
        ["mac os", "macos"],
        ["macos", "macos"],
        ["windows", "windows"],
    ]);
    const normalizedUserAgent = userAgent.toLowerCase();
    for (const [match, platform] of knownPlatforms.entries()) {
        if (normalizedUserAgent.includes(match))
            return platform;
    }
    return "unknown";
}
/**
 * Parse the OS (a.k.a. platform) version.
 *
 * From limited testing, this seems to often produce incorrect results – the userAgent string does not typically include
 * the actual OS version.
 *
 * Better results could be obtained from [NavigatorUAData.getHighEntropyValues]
 * (https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/getHighEntropyValues), but this presents two
 * problems: 1) it's currently only supported on Chrome and 2) browsers may prompt the user for permission to share
 * this information.
 *
 * So, at least for now, we'll be satisfied with the incorrect version number.
 */
function parseOSVersion(userAgent) {
    // possible platform version values inside of user agent string
    // " 11;"
    // " 10_15_7)"
    // " 13_5_1 "
    // " 10.0;"
    // " 15_1 "
    const versionMatch = userAgent.match(/\s([\d][\d_.]*[\d])(;|\)|\s)/);
    if (versionMatch != null) {
        return versionMatch[1].replace(/_/g, ".");
    }
    return "";
}
/**
 * Some browsers (e.g. Safari) do not support the `Navigator.userAgentData` API. We'll attempt a sort of polyfill by
 * parsing the data found in [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) from
 * the raw user agent string.
 */
function parseUserAgentData(userAgent) {
    let brand;
    // Parse UA string for Chromium-based browsers (e.g. Chrome, Edge)
    if (/Chrome/.test(userAgent)) {
        const versionMatch = userAgent.match(/Chrome\/([\d.]+)/);
        brand = {
            brand: "Chrome",
            version: versionMatch !== null ? versionMatch[1] : "unknown",
        };
    }
    // Parse UA string for Safari (very important for this to only be done if Chrome is not found – Chrome userAgent
    // strings will contain "Safari")
    else if (/Safari/.test(userAgent)) {
        let versionMatch = userAgent.match(/Version\/([\d.]+)/);
        if (versionMatch === null)
            versionMatch = userAgent.match(/Safari\/([\d.]+)/);
        brand = {
            brand: "Safari",
            version: versionMatch !== null ? versionMatch[1] : "unknown",
        };
    }
    // Parse UA for unknown browser.
    // TODO: will be changed, default value support should be added on a COF server side.
    else {
        brand = {
            brand: "Firefox",
            version: "0",
        };
    }
    // We're not using `mobile` for anything, and we have no consistent way to determine this from the UA string.
    // We'll set it to false, but this should not be used – instead, we'll need to rely on more sophisticated methods
    // (e.g. a userAgent database) to determine actual device.
    const mobile = false;
    const platform = parseOSName(userAgent);
    return {
        brands: [brand],
        mobile,
        platform,
    };
}
function normalizeBrands(brands) {
    const knownBrands = new Map([
        ["Google Chrome", "Chrome"],
        ["Chrome", "Chrome"],
        ["Chromium", "Chrome"],
        ["Firefox", "Firefox"],
        ["Microsoft Edge", "Chrome"],
        ["Safari", "Safari"],
    ]);
    const normalizedBrands = brands
        .filter(({ brand }) => knownBrands.has(brand))
        .map((brand) => {
        return {
            // Safety: we've filtered out brands which do not appear as keys in `knownBrands`, so this cannot return
            // undefined.
            brand: knownBrands.get(brand.brand),
            version: brand.version,
        };
    });
    // TODO: default "unknown" value should be added on COF server side. For now we'll use Firefox.
    if (normalizedBrands.length === 0)
        return [{ brand: "Firefox", version: "0" }];
    return normalizedBrands;
}
/* eslint-disable max-len */
/**
 * We must ensure the data we get from `navigator.userAgentData` is normalized to match what our backend expects to
 * see in our custom CameraKitWeb userAgent string.
 *
 * This string is defined here:
 * https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124
 */
/* eslint-enable */
function normalizeUserAgentData(userAgentData) {
    return {
        brands: normalizeBrands(userAgentData.brands),
        mobile: userAgentData.mobile,
        platform: parseOSName(userAgentData.platform),
    };
}
/** @internal */
export const getPlatformInfo = memoize(function getPlatformIno() {
    var _a, _b, _c;
    // [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) is currently only
    // available on Chromium-based browsers – it's nice because it gives us clear, well-documented information. But
    // we'll have to fallback to parsing the userAgent string when it's not available.
    const userAgent = navigator.userAgent;
    const userAgentData = isNavigatorUAData(navigator.userAgentData)
        ? normalizeUserAgentData(navigator.userAgentData)
        : parseUserAgentData(userAgent);
    const osVersion = parseOSVersion(userAgent);
    const deviceModel = parseDeviceModel(userAgent);
    // Remove any `-prerelease` or `+buildmetadata` portions from the semver string.
    const sdkShortVersion = environment.PACKAGE_VERSION.replace(/[-+]\S+$/, "");
    const locale = navigator.language;
    // The full locale string includes all the languages with qvalues -- this is needed for some API calls.
    // More on qvalues: https://developer.mozilla.org/en-US/docs/Glossary/Quality_values
    const fullLocale = ((_a = navigator.languages) !== null && _a !== void 0 ? _a : [])
        .map((lang, index) => {
        const qvalue = Math.max(0, (10 - index) / 10);
        return `${lang};q=${qvalue.toFixed(1)}`;
    })
        .join(", ") || locale;
    return {
        sdkShortVersion,
        sdkLongVersion: environment.PACKAGE_VERSION,
        lensCore: lensCoreWasm,
        // In cases where we've parsed the userAgent string to find the brand, there will only ever be a single brand –
        // in browsers which support NavigatorUAData there could be more than one (e.g. Chrome and Chromium), but they
        // should be equivalent for our purposes -- either way we're okay just picking the first one.
        browser: userAgentData.brands[0],
        osName: userAgentData.platform,
        osVersion,
        deviceModel,
        locale,
        fullLocale,
        origin: parseOrigin(),
        connectionType: (_c = (_b = navigator.connection) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : "unknown",
    };
});
//# sourceMappingURL=platformInfo.js.map