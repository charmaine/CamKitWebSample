{"version":3,"file":"platformInfo.js","sourceRoot":"","sources":["../../src/platform/platformInfo.ts"],"names":[],"mappings":"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","sourcesContent":["import { memoize } from \"../common/memoize\";\nimport { isRecord } from \"../common/typeguards\";\nimport environment from \"../environment.json\";\nimport lensCoreWasm from \"../lensCoreWasmVersions.json\";\n\ntype BrandArray = Array<{ brand: string; version: string }>;\n\ninterface NavigatorUAData {\n    brands: BrandArray;\n    mobile: boolean;\n    platform: string;\n}\n\nexport type ConnectionType = \"bluetooth\" | \"cellular\" | \"ethernet\" | \"none\" | \"wifi\" | \"wimax\" | \"other\" | \"unknown\";\n\ndeclare global {\n    interface Navigator {\n        userAgentData?: NavigatorUAData;\n        connection?: {\n            // This currently has extremely limited support in browsers.\n            // https://wicg.github.io/netinfo/#dom-networkinformation-type\n            type?: ConnectionType;\n        };\n    }\n}\n\n/**\n * Some user agents may not properly implement the NavigatorUAData interface, so we have to do our own validation here\n * to make sure we're dealing with a well-formed value.\n */\nfunction isNavigatorUAData(value: unknown): value is NavigatorUAData {\n    return (\n        isRecord(value) &&\n        Array.isArray(value[\"brands\"]) &&\n        value[\"brands\"].every((brand) => {\n            return isRecord(brand) && typeof brand[\"brand\"] === \"string\" && typeof brand[\"version\"] === \"string\";\n        }) &&\n        typeof value[\"mobile\"] === \"boolean\" &&\n        typeof value[\"platform\"] === \"string\"\n    );\n}\n\n/**\n * In the future, we may invest in more robust device-detection (e.g. a UA string database), but for now this will give\n * us some sense of device usage.\n */\nfunction parseDeviceModel(userAgent: string) {\n    // from user agent like \"(Linux; Android 11; Pixel 2)\" extact \"Pixel 2\"\n    const userAgentWithModel = userAgent.match(/;[^;]+?;([^\\)]+?)\\)/);\n\n    if (userAgentWithModel) {\n        return userAgentWithModel[1].trim();\n    }\n\n    // from user agent like \"... (iPad; CPU OS 15_1 like Mac OS X) ...\" extract \"IPad\"\n    const userAgentWithModel2 = userAgent.match(/\\(([^;]+);/);\n\n    if (userAgentWithModel2) {\n        return userAgentWithModel2[1].trim();\n    }\n\n    return \"unknown\";\n}\n\n/**\n * The origin may be useful to identify the running application (e.g. to attribute metrics).\n *\n * We need to handle cases in which we run inside a child browsing context (e.g. an iframe), which may not have a\n * hostname – in this case we'll check each ancestor context until we find a valid hostname.\n */\nfunction parseOrigin(): string {\n    if (location.hostname !== \"\") return location.hostname;\n\n    // Firefox does not implement ancestorOrigins, so we need a fallback.\n    // Context here: https://github.com/whatwg/html/issues/1918\n    const possibleOrigins =\n        location.ancestorOrigins === undefined && typeof window !== \"undefined\"\n            ? [window.parent.origin, window.top?.origin ?? \"\"]\n            : location.ancestorOrigins ?? [];\n\n    for (let origin of possibleOrigins) {\n        try {\n            origin = new URL(origin).hostname;\n            if (origin) return origin;\n        } catch (_) {}\n    }\n\n    return \"unknown\";\n}\n\n/* eslint-disable max-len */\n/**\n * The backend defines the allowed list of known OSes which will pass their RegEx test when found in our custom\n * CameraKitWeb userAgent string.\n *\n * See https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\ntype KnownPlatform = \"macos\" | \"windows\" | \"linux\" | \"android\" | \"ios\" | \"ipados\" | \"unknown\";\nfunction parseOSName(userAgent: string): KnownPlatform {\n    const knownPlatforms = new Map<string, KnownPlatform>([\n        [\"android\", \"android\"],\n        [\"linux\", \"linux\"],\n        [\"iphone os\", \"ios\"],\n        [\"ipad\", \"ipados\"],\n        [\"mac os\", \"macos\"],\n        [\"macos\", \"macos\"],\n        [\"windows\", \"windows\"],\n    ]);\n\n    const normalizedUserAgent = userAgent.toLowerCase();\n    for (const [match, platform] of knownPlatforms.entries()) {\n        if (normalizedUserAgent.includes(match)) return platform;\n    }\n    return \"unknown\";\n}\n\n/**\n * Parse the OS (a.k.a. platform) version.\n *\n * From limited testing, this seems to often produce incorrect results – the userAgent string does not typically include\n * the actual OS version.\n *\n * Better results could be obtained from [NavigatorUAData.getHighEntropyValues]\n * (https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/getHighEntropyValues), but this presents two\n * problems: 1) it's currently only supported on Chrome and 2) browsers may prompt the user for permission to share\n * this information.\n *\n * So, at least for now, we'll be satisfied with the incorrect version number.\n */\nfunction parseOSVersion(userAgent: string) {\n    // possible platform version values inside of user agent string\n    // \" 11;\"\n    // \" 10_15_7)\"\n    // \" 13_5_1 \"\n    // \" 10.0;\"\n    // \" 15_1 \"\n    const versionMatch = userAgent.match(/\\s([\\d][\\d_.]*[\\d])(;|\\)|\\s)/);\n\n    if (versionMatch != null) {\n        return versionMatch[1].replace(/_/g, \".\");\n    }\n\n    return \"\";\n}\n\n/**\n * Some browsers (e.g. Safari) do not support the `Navigator.userAgentData` API. We'll attempt a sort of polyfill by\n * parsing the data found in [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) from\n * the raw user agent string.\n */\nfunction parseUserAgentData(userAgent: string): NavigatorUAData {\n    let brand: BrandArray[number];\n\n    // Parse UA string for Chromium-based browsers (e.g. Chrome, Edge)\n    if (/Chrome/.test(userAgent)) {\n        const versionMatch = userAgent.match(/Chrome\\/([\\d.]+)/);\n        brand = {\n            brand: \"Chrome\",\n            version: versionMatch !== null ? versionMatch[1] : \"unknown\",\n        };\n    }\n\n    // Parse UA string for Safari (very important for this to only be done if Chrome is not found – Chrome userAgent\n    // strings will contain \"Safari\")\n    else if (/Safari/.test(userAgent)) {\n        let versionMatch = userAgent.match(/Version\\/([\\d.]+)/);\n        if (versionMatch === null) versionMatch = userAgent.match(/Safari\\/([\\d.]+)/);\n        brand = {\n            brand: \"Safari\",\n            version: versionMatch !== null ? versionMatch[1] : \"unknown\",\n        };\n    }\n\n    // Parse UA for unknown browser.\n    // TODO: will be changed, default value support should be added on a COF server side.\n    else {\n        brand = {\n            brand: \"Firefox\",\n            version: \"0\",\n        };\n    }\n\n    // We're not using `mobile` for anything, and we have no consistent way to determine this from the UA string.\n    // We'll set it to false, but this should not be used – instead, we'll need to rely on more sophisticated methods\n    // (e.g. a userAgent database) to determine actual device.\n    const mobile = false;\n    const platform = parseOSName(userAgent);\n\n    return {\n        brands: [brand],\n        mobile,\n        platform,\n    };\n}\n\n/* eslint-disable max-len */\n/**\n * The `brands` array found in [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) is\n * intentionally designed to discourage standardized processing. This method of extracting brand information will be\n * inherently brittle, and it relies on us matching some well-known brands.\n *\n * For more detail from the spec:\n * See https://wicg.github.io/ua-client-hints/#monkeypatch-html-windoworworkerglobalscope\n * And https://wicg.github.io/ua-client-hints/#grease\n *\n * We also must match the list of known brands allowed by the backend, defined here:\n * https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\ntype KnownBrand = \"Chrome\" | \"Safari\" | \"Firefox\";\nfunction normalizeBrands(brands: BrandArray): BrandArray {\n    const knownBrands = new Map<string, KnownBrand>([\n        [\"Google Chrome\", \"Chrome\"],\n        [\"Chrome\", \"Chrome\"],\n        [\"Chromium\", \"Chrome\"],\n        [\"Firefox\", \"Firefox\"],\n        [\"Microsoft Edge\", \"Chrome\"],\n        [\"Safari\", \"Safari\"],\n    ]);\n\n    const normalizedBrands = brands\n        .filter(({ brand }) => knownBrands.has(brand))\n        .map((brand) => {\n            return {\n                // Safety: we've filtered out brands which do not appear as keys in `knownBrands`, so this cannot return\n                // undefined.\n                brand: knownBrands.get(brand.brand)!,\n                version: brand.version,\n            };\n        });\n\n    // TODO: default \"unknown\" value should be added on COF server side. For now we'll use Firefox.\n    if (normalizedBrands.length === 0) return [{ brand: \"Firefox\", version: \"0\" }];\n    return normalizedBrands;\n}\n\n/* eslint-disable max-len */\n/**\n * We must ensure the data we get from `navigator.userAgentData` is normalized to match what our backend expects to\n * see in our custom CameraKitWeb userAgent string.\n *\n * This string is defined here:\n * https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\nfunction normalizeUserAgentData(userAgentData: NavigatorUAData): NavigatorUAData {\n    return {\n        brands: normalizeBrands(userAgentData.brands),\n        mobile: userAgentData.mobile,\n        platform: parseOSName(userAgentData.platform),\n    };\n}\n\n/** @internal */\nexport interface PlatformInfo {\n    sdkShortVersion: string;\n    sdkLongVersion: string;\n    lensCore: {\n        version: string;\n        buildNumber: string;\n        baseUrl: string;\n    };\n    browser: { brand: string; version: string };\n    osName: string;\n    osVersion: string;\n    deviceModel: string;\n    locale: string;\n    fullLocale: string;\n    origin: string;\n    connectionType: ConnectionType;\n}\n\n/** @internal */\nexport const getPlatformInfo = memoize(function getPlatformIno(): PlatformInfo {\n    // [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) is currently only\n    // available on Chromium-based browsers – it's nice because it gives us clear, well-documented information. But\n    // we'll have to fallback to parsing the userAgent string when it's not available.\n    const userAgent = navigator.userAgent;\n    const userAgentData = isNavigatorUAData(navigator.userAgentData)\n        ? normalizeUserAgentData(navigator.userAgentData)\n        : parseUserAgentData(userAgent);\n\n    const osVersion = parseOSVersion(userAgent);\n    const deviceModel = parseDeviceModel(userAgent);\n\n    // Remove any `-prerelease` or `+buildmetadata` portions from the semver string.\n    const sdkShortVersion = environment.PACKAGE_VERSION.replace(/[-+]\\S+$/, \"\");\n\n    const locale = navigator.language;\n    // The full locale string includes all the languages with qvalues -- this is needed for some API calls.\n    // More on qvalues: https://developer.mozilla.org/en-US/docs/Glossary/Quality_values\n    const fullLocale =\n        (navigator.languages ?? [])\n            .map((lang, index) => {\n                const qvalue = Math.max(0, (10 - index) / 10);\n                return `${lang};q=${qvalue.toFixed(1)}`;\n            })\n            .join(\", \") || locale;\n\n    return {\n        sdkShortVersion,\n        sdkLongVersion: environment.PACKAGE_VERSION,\n        lensCore: lensCoreWasm,\n        // In cases where we've parsed the userAgent string to find the brand, there will only ever be a single brand –\n        // in browsers which support NavigatorUAData there could be more than one (e.g. Chrome and Chromium), but they\n        // should be equivalent for our purposes -- either way we're okay just picking the first one.\n        browser: userAgentData.brands[0],\n        osName: userAgentData.platform,\n        osVersion,\n        deviceModel,\n        locale,\n        fullLocale,\n        origin: parseOrigin(),\n        connectionType: navigator.connection?.type ?? \"unknown\",\n    };\n});\n"]}