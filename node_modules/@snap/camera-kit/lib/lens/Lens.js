import { assert } from "../common/assertions";
import { predicateRecordValues, isRecord, isString, isUndefined, isEmptyOrSafeUrl, isArrayOfType, isTypedArray, } from "../common/typeguards";
export function isLensArray(value) {
    return isArrayOfType(isLens, value);
}
export function isLens(value) {
    return (isRecord(value) &&
        isString(value.id) &&
        isString(value.name) &&
        (isUndefined(value.iconUrl) || isString(value.iconUrl)) &&
        isRecord(value.vendorData) &&
        predicateRecordValues(isString)(value.vendorData) &&
        isString(value.cameraFacingPreference) &&
        (isUndefined(value.preview) || isPreview(value.preview)) &&
        (isUndefined(value.lensCreator) || isLensCreator(value.lensCreator)) &&
        (isUndefined(value.snapcode) || isSnapcode(value.snapcode)) &&
        isAnyArray(value.featureMetadata));
}
export function isLensProto(value) {
    return (isRecord(value) &&
        isString(value.id) &&
        isString(value.name) &&
        isRecord(value.vendorData) &&
        predicateRecordValues(isString)(value.vendorData) &&
        (typeof value.content === "undefined" || isLensContent(value.content)));
}
export function isPreview(value) {
    return isRecord(value) && isString(value.imageUrl);
}
export function isLensCreator(value) {
    return isRecord(value) && isString(value.displayName);
}
export function isSnapcode(value) {
    return isRecord(value) && isString(value.imageUrl) && isString(value.deepLink);
}
export function isLensContent(value) {
    return (isRecord(value) &&
        isString(value.iconUrlBolt) &&
        isString(value.lnsSha256) &&
        isString(value.lnsUrlBolt) &&
        isRecord(value.preview) &&
        isString(value.preview.imageUrl));
}
export function isGetGroupResponse(value) {
    return isRecord(value) && isString(value.id) && Array.isArray(value.lenses) && value.lenses.every(isLensProto);
}
export function isAny(value) {
    return isRecord(value) && isString(value.typeUrl) && isTypedArray(value.value);
}
export function isAnyArray(value) {
    return isArrayOfType(isAny, value);
}
/**
 * Converts lens proto to a public lens object.
 * @param lens Lens proto
 * @returns Public lens object.
 *
 * @internal
 */
export function toPublicLens({ id, groupId, name, content, vendorData, cameraFacingPreference, lensCreator, scannable, featureMetadata, }) {
    var _a;
    assert(isEmptyOrSafeUrl(content === null || content === void 0 ? void 0 : content.iconUrlBolt), "Unsafe icon URL");
    assert(isEmptyOrSafeUrl((_a = content === null || content === void 0 ? void 0 : content.preview) === null || _a === void 0 ? void 0 : _a.imageUrl), "Unsafe preview URL");
    return {
        id,
        groupId,
        name,
        iconUrl: content === null || content === void 0 ? void 0 : content.iconUrlBolt,
        preview: (content === null || content === void 0 ? void 0 : content.preview) ? { imageUrl: content.preview.imageUrl } : undefined,
        vendorData,
        cameraFacingPreference,
        lensCreator,
        snapcode: scannable
            ? { imageUrl: scannable.snapcodeImageUrl, deepLink: scannable.snapcodeDeeplink }
            : undefined,
        featureMetadata,
    };
}
//# sourceMappingURL=Lens.js.map