{"version":3,"file":"LensRepository.js","sourceRoot":"","sources":["../../src/lens/LensRepository.ts"],"names":[],"mappings":"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","sourcesContent":["import { guard, validate } from \"../common/validate\";\nimport { isArrayOfType, isSafeString, isSafeStringArray, isString, isUndefined } from \"../common/typeguards\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { cameraKitServiceFetchHandlerFactory } from \"../handlers/cameraKitServiceFetchHandlerFactory\";\nimport { defaultFetchHandlerFactory, FetchHandler } from \"../handlers/defaultFetchHandler\";\nimport { LensSources, lensSourcesFactory } from \"../extensions/LensSources\";\nimport {\n    RequestStateEventTarget,\n    createRequestStateEmittingHandler,\n    requestStateEventTargetFactory,\n} from \"../handlers/requestStateEmittingHandler\";\nimport { LensDownloadDimensions } from \"../metrics/reporters/reportLensAndAssetDownload\";\nimport { Handler, HandlerChainBuilder } from \"../handlers/HandlerChainBuilder\";\nimport { createArrayBufferParsingHandler } from \"../handlers/arrayBufferParsingHandler\";\nimport { LensAssetManifestItem_RequestTiming } from \"../generated-proto/pb_schema/camera_kit/v3/lens\";\nimport { getLogger } from \"../logger/logger\";\nimport { errorLoggingDecorator } from \"../logger/errorLoggingDecorator\";\nimport { CameraKitApiHostname, CameraKitConfiguration, configurationToken } from \"../configuration\";\nimport { isLensArray, Lens, LensProto, LensProtoWithGroupId, toPublicLens } from \"./Lens\";\nimport { retrieveCameraKitLens, retrieveCameraKitLensGroup } from \"./lensHttpUtil\";\nimport { decodeEnvelopes } from \"./lensEnvelopeUtil\";\nimport { LensAssetRepository, lensAssetRepositoryFactory } from \"./assets/LensAssetRepository\";\n\nconst logger = getLogger(\"LensRepository\");\nconst log = errorLoggingDecorator(logger);\n\ntype LensFetchHandler = Handler<\n    [RequestInfo, LensDownloadDimensions],\n    [ArrayBuffer, Response],\n    RequestInit | undefined\n>;\n\nconst assetTimingMap = {\n    required: LensAssetManifestItem_RequestTiming.REQUIRED,\n    onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND,\n};\n\nfunction isAssetTiming(value: unknown): value is AssetTiming {\n    return isString(value) && assetTimingMap.hasOwnProperty(value);\n}\n\nfunction isOptionalAssetTimingArray(value: unknown): value is undefined | AssetTiming[] {\n    return isUndefined(value) || isArrayOfType(isAssetTiming, value);\n}\n\n/**\n * Lens assets are included in a manifest, and each will indicate when that asset will be used by the lens.\n *\n * Assets can have the following timing values:\n * - `required`: the lens will definitely request this asset immediately when the lens is applied.\n * - `onDemand`: the lens may request this asset at some time while the lens is applied.\n *\n * Depending on the use-case, an application may want to cache both required and onDemand assets for\n * a particular lens, or may decide to only cache required assets (or cache no assets).\n *\n * @category Lenses\n */\nexport type AssetTiming = keyof typeof assetTimingMap;\n\nexport interface LensBinary {\n    lensBuffer: ArrayBuffer;\n    lensChecksum: string;\n}\n\n/**\n * The LensRepository is used to query for lenses from specific lens groups, or for a lens with a specific ID.\n *\n * Lens groups are configured in the CameraKit Portal -- that's where you'll find lens group IDs and lens IDs.\n *\n * Lenses must be loaded by the LensRepository before they can be applied to a {@link CameraKitSession}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(options)\n * const session = await cameraKit.createSession()\n * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n * session.applyLens(lens)\n * ```\n *\n * @category Lenses\n */\nexport class LensRepository {\n    private readonly metadataCache = new Map<string, LensProtoWithGroupId>();\n    private readonly binariesCache = new Map<string, ArrayBuffer>();\n\n    /** @internal */\n    constructor(\n        private readonly lensMetadataFetchHandler: FetchHandler,\n        private readonly lensFetchHandler: LensFetchHandler,\n        private readonly lensSources: LensSources,\n        private readonly lensAssetRepository: LensAssetRepository,\n        private readonly apiHostname: CameraKitApiHostname\n    ) {}\n\n    /**\n     * Retrieve a single Lens.\n     *\n     * @param lensId Desired Lens's unique ID. Can be found in the CameraKit Portal.\n     * @param groupId The ID of a group containing the desired Lens. Can be found in the CameraKit Portal.\n     * @returns Resolves with the desired Lens, or rejects if an error occurred (including a missing Lens).\n     */\n    @validate\n    @log\n    async loadLens(@guard(isSafeString) lensId: string, @guard(isSafeString) groupId: string): Promise<Lens> {\n        const envelopes = await this.lensSources.retrieveLenses({ lensId, groupId });\n        let lens: LensProto;\n        if (envelopes) {\n            lens = decodeEnvelopes(envelopes)[0];\n            if (!lens) {\n                throw new Error(\"Expected non-empty envelope.\");\n            }\n        } else {\n            lens = await retrieveCameraKitLens(this.lensMetadataFetchHandler, lensId, groupId, this.apiHostname);\n        }\n        const lensWithGroup = { ...lens, groupId };\n        this.metadataCache.set(lens.id, lensWithGroup);\n        return toPublicLens(lensWithGroup);\n    }\n\n    /**\n     * Retrieve the Lenses contained in a list of Lens Groups.\n     *\n     * This may result in multiple requests to retrieve Lens data (e.g. one per desired group). If any constituent\n     * requests fail, those errors will be reported in the response – but the returned Promise will not be rejected. Any\n     * Lenses which could be successfully retrieved will be available in the response.\n     *\n     * @param groupIds A list of Lens Group IDs. Can be found in the CameraKit Portal.\n     * @returns Resolves with a flattened list of all lenses in the desired groups. If any errors occurred during the\n     * query operation, these will be included in a separate list. If errors are present, the list of Lenses may not\n     * contain all the Lenses from the desired groups.\n     */\n    @validate\n    @log\n    async loadLensGroups(@guard(isSafeStringArray) groupIds: string[]): Promise<{\n        errors: Error[];\n        lenses: Lens[];\n    }> {\n        const responses = await Promise.all(\n            groupIds.map(async (groupId) => {\n                try {\n                    const envelopes = await this.lensSources.retrieveLenses({ groupId });\n                    const lenses = envelopes\n                        ? decodeEnvelopes(envelopes)\n                        : await retrieveCameraKitLensGroup(this.lensMetadataFetchHandler, groupId, this.apiHostname);\n                    lenses.forEach((lens) => this.metadataCache.set(lens.id, { ...lens, groupId }));\n                    return lenses.map((lens) => toPublicLens({ ...lens, groupId }));\n                } catch (error) {\n                    logger.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));\n                    return error as Error;\n                }\n            })\n        );\n\n        const errors: Error[] = [];\n        const lenses: Lens[] = [];\n        responses.forEach((response) => (Array.isArray(response) ? lenses.push(...response) : errors.push(response)));\n        return { errors, lenses };\n    }\n\n    /**\n     * Loads and caches lens content and dependencies to reduce latency when {@link CameraKitSession.applyLens} is later\n     * called to apply the lens. This is an in-memory cache, it will not be persisted across page loads.\n     *\n     * This may useful if the application A) knows which lenses will be applied and B) has some opportunity to call\n     * this method before a lens is applied. For example, if the user must perform some other actions before lenses\n     * become active, this might be a good opportunity to cache lenses to improve applyLens latency.\n     *\n     * @example\n     * ```ts\n     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n     * await cameraKit.lensRepository.cacheLensContent([lens])\n     *\n     * // sometime later -- this call will use the cached lens content, making lens application faster.\n     * await cameraKitSession.applyLens(lens)\n     * ```\n     *\n     * @param lenses Array of lenses to cache in memory.\n     * @param assetTimingsToCache Lenses specify certain required assets that are necessary for the lens to render, and\n     * other assets which may be needed by the lens. By default this method will cache all of those assets, but this\n     * behavior can be modified to only load the required assets, only the \"onDemand\" assets, or neither (by passing\n     * an empty array).\n     */\n    @validate\n    @log\n    async cacheLensContent(\n        @guard(isLensArray) lenses: Lens[],\n        @guard(isOptionalAssetTimingArray) assetTimingsToCache: AssetTiming[] = [\"required\", \"onDemand\"]\n    ) {\n        const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);\n        await Promise.all(\n            lenses.map(async (lens) => {\n                try {\n                    const { lensBuffer } = await this.getLensContent(lens);\n                    // Safety: getLensContent() call above ensures metadata to exist\n                    const { content } = this.metadataCache.get(lens.id)!;\n                    this.binariesCache.set(lens.id, lensBuffer);\n                    await this.lensAssetRepository.cacheAssets(content!.assetManifest, lens, assetTimingsToLoad);\n                } catch (e) {\n                    logger.warn(new Error(`Failed to cache lens ${lens.id}.`, { cause: e }));\n                }\n            })\n        );\n    }\n\n    /**\n     * Returns loaded Lens metadata if available.\n     */\n    getLensMetadata(lensId: string): LensProtoWithGroupId | undefined {\n        return this.metadataCache.get(lensId);\n    }\n\n    /**\n     * Removes Lens content from the in-memory cache.\n     */\n    removeCachedLenses(lenses: Lens[]) {\n        lenses.forEach((lens) => this.binariesCache.delete(lens.id));\n    }\n\n    /**\n     * Fetches lens content and assets. This may come from the cache, otherwise network requests will be made.\n     *\n     * @internal\n     */\n    async getLensContent(lens: Lens): Promise<LensBinary> {\n        const { content } = this.metadataCache.get(lens.id) ?? {};\n        if (!content) {\n            throw new Error(`Cannot find metadata for lens ${lens.id}.`);\n        }\n\n        const cachedLensBuffer = this.binariesCache.get(lens.id);\n        if (cachedLensBuffer) {\n            return {\n                lensBuffer: cachedLensBuffer,\n                lensChecksum: content.lnsSha256,\n            };\n        }\n\n        // Load required lens assets and the lens itself in parallel. We count both toward lens download time.\n        const [lensBuffer] = await this.lensFetchHandler([\n            // TODO: remove force-cache once https://jira.sc-corp.net/browse/CAMKIT-3671 is addressed\n            new Request(content.lnsUrlBolt, { cache: \"force-cache\" }),\n            {\n                requestType: \"lens_content\",\n                lensId: lens.id,\n            },\n        ]);\n        return { lensBuffer, lensChecksum: content.lnsSha256 };\n    }\n}\n\n/**\n * @internal\n */\nexport const lensRepositoryFactory = Injectable(\n    \"LensRepository\",\n    [\n        requestStateEventTargetFactory.token,\n        cameraKitServiceFetchHandlerFactory.token,\n        defaultFetchHandlerFactory.token,\n        lensSourcesFactory.token,\n        lensAssetRepositoryFactory.token,\n        configurationToken,\n    ] as const,\n    (\n        requestStateEventTarget: RequestStateEventTarget,\n        lensMetadataFetchHandler: FetchHandler,\n        defaultFetchHandler: FetchHandler,\n        lensSources: LensSources,\n        lensAssetRepository: LensAssetRepository,\n        configuration: CameraKitConfiguration\n    ) => {\n        const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler)\n            .map(createRequestStateEmittingHandler<LensDownloadDimensions>(requestStateEventTarget))\n            .map(createArrayBufferParsingHandler()).handler;\n        return new LensRepository(\n            lensMetadataFetchHandler,\n            lensFetchHandler,\n            lensSources,\n            lensAssetRepository,\n            configuration.apiHostname\n        );\n    }\n);\n"]}