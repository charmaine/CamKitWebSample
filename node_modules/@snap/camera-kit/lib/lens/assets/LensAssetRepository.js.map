{"version":3,"file":"LensAssetRepository.js","sourceRoot":"","sources":["../../../src/lens/assets/LensAssetRepository.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from \"../../dependency-injection/Injectable\";\nimport { Lens } from \"../Lens\";\nimport {\n    RequestStateEventTarget,\n    dispatchRequestCompleted,\n    dispatchRequestErrored,\n    dispatchRequestStarted,\n    requestStateEventTargetFactory,\n} from \"../../handlers/requestStateEmittingHandler\";\nimport { AssetDownloadDimensions } from \"../../metrics/reporters/reportLensAndAssetDownload\";\nimport {\n    LensAssetManifestItem,\n    LensAssetManifestItem_RequestTiming,\n    LensAssetManifestItem_Type,\n} from \"../../generated-proto/pb_schema/camera_kit/v3/lens\";\nimport { AssetDescriptor, AssetType, LensCore, lensCoreFactory } from \"../../lens-core-module\";\nimport { assertUnreachable } from \"../../common/assertions\";\nimport { getLogger } from \"../../logger/logger\";\nimport { MetricsEventTarget, metricsEventTargetFactory } from \"../../metrics/metricsEventTarget\";\nimport { TypedCustomEvent } from \"../../events/TypedCustomEvent\";\nimport { deviceDependentAssetLoaderFactory } from \"./deviceDependentAssetLoader\";\nimport { remoteMediaAssetLoaderFactory } from \"./remoteMediaAssetLoaderFactory\";\nimport { staticAssetLoaderFactory } from \"./staticAssetLoader\";\n\nconst logger = getLogger(\"LensAssetRepository\");\n\n/**\n * Computes cache key for asset ID and loader type pair.\n * @param asset Asset ID and loader type pair.\n * @returns Cache key.\n */\nfunction getCacheKey(asset: AssetDescriptor) {\n    return `${asset.assetId}_${asset.assetType.value}`;\n}\n\nexport function mapManfiestItemToAssetType(lensCore: LensCore, type: LensAssetManifestItem_Type): AssetType {\n    switch (type) {\n        case LensAssetManifestItem_Type.ASSET:\n            return lensCore.AssetType.Static;\n        case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:\n        case LensAssetManifestItem_Type.UNRECOGNIZED:\n            return lensCore.AssetType.DeviceDependent;\n        default:\n            return assertUnreachable(type);\n    }\n}\n\nexport interface Asset {\n    assetId: string;\n    assetBuffer: ArrayBuffer;\n    assetType: AssetType;\n    assetChecksum: string | undefined;\n}\n\nexport type AssetResponse =\n    | ArrayBuffer\n    | {\n          data: ArrayBuffer;\n          checksum?: string;\n      };\n\n/**\n * An AssetLoader is used to retrieve assets. A separate loader may be defined to retrieve different asset types.\n *\n * @category Lenses\n */\nexport type AssetLoader = (\n    asset: AssetDescriptor,\n    lens?: Lens,\n    assetManifest?: LensAssetManifestItem[]\n) => Promise<AssetResponse> | AssetResponse;\n\n/**\n * Registers a remote asset provider function with a given instance of LensCore, and uses a provided mapping of asset\n * types to loading functions to acquire remote asset data and pass it to LensCore.\n *\n * *Note:* LensCoreModule.initialize must be called on the desired LensCoreModule instance **prior** to passing it\n * to the LensAssetProvider constructor. If this class is instantiated with a LensCoreModule that has not been\n * initialized, the registry of the asset provider function will fail silently and no remote assets will be loaded.\n */\nexport class LensAssetRepository {\n    private readonly cachedAssetKeys = new Set<string>();\n\n    constructor(\n        private readonly lensCore: LensCore,\n        private readonly assetLoaders: Map<AssetType, [keyof LensCore[\"AssetType\"], AssetLoader]>,\n        private readonly metrics: MetricsEventTarget,\n        private readonly requestStateEventTarget: RequestStateEventTarget\n    ) {}\n\n    /**\n     * Caches lens assets defined in asset manifest.\n     *\n     * @param assetManifest Lens asset manifest.\n     * @param lens Lens to cache assets of.\n     * @param assetTimings Optionally specifies what assets to cache. By default, on-demand assets are not cached.\n     * @returns Promise rejects if any required assets could not be loaded â€“ if this occurs, it's very likely the Lens\n     * with this manifest will not function.\n     */\n    public async cacheAssets(\n        assetManifest: LensAssetManifestItem[],\n        lens: Lens,\n        assetTimings: LensAssetManifestItem_RequestTiming[] = [LensAssetManifestItem_RequestTiming.REQUIRED]\n    ): Promise<void> {\n        const assetTimingsToPreload = new Set([\n            // That is a bad naming, but PRELOAD_UNSET actually means\n            // that an asset has to be preloaded\n            LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,\n            ...assetTimings,\n        ]);\n        const assetDescriptors = assetManifest\n            .filter((asset) => {\n                return assetTimingsToPreload.has(asset.requestTiming);\n            })\n            .map(({ id, type }) => ({\n                assetId: id,\n                assetType: mapManfiestItemToAssetType(this.lensCore, type),\n            }));\n\n        if (assetDescriptors.length) {\n            // When preloading, we *do* want load failures to reject Promise.all (assets listed in the manifest\n            // are known to be hard requirements of the lens).\n            return this.cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest);\n        }\n    }\n\n    /**\n     * Calls the correct asset loader to fetch the asset's data,\n     * depending on the requested asset's type and provides that to LensCore.\n     */\n    public async loadAsset(\n        assetDescriptor: AssetDescriptor,\n        lens: Lens | undefined,\n        assetManifest: LensAssetManifestItem[] | undefined\n    ): Promise<void> {\n        const { assetId, assetType } = assetDescriptor;\n        const [assetTypeName, assetLoader] = this.assetLoaders.get(assetType) ?? [];\n        const safeAssetTypeName = assetTypeName ?? \"unknown\";\n        const dimensions: AssetDownloadDimensions = {\n            requestType: \"asset\",\n            assetId: assetId,\n            assetType: safeAssetTypeName,\n            lensId: lens?.id ?? \"unknown\",\n        };\n\n        const { requestId } = dispatchRequestStarted(this.requestStateEventTarget, { dimensions });\n\n        try {\n            if (!assetLoader) {\n                throw new Error(`Cannot get asset ${assetId}. Asset type ${safeAssetTypeName} is not supported.`);\n            }\n\n            const assetResponse = await assetLoader(assetDescriptor, lens, assetManifest);\n            const assetBuffer = \"data\" in assetResponse ? assetResponse.data : assetResponse;\n            const assetChecksum = \"checksum\" in assetResponse ? assetResponse.checksum : undefined;\n\n            if (assetBuffer.byteLength === 0) {\n                throw new Error(`Got empty response for asset ${assetId} from ${safeAssetTypeName} loader.`);\n            }\n\n            dispatchRequestCompleted(this.requestStateEventTarget, {\n                requestId,\n                dimensions,\n                status: 200,\n                sizeByte: assetBuffer.byteLength,\n            });\n\n            this.lensCore.provideRemoteAssetsResponse({\n                assetId,\n                assetBuffer,\n                assetType,\n                assetChecksum,\n                onFailure: (lensCoreError) => {\n                    if (/validation failed/.test(lensCoreError.message)) {\n                        this.metrics.dispatchEvent(\n                            new TypedCustomEvent(\"assetValidationFailed\", {\n                                name: \"assetValidationFailed\",\n                                assetId,\n                            })\n                        );\n                    }\n                    logger.warn(new Error(`Failed to provide lens asset ${assetId}.`, { cause: lensCoreError }));\n                },\n            });\n        } catch (error) {\n            const wrappedError = new Error(`Failed to load lens asset ${assetId}.`, { cause: error });\n            dispatchRequestErrored(this.requestStateEventTarget, { requestId, dimensions, error: wrappedError });\n            throw wrappedError;\n        }\n    }\n\n    /**\n     * Downloads and caches assets if applicable. Does nothing for assets that are already in cache.\n     * @param assetDescriptors Asset ID and type pairs.\n     * @param lens Lens to load assets for.\n     * @param assetManifest Lens asset manifest.\n     */\n    private async cacheAssetsByDescriptor(\n        assetDescriptors: AssetDescriptor[],\n        lens: Lens,\n        assetManifest: LensAssetManifestItem[] | undefined\n    ): Promise<void> {\n        await Promise.all(\n            assetDescriptors\n                .filter((assetDescriptors) => !this.cachedAssetKeys.has(getCacheKey(assetDescriptors)))\n                .map(async (assetDescriptor) => {\n                    try {\n                        // NOTE: we allow concurrent cache request to download the same asset more than once,\n                        // because that is better than skipping second request when the firs one fails.\n                        // In future we could improve concurretn logic with observables as part of\n                        // https://jira.sc-corp.net/browse/CAMKIT-3931\n                        await this.loadAsset(assetDescriptor, lens, assetManifest);\n                        this.cachedAssetKeys.add(getCacheKey(assetDescriptor));\n                    } catch (error) {\n                        const { assetId, assetType } = assetDescriptor;\n                        const [assetTypeName] = this.assetLoaders.get(assetType) ?? [];\n                        logger.warn(\n                            new Error(`Failed to cache asset ${assetId} of type ${assetTypeName ?? assetType.value}.`, {\n                                cause: error,\n                            })\n                        );\n                    }\n                })\n        );\n    }\n}\n\n/**\n * @internal\n */\nexport const lensAssetRepositoryFactory = Injectable(\n    \"lensAssetRepository\",\n    [\n        lensCoreFactory.token,\n        deviceDependentAssetLoaderFactory.token,\n        remoteMediaAssetLoaderFactory.token,\n        staticAssetLoaderFactory.token,\n        metricsEventTargetFactory.token,\n        requestStateEventTargetFactory.token,\n    ] as const,\n    (\n        lensCore: LensCore,\n        deviceDependentAssetLoader: AssetLoader,\n        remoteMediaAssetLoader: AssetLoader,\n        staticAssetLoader: AssetLoader,\n        metrics: MetricsEventTarget,\n        requestStateEventTarget: RequestStateEventTarget\n    ) =>\n        new LensAssetRepository(\n            lensCore,\n            new Map([\n                [lensCore.AssetType.DeviceDependent, [\"DeviceDependent\", deviceDependentAssetLoader]],\n                [lensCore.AssetType.RemoteMediaByUrl, [\"RemoteMediaByUrl\", remoteMediaAssetLoader]],\n                // URL type is deprecated and was introduced before RemoteMediaByURL\n                // however, there are some lenses still using it so we need to support it\n                [lensCore.AssetType.URL, [\"URL\", remoteMediaAssetLoader]],\n                [lensCore.AssetType.Static, [\"Static\", staticAssetLoader]],\n            ]),\n            metrics,\n            requestStateEventTarget\n        )\n);\n"]}