import { __awaiter } from "tslib";
import { Injectable } from "../../dependency-injection/Injectable";
import { lensAssetError } from "../../namedErrors";
import { lensCoreFactory } from "../../lens-core-module";
import { getLogger } from "../../logger/logger";
import { toPublicLens } from "../Lens";
import { lensRepositoryFactory } from "../LensRepository";
import { lensStateFactory } from "../../session/lensState";
import { lensAssetRepositoryFactory } from "./LensAssetRepository";
const logger = getLogger("LensAssetProvider");
const maxConsecutiveErrors = 3;
/**
 * Registers a remote asset provider function with a given instance of LensCore.
 *
 * *Note:* LensCoreModule.initialize must be called on the desired LensCoreModule instance **prior** to passing it
 * to the LensAssetsProvider constructor. If this class is instantiated with a LensCoreModule that has not been
 * initialized, the registry of the asset provider function will fail silently and no remote assets will be loaded.
 * @internal
 */
export const registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [
    lensCoreFactory.token,
    lensRepositoryFactory.token,
    lensAssetRepositoryFactory.token,
    lensStateFactory.token,
], (lensCore, lensRepository, lensAssetRepository, lensState) => {
    const consecutiveErrorsPerAsset = new Map();
    lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        // Fetch an asset and provide it to LensCore. If fetching the asset fails we give LensCore
        // an empty response (which it may handle in a variety of ways, e.g. retry, gracefully
        // degrade lens behavior, throw error) and then reject.
        const { assetId, assetType, effectId } = assetDescriptor;
        try {
            if (((_a = consecutiveErrorsPerAsset.get(assetId)) !== null && _a !== void 0 ? _a : 0) > maxConsecutiveErrors) {
                throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);
            }
            const lensId = effectId !== null && effectId !== void 0 ? effectId : (_b = lensState.getState().data) === null || _b === void 0 ? void 0 : _b.id;
            const lens = lensId ? lensRepository.getLensMetadata(lensId) : undefined;
            yield lensAssetRepository.loadAsset(assetDescriptor, lens && toPublicLens(lens), (_c = lens === null || lens === void 0 ? void 0 : lens.content) === null || _c === void 0 ? void 0 : _c.assetManifest);
            consecutiveErrorsPerAsset.set(assetId, 0);
        }
        catch (error) {
            // if an error occurs, LensCore handles things in different ways
            // depending on the active lens. It might: 1) retry, 2) gracefully degrade lens behavior,
            // 3) lens JS might throw, which will be passed to the exceptionHandler we register with LensCore.
            lensCore.provideRemoteAssetsResponse({
                assetId,
                assetType,
            });
            const consecutiveErrors = ((_d = consecutiveErrorsPerAsset.get(assetId)) !== null && _d !== void 0 ? _d : 0) + 1;
            consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);
            // We've already reported `maxConsecutiveErrors` number of errors for this asset, so we can skip
            // logging additional errors.
            if (consecutiveErrors <= maxConsecutiveErrors) {
                logger.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));
            }
            else {
                logger.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);
            }
        }
    }));
});
//# sourceMappingURL=LensAssetsProvider.js.map