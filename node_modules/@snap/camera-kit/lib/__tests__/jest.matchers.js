function areErrorsEqual(error, errorOrMessageOrName) {
    if (typeof errorOrMessageOrName === "string") {
        return error.message === errorOrMessageOrName || error.name === errorOrMessageOrName;
    }
    return error.message === errorOrMessageOrName.message && error.name === errorOrMessageOrName.name;
}
function expectErrorsToEqual(utils, error, ...errors) {
    expect(error).toBeInstanceOf(Error);
    for (const errorOrMessage of errors) {
        if (!areErrorsEqual(error, errorOrMessage)) {
            const receivedMessage = utils.printReceived(error.message);
            const receivedName = utils.printReceived(error.name);
            const expected = utils.printExpected(errorOrMessage);
            throw new Error(`Expected ${receivedMessage} error message (or ${receivedName} error name) to equal ${expected}.`);
        }
        error = error.cause;
    }
}
const smallest = (numbers) => numbers.reduce((a, b) => (a < b ? a : b));
const toBeCalledBeforeMessage = (pass, a, b) => () => `Expected first mock to${pass ? " not" : ""} have been called before second. First mock call order:\n` +
    `\t${a}\nSecond mock call order:\n\t${b}`;
expect.extend({
    /**
     * Usage: expect(mockA).toBeCalledBefore(mockB)
     */
    toBeCalledBefore(firstMock, secondMock) {
        expect(firstMock).toBeCalled();
        expect(secondMock).toBeCalled();
        const firstOrder = smallest(firstMock.mock.invocationCallOrder);
        const secondOrder = smallest(secondMock.mock.invocationCallOrder);
        const pass = firstOrder < secondOrder;
        return { pass, message: toBeCalledBeforeMessage(pass, firstOrder, secondOrder) };
    },
    /**
     * Use .toEqualError() to compare error objects.
     * This is useful for comparing nested error objects.
     * @param actualError Error object.
     * @param expectedErrors Error like objects, messages or names. Multiple values represent nested error chain.
     */
    toEqualError(actualError, ...expectedErrors) {
        try {
            expectErrorsToEqual(this.utils, actualError, ...expectedErrors);
            return {
                pass: true,
                message: () => "",
            };
        }
        catch (e) {
            return {
                pass: false,
                message: () => e.message,
            };
        }
    },
    /**
     * Allows to do expecations like expect(fn).toBeCalledWith(expect.errorContaining("BOOM!"))
     */
    errorContaining(actualError, ...expectedErrors) {
        expectErrorsToEqual(this.utils, actualError, ...expectedErrors);
        return {
            pass: true,
            message: () => "",
        };
    },
});
export {};
//# sourceMappingURL=jest.matchers.js.map