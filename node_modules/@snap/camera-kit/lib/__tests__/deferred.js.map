{"version":3,"file":"deferred.js","sourceRoot":"","sources":["../../src/__tests__/deferred.ts"],"names":[],"mappings":"AAEA;;;;;;;;;;GAUG;AACH,MAAM,UAAU,cAAc;IAC1B,IAAI,OAAuB,CAAC;IAC5B,IAAI,MAA8B,CAAC;IACnC,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QACxC,OAAO,GAAG,GAAG,CAAC;QACd,MAAM,GAAG,GAAG,CAAC;IACjB,CAAC,CAAC,CAAC;IACF,OAAe,CAAC,OAAO,GAAG,CAAC,CAAI,EAAE,EAAE;QAChC,OAAO,CAAC,CAAC,CAAC,CAAC;QACX,OAAO,OAAO,CAAC;IACnB,CAAC,CAAC;IACD,OAAe,CAAC,MAAM,GAAG,CAAC,MAAe,EAAE,EAAE;QAC1C,MAAM,CAAC,MAAM,CAAC,CAAC;QACf,OAAO,OAAO,CAAC;IACnB,CAAC,CAAC;IACF,OAAO,OAAsB,CAAC;AAClC,CAAC","sourcesContent":["export type Deferred<T> = Promise<T> & { resolve: (v: T) => Promise<void>; reject: (e: unknown) => Promise<void> };\n\n/**\n * Creates a promise that can be resolved/rejected manually later.\n *```ts\n * const promise = createDeferred();\n * // when some piece of code awaits the promise:\n * await promise\n * // we can resovle that promise when it is more suitable for us:\n * await promise.resolve();\n *```\n * @returns A promise wtih resolve() and reject() methods.\n */\nexport function createDeferred<T>(): Deferred<T> {\n    let resolve: (v: T) => void;\n    let reject: (reason?: any) => void;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    (promise as any).resolve = (v: T) => {\n        resolve(v);\n        return promise;\n    };\n    (promise as any).reject = (reason: unknown) => {\n        reject(reason);\n        return promise;\n    };\n    return promise as Deferred<T>;\n}\n"]}