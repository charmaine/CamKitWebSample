{"version":3,"file":"Timer.js","sourceRoot":"","sources":["../../../src/metrics/operational/Timer.ts"],"names":[],"mappings":"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","sourcesContent":["import { getTimeMs } from \"../../common/time\";\nimport { OperationalMetric } from \"../../generated-proto/pb_schema/camera_kit/v3/operational_metrics\";\nimport { JoinMetricNames, Metric, MetricDimensions, joinMetricNames, serializeMetricDimensions } from \"./Metric\";\nimport { OperationalMetricsReporter } from \"./operationalMetricsReporter\";\n\ninterface Measure {\n    name: string;\n    duration: number;\n    dimensions: MetricDimensions;\n}\n\n/** @internal */\nexport type LatencyMetric = OperationalMetric & {\n    metric: Extract<OperationalMetric[\"metric\"], { $case: \"latencyMillis\" }>;\n};\n\n/** @internal */\nexport class Timer<Name extends string> extends Metric {\n    private readonly marks: Set<Timer<string>>;\n    private readonly measures: Set<Measure>;\n    private readonly startTime = getTimeMs();\n    private stopped = false;\n\n    constructor(readonly name: Name, dimensions: MetricDimensions = {}) {\n        super(name, dimensions);\n\n        this.marks = new Set();\n        this.measures = new Set();\n    }\n\n    /**\n     * Return all measures created by this Timer and any child timers.\n     */\n    getMeasures(): ReadonlyArray<Measure> {\n        return Array.from(this.measures.values()).concat(\n            ...Array.from(this.marks.values()).map((mark) => mark.getMeasures())\n        );\n    }\n\n    /**\n     * Create a child Timer, using this Timer's name as a prefix when naming the new Timer. Any measures made with the\n     * child Timer will be included when calling `getMeasures()` on this Timer, or when calling `toOperationalMetric`\n     * on this Timer.\n     *\n     * @example\n     * ```ts\n     * const parent = new Timer('parent')\n     * const child = parent.mark('child') // child metric name is parent_child.\n     *\n     * child.measure()\n     * const measures = parent.getMeasures() // has one element.\n     * ```\n     *\n     * @param name\n     * @param dimensions If omitted, the child timer will NOT inherit dimensions from the parent -- if the child timer\n     * should re-use the parent's dimensions, this must be done explicitly by passing the parent's dimensions as an\n     * argument here.\n     * @returns A child Timer.\n     */\n    mark<MarkName extends string>(\n        name: MarkName,\n        dimensions: MetricDimensions = {}\n    ): Timer<JoinMetricNames<Name, MarkName>> {\n        const mark = new Timer(joinMetricNames([this.name, name]) as JoinMetricNames<Name, MarkName>, dimensions);\n        if (this.stopped) mark.stop();\n        this.marks.add(mark);\n        return mark;\n    }\n\n    /**\n     * Measure the time (in milliseconds) since this Timer was created.\n     *\n     * If a name is provided, the measure's name will be prefixed with the name of this Timer. Otherwise the name of\n     * the measure will be the name of this Timer.\n     *\n     * @example\n     * ```ts\n     * const timer = new Timer('a')\n     * timer.measure('b')\n     * const measures = timer.getMeasures()\n     * // measure[0].name === 'a_b'\n     * ```\n     *\n     * @param name\n     * @returns\n     */\n    measure(name = \"\"): void {\n        if (this.stopped) return;\n        const fullName = joinMetricNames([this.name, name]);\n        const measure: Measure = {\n            name: fullName,\n            duration: getTimeMs() - this.startTime,\n            dimensions: this.dimensions,\n        };\n        this.measures.add(measure);\n    }\n\n    /**\n     * Remove all measures from this Timer and any child timers previously created by calls to `mark()`.\n     */\n    clear(): void {\n        this.measures.clear();\n        this.marks.forEach((mark) => mark.clear());\n    }\n\n    /**\n     * Prevent any future measures from being created by this Timer or any child timers.\n     */\n    stop(): void {\n        this.stopped = true;\n        this.marks.forEach((mark) => mark.stop());\n    }\n\n    /**\n     * Report this metric using {@link OperationalMetricsReporter}.\n     *\n     * After reporting, the Timer can longer be used. Its internal state is cleared and cannot be updated. Calling this\n     * method a second time will no-op.\n     *\n     * @param reporter All measurements will be reported using the given reporter.\n     */\n    async stopAndReport(reporter: OperationalMetricsReporter): Promise<void> {\n        reporter.report(this);\n        this.stop();\n        this.clear();\n    }\n\n    /**\n     * Convert all measures from this Timer and from any child timers into an array of {@link OperationalMeric} objects,\n     * which can be sent to the backend.\n     *\n     * @returns\n     */\n    toOperationalMetric(): LatencyMetric[] {\n        const timestamp = new Date();\n        return this.getMeasures().map((measure) => ({\n            name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,\n            timestamp,\n            metric: {\n                $case: \"latencyMillis\",\n                latencyMillis: measure.duration,\n            },\n        }));\n    }\n}\n"]}