import { __awaiter } from "tslib";
import { dayFormatter, monthFormatter } from "../../common/date";
import { Injectable } from "../../dependency-injection/Injectable";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { DailySessionBucket } from "../../generated-proto/blizzard/cameraKitEvents";
import { IndexedDBPersistence } from "../../persistence/IndexedDBPersistence";
import { metricsEventTargetFactory } from "../metricsEventTarget";
/**
 * @internal
 */
export const reportUserSession = Injectable("reportUserSession", [metricsEventTargetFactory.token], (metricsEventTarget) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const userSessionKey = "userSessionInfo";
    const db = new IndexedDBPersistence({ databaseName: "SessionHistory" });
    // We standardize all user dates to PST as per our documentation:
    // https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY/
    const date = new Date();
    const formattedDate = dayFormatter.format(date);
    const formattedDateParts = dayFormatter.formatToParts(date);
    const { day, month, year } = formattedDateParts.reduce((acc, { type, value }) => (Object.assign(Object.assign({}, acc), { [type]: parseInt(value) })), {});
    const userSessionInfo = yield db.retrieve(userSessionKey);
    const mostRecentSessionStartDate = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.mostRecentSessionStartDate;
    const formattedMostRecentSessionStartDate = mostRecentSessionStartDate
        ? dayFormatter.format(mostRecentSessionStartDate)
        : null;
    const dailySessionBucketMap = new Map([
        [1, DailySessionBucket.ONE_SESSION],
        [2, DailySessionBucket.TWO_SESSION],
        [3, DailySessionBucket.THREE_SESSION],
        [4, DailySessionBucket.FOUR_SESSION],
        [5, DailySessionBucket.FIVE_SESSION],
        [6, DailySessionBucket.SIX_SESSION],
        [7, DailySessionBucket.SEVEN_SESSION],
        [8, DailySessionBucket.EIGHT_SESSION],
        [9, DailySessionBucket.NINE_SESSION],
    ]);
    let dailySessionBucket = (_a = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.dailySessionBucket) !== null && _a !== void 0 ? _a : DailySessionBucket.NO_SESSION_BUCKET;
    let isFirstWithinMonth = false;
    if (formattedMostRecentSessionStartDate === formattedDate) {
        dailySessionBucket =
            (_b = dailySessionBucketMap.get(dailySessionBucket + 1)) !== null && _b !== void 0 ? _b : DailySessionBucket.TEN_OR_MORE_SESSION;
        yield db.store(userSessionKey, {
            mostRecentSessionStartDate: date,
            dailySessionBucket,
        });
    }
    else {
        isFirstWithinMonth =
            !mostRecentSessionStartDate ||
                monthFormatter.format(mostRecentSessionStartDate) !== monthFormatter.format(date);
        yield db.store(userSessionKey, {
            mostRecentSessionStartDate: date,
            dailySessionBucket: (dailySessionBucket = DailySessionBucket.ONE_SESSION),
        });
    }
    const session = {
        name: "session",
        dailySessionBucket,
        isFirstWithinMonth,
        month,
        day,
        year,
    };
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("session", session));
}));
//# sourceMappingURL=reportUserSession.js.map