import { assertUnreachable } from "../../common/assertions";
import { stringifyError } from "../../common/errorHelpers";
import { Injectable } from "../../dependency-injection/Injectable";
import { scan } from "../../events/scan";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { requestStateEventTargetFactory, } from "../../handlers/requestStateEmittingHandler";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { operationalMetricReporterFactory, } from "../operational/operationalMetricsReporter";
const relevantRequestTypes = ["lens_content", "asset"];
export const isLensOrAssetRequest = (value) => {
    const requestType = value["requestType"];
    // Safety: the cast makes the type less specific so we can check if any string is present in the tuple.
    return typeof requestType === "string" && relevantRequestTypes.includes(requestType);
};
export const reportLensAndAssetDownload = Injectable("reportLensAndAssetDownload", [
    metricsEventTargetFactory.token,
    operationalMetricReporterFactory.token,
    requestStateEventTargetFactory.token,
], (metricsEventTarget, reporter, requestStateEventTarget) => {
    scan({ name: "inProgress", inProgress: new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
        const { inProgress } = state;
        const { dimensions, requestId, timeMs } = event.detail;
        if (!isLensOrAssetRequest(dimensions))
            return state;
        switch (event.type) {
            case "started":
                inProgress.set(requestId, { startTimeMs: timeMs });
                return { name: "inProgress", inProgress };
            case "completed":
                const completedRequest = inProgress.get(requestId);
                if (!completedRequest)
                    return state;
                inProgress.delete(requestId);
                const downloadTimeSec = (timeMs - completedRequest.startTimeMs) / 1000;
                const { sizeByte } = event.detail;
                switch (dimensions.requestType) {
                    case "lens_content":
                        return {
                            name: "completed",
                            inProgress,
                            event: new TypedCustomEvent("lensDownload", {
                                name: "lensDownload",
                                lensId: dimensions.lensId,
                                automaticDownload: false,
                                sizeByte,
                                downloadTimeSec,
                            }),
                        };
                    case "asset":
                        return {
                            name: "completed",
                            inProgress,
                            event: new TypedCustomEvent("assetDownload", {
                                name: "assetDownload",
                                assetId: dimensions.assetId,
                                automaticDownload: false,
                                sizeByte,
                                downloadTimeSec,
                            }),
                        };
                    default:
                        assertUnreachable(dimensions);
                }
            case "errored":
                const erroredRequest = inProgress.get(requestId);
                if (!erroredRequest)
                    return state;
                inProgress.delete(requestId);
                const error = event.detail.error;
                return {
                    name: "completed",
                    inProgress,
                    event: new TypedCustomEvent("exception", {
                        name: "exception",
                        lensId: dimensions.lensId,
                        type: dimensions.requestType === "lens_content" ? "lens" : "asset",
                        reason: stringifyError(error),
                    }),
                };
            default:
                assertUnreachable(event);
        }
    }).addEventListener("state", ({ detail: state }) => {
        if (state.name !== "completed")
            return;
        metricsEventTarget.dispatchEvent(state.event);
        if (state.event.detail.name === "exception") {
            reporter.count("handled_exception", 1, new Map([["type", state.event.detail.type]]));
        }
    });
});
//# sourceMappingURL=reportLensAndAssetDownload.js.map