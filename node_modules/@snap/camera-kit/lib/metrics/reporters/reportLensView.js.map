{"version":3,"file":"reportLensView.js","sourceRoot":"","sources":["../../../src/metrics/reporters/reportLensView.ts"],"names":[],"mappings":"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","sourcesContent":["import { combineLatestWith, filter, from, map, merge, mergeMap, of, raceWith, switchMap, take, takeUntil } from \"rxjs\";\nimport { forActions, inStates, isState } from \"@snap/state-management\";\nimport { Injectable } from \"../../dependency-injection/Injectable\";\nimport { TypedCustomEvent } from \"../../events/TypedCustomEvent\";\nimport { MetricsEventTarget, metricsEventTargetFactory } from \"../metricsEventTarget\";\nimport { CameraKitSession, cameraKitSessionFactory } from \"../../session/CameraKitSession\";\nimport { MakeTaggedBusinessEvent } from \"../businessEventsReporter\";\nimport { getTimeMs } from \"../../common/time\";\nimport {\n    operationalMetricReporterFactory,\n    OperationalMetricsReporter,\n} from \"../operational/operationalMetricsReporter\";\nimport { CameraKitConfiguration, configurationToken } from \"../../configuration\";\nimport { lensStateFactory, LensState } from \"../../session/lensState\";\nimport { SessionState, sessionStateFactory } from \"../../session/sessionState\";\nimport { Histogram } from \"../operational/Histogram\";\nimport { IndexedDBPersistence } from \"../../persistence/IndexedDBPersistence\";\nimport { ExpiringPersistence } from \"../../persistence/ExpiringPersistence\";\nimport { dayFormatter, monthFormatter } from \"../../common/date\";\n\n// We ignore short-duration lens views.\n//\n// The value is documented here:\n// https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY/edit#heading=h.q5liip76r9lt\nconst viewTimeThresholdSec = 0.1;\n\nasync function isFirstTimeWithinPeriods(lensId: string, persistence: ExpiringPersistence<Date>) {\n    let isLensFirstWithinDay = false;\n    let isLensFirstWithinMonth = false;\n\n    try {\n        const lensLastViewDate = await persistence.retrieve(lensId);\n        const currentDate = new Date();\n\n        if (!lensLastViewDate) {\n            isLensFirstWithinDay = true;\n            isLensFirstWithinMonth = true;\n        } else {\n            isLensFirstWithinDay = dayFormatter.format(lensLastViewDate) !== dayFormatter.format(currentDate);\n            isLensFirstWithinMonth = monthFormatter.format(lensLastViewDate) !== monthFormatter.format(currentDate);\n        }\n\n        await persistence.store(lensId, currentDate);\n    } catch (error) {\n        console.error(`Error handling persistence for lensId ${lensId}: ${error}`);\n        isLensFirstWithinDay = false;\n        isLensFirstWithinMonth = false;\n    }\n\n    return { isLensFirstWithinDay, isLensFirstWithinMonth };\n}\n\n/**\n * The LensView metric is emitted after a lens has been viewed (for longer than 100ms), when the lens is turned off.\n *\n * It contains information about rendering performance.\n *\n * Notes:\n *   - If the page is hidden (e.g. user switches to a different tab, or application, or closes the tab, or closes the\n *     browser, navigates to a new page, refreshes, etc.) this metric will be emitted at that time. This is to ensure\n *     we don't lose the metric if the page is closed.\n *   - If the page is hidden and then made visible again later (e.g. user switches to a different tab, then back), we\n *     will begin measuring a new LensView. That is, we will not capture the time when the page is hidden even if the\n *     lens is still rendering in the background.\n *\n * @category Lenses\n * @category Metrics\n */\n// This type corresponds to the internal CameraKitLensSwipe event, described here:\n// https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY#heading=h.q5liip76r9lt\nexport type LensView = MakeTaggedBusinessEvent<\"lensView\">;\n\n/**\n * @internal\n */\nexport const reportLensView = Injectable(\n    \"reportLensView\",\n    [\n        cameraKitSessionFactory.token,\n        lensStateFactory.token,\n        sessionStateFactory.token,\n        metricsEventTargetFactory.token,\n        operationalMetricReporterFactory.token,\n        configurationToken,\n    ] as const,\n    async (\n        session: CameraKitSession,\n        lensState: LensState,\n        sessionState: SessionState,\n        metricsEventTarget: MetricsEventTarget,\n        operationalMetricsReporter: OperationalMetricsReporter,\n        configuration: CameraKitConfiguration\n    ): Promise<void> => {\n        // We need to do this await up front so that it won't interrupt reporting the metric when the session is\n        // suspended -- suspension could happen because the tab is closing, in which case we cannot perform await a\n        // Promise, because in the case of a tab close the browser will not schedule any work for future turns of the\n        // event loop.\n        const { cluster: performanceCluster, webglRendererInfo } = (await configuration.lensPerformance) ?? {\n            cluster: 0,\n            webglRendererInfo: \"unknown\",\n        };\n\n        const lensViewPersistence = new ExpiringPersistence<Date>(\n            // 60 days expiration\n            () => 60 * 24 * 60 * 60,\n            new IndexedDBPersistence({ databaseName: \"recentLensViews\" })\n        );\n\n        merge(\n            // Begin measuring LensCore apply time once the lens has finished downloading and we actually add the lens\n            // to LensCore (LensWait measures the full download + LensCore apply time i.e. perceived UX latency).\n            lensState.events.pipe(\n                forActions(\"downloadComplete\"),\n                map(([a]) => a.data)\n            ),\n\n            // If the session is resumed (e.g. user returns to this tab while a lens is on), we count this as a new\n            // LensView (and applyDelaySec will be 0).\n            lensState.events.pipe(\n                inStates(\"lensApplied\"),\n                switchMap(([, s]) =>\n                    sessionState.events.pipe(\n                        forActions(\"resume\"),\n                        takeUntil(lensState.events.pipe(forActions(\"removeLens\"))),\n                        map(() => s.data)\n                    )\n                )\n            )\n        )\n            .pipe(\n                map((lens): [number, string, string] => [getTimeMs(), lens.id, lens.groupId]),\n                mergeMap(([applyLensStartTime, lensId, lensGroupId]) => {\n                    const alreadyOn = isState(lensState.getState(), \"lensApplied\");\n\n                    const applyDelay = alreadyOn\n                        ? of(0)\n                        : lensState.events.pipe(\n                              forActions(\"resourcesLoaded\"),\n                              filter(([a]) => a.data.id === lensId),\n                              // Applying a new lens may happen before removing the old one, so if we kept taking events\n                              // we would get the lensResourcesLoaded for the next lens, too.\n                              take(1),\n                              map(() => (getTimeMs() - applyLensStartTime) / 1000)\n                          );\n\n                    const viewMetrics = (\n                        alreadyOn\n                            ? of([getTimeMs(), session.metrics.beginMeasurement()] as const)\n                            : lensState.events.pipe(\n                                  forActions(\"turnedOn\"),\n                                  filter(([a]) => a.data.id === lensId),\n                                  map(() => [getTimeMs(), session.metrics.beginMeasurement()] as const)\n                              )\n                    ).pipe(\n                        take(1),\n                        mergeMap(([lensTurnedOnTime, metricsMeasurement]) =>\n                            lensState.events.pipe(\n                                forActions(\"turnedOff\"),\n                                // Applying a new lens may happen before removing the old one, so we'll get a\n                                // lensTurnedOff for the prior lens (if one was applied), which we must filter out.\n                                filter(([a]) => a.data.id === lensId),\n                                // If the session is suspended, we'll count that as the lens turning off.\n                                raceWith(sessionState.events.pipe(forActions(\"suspend\"))),\n                                map(() => {\n                                    metricsMeasurement.end();\n                                    return {\n                                        viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1000,\n                                        ...metricsMeasurement.measure(),\n                                    };\n                                })\n                            )\n                        )\n                    );\n\n                    return applyDelay.pipe(\n                        combineLatestWith(viewMetrics, from(isFirstTimeWithinPeriods(lensId, lensViewPersistence))),\n                        // This lens should always receive the lensTurnedOff action *before* the next lens is\n                        // turned on. But just in case that assumption is violated, we'll clean up\n                        // (and not report) if another lens turns on before our lens is turned off.\n                        takeUntil(\n                            lensState.events.pipe(\n                                forActions(\"turnedOn\"),\n                                filter(([a]) => a.data.id !== lensId)\n                            )\n                        ),\n                        take(1),\n                        map(([applyDelaySec, viewMetrics, isFirstTimeResults]) => ({\n                            applyDelaySec,\n                            lensId,\n                            lensGroupId,\n                            ...viewMetrics,\n                            ...isFirstTimeResults,\n                        }))\n                    );\n                })\n            )\n            .subscribe({\n                next: async ({\n                    applyDelaySec,\n                    lensId,\n                    lensGroupId,\n                    viewTimeSec,\n                    avgFps,\n                    lensFrameProcessingTimeMsAvg,\n                    lensFrameProcessingTimeMsStd,\n                    lensFrameProcessingTimeMsMedian,\n                    lensFrameProcessingN,\n                    isLensFirstWithinDay,\n                    isLensFirstWithinMonth,\n                }) => {\n                    if (viewTimeSec < viewTimeThresholdSec) return;\n\n                    const lensView: LensView = {\n                        name: \"lensView\",\n                        applyDelaySec,\n                        avgFps,\n                        lensId,\n                        lensGroupId,\n                        lensFrameProcessingTimeMsAvg,\n                        lensFrameProcessingTimeMsStd,\n                        // We don't support recording video, but applications may do this without our knowledge.\n                        recordingTimeSec: 0,\n                        viewTimeSec,\n                        isLensFirstWithinDay,\n                        isLensFirstWithinMonth,\n                        performanceCluster,\n                        webglRendererInfo,\n                    };\n\n                    metricsEventTarget.dispatchEvent(new TypedCustomEvent(\"lensView\", lensView));\n                    operationalMetricsReporter.report(Histogram.level(\"lens_view\", viewTimeSec * 1000));\n\n                    // The first few frames will typically take much longer to process (as they might involve requesting\n                    // remote assets to be downloaded, or other high-latency initialization steps) -- so we'll skip\n                    // reporting views with a very small number of frames.\n                    if (lensFrameProcessingN >= 30) {\n                        operationalMetricsReporter.report(\n                            Histogram.level(\"lens_view_frame-processing-time\", lensFrameProcessingTimeMsMedian, {\n                                performance_cluster: performanceCluster.toString(),\n                            })\n                        );\n                    }\n                },\n            });\n    }\n);\n"]}