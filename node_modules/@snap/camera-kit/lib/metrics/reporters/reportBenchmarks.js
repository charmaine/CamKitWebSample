import { __awaiter } from "tslib";
import { configurationToken } from "../../configuration";
import { Injectable } from "../../dependency-injection/Injectable";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { operationalMetricReporterFactory, } from "../operational/operationalMetricsReporter";
// Allowlist the benchmarks we wish to report.
const reportableBenchmarks = ["gflops"];
export const reportBenchmarks = Injectable("reportBenchmarks", [metricsEventTargetFactory.token, operationalMetricReporterFactory.token, configurationToken], (metricsEventTarget, reporter, config) => __awaiter(void 0, void 0, void 0, function* () {
    if (config.lensPerformance === undefined)
        return;
    // Safety: config.lensPerformance cannot reject â€“ all Promises contained in CameraKitConfiguration have
    // catch blocks which return a default value.
    const lensPerformance = yield config.lensPerformance;
    const baseBenchmark = {
        name: "benchmarkComplete",
        performanceCluster: lensPerformance.cluster,
        webglRendererInfo: lensPerformance.webglRendererInfo,
    };
    const dimensions = new Map([["performance_cluster", lensPerformance.cluster.toString()]]);
    for (const benchmark of lensPerformance.benchmarks) {
        if (!reportableBenchmarks.includes(benchmark.name))
            continue;
        const benchmarkComplete = Object.assign(Object.assign({}, baseBenchmark), { benchmarkName: benchmark.name, benchmarkValue: benchmark.value });
        metricsEventTarget.dispatchEvent(new TypedCustomEvent("benchmarkComplete", benchmarkComplete));
        reporter.histogram(`benchmark.${benchmark.name}`, benchmark.value, dimensions);
    }
}));
//# sourceMappingURL=reportBenchmarks.js.map