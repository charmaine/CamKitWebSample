import { MetricsEventTarget } from "../metricsEventTarget";
import { CameraKitSession } from "../../session/CameraKitSession";
import { MakeTaggedBusinessEvent } from "../businessEventsReporter";
import { OperationalMetricsReporter } from "../operational/operationalMetricsReporter";
import { CameraKitConfiguration } from "../../configuration";
/**
 * The LensView metric is emitted after a lens has been viewed (for longer than 100ms), when the lens is turned off.
 *
 * It contains information about rendering performance.
 *
 * Notes:
 *   - If the page is hidden (e.g. user switches to a different tab, or application, or closes the tab, or closes the
 *     browser, navigates to a new page, refreshes, etc.) this metric will be emitted at that time. This is to ensure
 *     we don't lose the metric if the page is closed.
 *   - If the page is hidden and then made visible again later (e.g. user switches to a different tab, then back), we
 *     will begin measuring a new LensView. That is, we will not capture the time when the page is hidden even if the
 *     lens is still rendering in the background.
 *
 * @category Lenses
 * @category Metrics
 */
export type LensView = MakeTaggedBusinessEvent<"lensView">;
/**
 * @internal
 */
export declare const reportLensView: {
    (args_0: CameraKitSession, args_1: import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"applyLens", {
        lens: import("../..").Lens;
        launchParams?: import("../..").LensLaunchParams | undefined;
    }> | import("@snap/state-management").Action<"downloadComplete", import("../..").Lens> | import("@snap/state-management").Action<"turnedOn", import("../..").Lens> | import("@snap/state-management").Action<"resourcesLoaded", import("../..").Lens> | import("@snap/state-management").Action<"firstFrameProcessed", import("../..").Lens> | import("@snap/state-management").Action<"applyLensComplete", import("../..").Lens> | import("@snap/state-management").Action<"applyLensFailed", {
        error: import("../../session/lensState").LensErrors;
        lens: import("../..").Lens;
    }> | import("@snap/state-management").Action<"applyLensAborted", import("../..").Lens> | import("@snap/state-management").Action<"removeLens", undefined> | import("@snap/state-management").Action<"turnedOff", import("../..").Lens> | import("@snap/state-management").Action<"removeLensComplete", undefined> | import("@snap/state-management").Action<"removeLensFailed", Error>, import("@snap/state-management").State<"noLensApplied", undefined> | import("@snap/state-management").State<"applyingLens", import("../..").Lens> | import("@snap/state-management").State<"lensApplied", import("../..").Lens>>, args_2: import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"suspend", CameraKitSession> | import("@snap/state-management").Action<"resume", CameraKitSession> | import("@snap/state-management").Action<"destroy", undefined>, import("@snap/state-management").State<"inactive", undefined> | import("@snap/state-management").State<"active", CameraKitSession> | import("@snap/state-management").State<"destroyed", undefined>>, args_3: MetricsEventTarget, args_4: OperationalMetricsReporter, args_5: CameraKitConfiguration): Promise<void>;
    token: "reportLensView";
    dependencies: readonly ["CameraKitSession", "lensState", "sessionState", "metricsEventTarget", "operationalMetricsReporter", "configuration"];
};
