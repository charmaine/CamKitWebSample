import { MakeTaggedBusinessEvent } from "../businessEventsReporter";
import { MetricsEventTarget } from "../metricsEventTarget";
import { OperationalMetricsReporter } from "../operational/operationalMetricsReporter";
/**
 * The LensWait metric measures the time spent downloading the lens content and required assets. It gives an indication
 * of the real UX impact of download latency. If lens content and assets are pre-loaded, the latency measured here
 * should decrease – we measure between the request to apply a lens and when the lens is ready to render.
 *
 * @category Lenses
 * @category Metrics
 */
export type LensWait = MakeTaggedBusinessEvent<"lensWait">;
/**
 * Each time a lens is applied, we measure the duration until the lens is fully loaded by LensCore. This
 * includes any time spent downloading the lens content and required assets from the lens manifest.
 *
 * The intention of this event is to measure the experienced UX latency between a user requesting a lens and
 * the lens rendering. Of course, the application may call `applyLens` at any time, and may hide/show the
 * rendered result at any time – but this should give us a good baseline for how much UX latency could be seen.
 *
 * @internal
 */
export declare const reportLensWait: {
    (args_0: import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"applyLens", {
        lens: import("../..").Lens;
        launchParams?: import("../..").LensLaunchParams | undefined;
    }> | import("@snap/state-management").Action<"downloadComplete", import("../..").Lens> | import("@snap/state-management").Action<"turnedOn", import("../..").Lens> | import("@snap/state-management").Action<"resourcesLoaded", import("../..").Lens> | import("@snap/state-management").Action<"firstFrameProcessed", import("../..").Lens> | import("@snap/state-management").Action<"applyLensComplete", import("../..").Lens> | import("@snap/state-management").Action<"applyLensFailed", {
        error: import("../../session/lensState").LensErrors;
        lens: import("../..").Lens;
    }> | import("@snap/state-management").Action<"applyLensAborted", import("../..").Lens> | import("@snap/state-management").Action<"removeLens", undefined> | import("@snap/state-management").Action<"turnedOff", import("../..").Lens> | import("@snap/state-management").Action<"removeLensComplete", undefined> | import("@snap/state-management").Action<"removeLensFailed", Error>, import("@snap/state-management").State<"noLensApplied", undefined> | import("@snap/state-management").State<"applyingLens", import("../..").Lens> | import("@snap/state-management").State<"lensApplied", import("../..").Lens>>, args_1: MetricsEventTarget, args_2: OperationalMetricsReporter): void;
    token: "reportLensWait";
    dependencies: readonly ["lensState", "metricsEventTarget", "operationalMetricsReporter"];
};
