{"version":3,"file":"reportLensWait.js","sourceRoot":"","sources":["../../../src/metrics/reporters/reportLensWait.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,wBAAwB,CAAC;AACpD,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAC3C,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC9C,OAAO,EAAE,UAAU,EAAE,MAAM,uCAAuC,CAAC;AACnE,OAAO,EAAE,gBAAgB,EAAE,MAAM,+BAA+B,CAAC;AACjE,OAAO,EAAE,gBAAgB,EAAa,MAAM,yBAAyB,CAAC;AAEtE,OAAO,EAAsB,yBAAyB,EAAE,MAAM,uBAAuB,CAAC;AACtF,OAAO,EACH,gCAAgC,GAEnC,MAAM,2CAA2C,CAAC;AAEnD,uCAAuC;AACvC,EAAE;AACF,gCAAgC;AAChC,8GAA8G;AAC9G,MAAM,oBAAoB,GAAG,GAAG,CAAC;AAcjC;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,UAAU,CACpC,gBAAgB,EAChB,CAAC,gBAAgB,CAAC,KAAK,EAAE,yBAAyB,CAAC,KAAK,EAAE,gCAAgC,CAAC,KAAK,CAAU,EAC1G,CAAC,SAAoB,EAAE,kBAAsC,EAAE,QAAoC,EAAE,EAAE;IACnG,SAAS,CAAC,MAAM;SACX,IAAI,CACD,UAAU,CAAC,WAAW,CAAC,EACvB,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;QACb,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;QAC9B,MAAM,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;QACxC,MAAM,kBAAkB,GAAG,SAAS,EAAE,CAAC;QACvC,OAAO,SAAS,CAAC,MAAM,CAAC,IAAI;QACxB,0FAA0F;QAC1F,sEAAsE;QACtE,EAAE;QACF,8FAA8F;QAC9F,gGAAgG;QAChG,6FAA6F;QAC7F,kDAAkD;QAClD,EAAE;QACF,8FAA8F;QAC9F,kDAAkD;QAClD,UAAU,CAAC,qBAAqB,EAAE,WAAW,CAAC,EAC9C,IAAI,CAAC,CAAC,CAAC,EACP,GAAG,CAAC,GAA6B,EAAE,CAAC;YAChC,CAAC,SAAS,EAAE,GAAG,kBAAkB,CAAC,GAAG,IAAI;YACzC,MAAM;YACN,WAAW;SACd,CAAC,CACL,CAAC;IACN,CAAC,CAAC,CACL;SACA,SAAS,CAAC;QACP,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,EAAE;YACzC,IAAI,WAAW,GAAG,oBAAoB;gBAAE,OAAO;YAE/C,MAAM,QAAQ,GAAa;gBACvB,IAAI,EAAE,UAAU;gBAChB,MAAM;gBACN,WAAW;gBACX,WAAW;aACd,CAAC;YACF,kBAAkB,CAAC,aAAa,CAAC,IAAI,gBAAgB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC;YAC7E,QAAQ,CAAC,KAAK,CAAC,yBAAyB,EAAE,WAAW,GAAG,IAAI,CAAC,CAAC;QAClE,CAAC;KACJ,CAAC,CAAC;AACX,CAAC,CACJ,CAAC","sourcesContent":["import { forActions } from \"@snap/state-management\";\nimport { map, mergeMap, take } from \"rxjs\";\nimport { getTimeMs } from \"../../common/time\";\nimport { Injectable } from \"../../dependency-injection/Injectable\";\nimport { TypedCustomEvent } from \"../../events/TypedCustomEvent\";\nimport { lensStateFactory, LensState } from \"../../session/lensState\";\nimport { MakeTaggedBusinessEvent } from \"../businessEventsReporter\";\nimport { MetricsEventTarget, metricsEventTargetFactory } from \"../metricsEventTarget\";\nimport {\n    operationalMetricReporterFactory,\n    OperationalMetricsReporter,\n} from \"../operational/operationalMetricsReporter\";\n\n// We ignore short-duration lens waits.\n//\n// The value is documented here:\n// https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY/edit#heading=h.q5liip76r9lt\nconst viewTimeThresholdSec = 0.1;\n\n/**\n * The LensWait metric measures the time spent downloading the lens content and required assets. It gives an indication\n * of the real UX impact of download latency. If lens content and assets are pre-loaded, the latency measured here\n * should decrease – we measure between the request to apply a lens and when the lens is ready to render.\n *\n * @category Lenses\n * @category Metrics\n */\n// This type corresponds to the internal CameraKitLensSpin event, described here:\n// https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY#heading=h.q5liip76r9lt\nexport type LensWait = MakeTaggedBusinessEvent<\"lensWait\">;\n\n/**\n * Each time a lens is applied, we measure the duration until the lens is fully loaded by LensCore. This\n * includes any time spent downloading the lens content and required assets from the lens manifest.\n *\n * The intention of this event is to measure the experienced UX latency between a user requesting a lens and\n * the lens rendering. Of course, the application may call `applyLens` at any time, and may hide/show the\n * rendered result at any time – but this should give us a good baseline for how much UX latency could be seen.\n *\n * @internal\n */\nexport const reportLensWait = Injectable(\n    \"reportLensWait\",\n    [lensStateFactory.token, metricsEventTargetFactory.token, operationalMetricReporterFactory.token] as const,\n    (lensState: LensState, metricsEventTarget: MetricsEventTarget, reporter: OperationalMetricsReporter) => {\n        lensState.events\n            .pipe(\n                forActions(\"applyLens\"),\n                mergeMap(([a]) => {\n                    const lensId = a.data.lens.id;\n                    const lensGroupId = a.data.lens.groupId;\n                    const applyLensStartTime = getTimeMs();\n                    return lensState.events.pipe(\n                        // We'll measure the time until either the requested lens was rendered, or a new applyLens\n                        // request was made (in both cases, we're done waiting for this lens).\n                        //\n                        // This does have the side-effect that if a user rapidly switches between lenses, we'll record\n                        // many low-duration lensWait events that are measuring user behavior instead of system latency.\n                        // But this is a good trade-off so that we can capture those long-duration lensWaits that are\n                        // terminated by the user trying a different lens.\n                        //\n                        // (This effect can be mitigated by increasing the viewtimeThresholdSec to ignore low-duration\n                        // waits that are likely caused by user behavior).\n                        forActions(\"firstFrameProcessed\", \"applyLens\"),\n                        take(1),\n                        map((): [number, string, string] => [\n                            (getTimeMs() - applyLensStartTime) / 1000,\n                            lensId,\n                            lensGroupId,\n                        ])\n                    );\n                })\n            )\n            .subscribe({\n                next: ([viewTimeSec, lensId, lensGroupId]) => {\n                    if (viewTimeSec < viewTimeThresholdSec) return;\n\n                    const lensWait: LensWait = {\n                        name: \"lensWait\",\n                        lensId,\n                        viewTimeSec,\n                        lensGroupId,\n                    };\n                    metricsEventTarget.dispatchEvent(new TypedCustomEvent(\"lensWait\", lensWait));\n                    reporter.timer(\"lens.apply_lens_latency\", viewTimeSec * 1000);\n                },\n            });\n    }\n);\n"]}