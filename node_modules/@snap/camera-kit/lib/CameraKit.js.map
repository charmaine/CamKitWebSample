{"version":3,"file":"CameraKit.js","sourceRoot":"","sources":["../src/CameraKit.ts"],"names":[],"mappings":"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","sourcesContent":["import { lensRepositoryFactory, LensRepository } from \"./lens/LensRepository\";\nimport { CONTAINER, Container } from \"./dependency-injection/Container\";\nimport { Injectable } from \"./dependency-injection/Injectable\";\nimport { LensCoreError } from \"./lens-core-module/lensCoreError\";\nimport { LensCore } from \"./lens-core-module/lensCore\";\nimport { CameraKitSession, cameraKitSessionFactory } from \"./session/CameraKitSession\";\nimport { registerLensAssetsProvider } from \"./lens/assets/LensAssetsProvider\";\nimport { lensCoreFactory } from \"./lens-core-module/loader/lensCoreFactory\";\nimport { configurationToken } from \"./configuration\";\nimport { RootServices } from \"./dependency-injection/RootServices\";\nimport { registerUriHandlers } from \"./extensions/uriHandlersRegister\";\nimport { MetricsEventTarget, metricsEventTargetFactory } from \"./metrics/metricsEventTarget\";\nimport { reportSessionScopedMetrics } from \"./metrics/reporters/reporters\";\nimport { lensStateFactory } from \"./session/lensState\";\nimport { lensKeyboardFactory } from \"./session/LensKeyboard\";\nimport { registerLensClientInterfaceHandler } from \"./lens-client-interface/lensClientInterface\";\nimport { sessionStateFactory } from \"./session/sessionState\";\nimport { lensExecutionError, lensAbortError } from \"./namedErrors\";\nimport { getLogger, resetLogger } from \"./logger/logger\";\nimport { errorLoggingDecorator } from \"./logger/errorLoggingDecorator\";\nimport { TypedEventTarget } from \"./events/TypedEventTarget\";\nimport { TypedCustomEvent } from \"./events/TypedCustomEvent\";\nimport { LensView } from \"./metrics/reporters/reportLensView\";\nimport { LensWait } from \"./metrics/reporters/reportLensWait\";\nimport { PageVisibility, pageVisibilityFactory } from \"./common/pageVisibility\";\nimport { setPreloadedConfiguration } from \"./remote-configuration/preloadConfiguration\";\n\nconst logger = getLogger(\"CameraKit\");\nconst log = errorLoggingDecorator(logger);\n\n/**\n * Metrics event names that are exposed to apps.\n */\nconst publicMetricsEventNames: Array<LensMetricsEvents[\"detail\"][\"name\"]> = [\"lensView\", \"lensWait\"];\n\n/**\n * Lens metrics events.\n *\n * These events are emitted by {@link CameraKit} to report lens usage, performance, apply latency, etc.\n *\n * @category Lenses\n * @category Metrics\n */\nexport type LensMetricsEvents =\n    | TypedCustomEvent<LensView[\"name\"], LensView>\n    | TypedCustomEvent<LensWait[\"name\"], LensWait>;\n\n/**\n * Options available when creating a {@link CameraKitSession}.\n *\n * @category Rendering\n */\nexport interface CreateSessionOptions {\n    /**\n     * Optionally provide an existing canvas element, on which the Live RenderTarget will be rendered.\n     *\n     * If this is not provided, CameraKit will create a new canvas element which can be added to the DOM.\n     */\n    liveRenderTarget?: HTMLCanvasElement;\n\n    /**\n     * Browsers optimize tabs when they are hidden - for example, by pausing the execution of requestAnimationFrame\n     * callbacks.\n     *\n     * If you need the CameraKitSession to continue rendering even when the tab is in the background, set this to true.\n     * There is a small performance penalty, and it's a good practice to only render in the background if absolutely\n     * necessary.\n     */\n    renderWhileTabHidden?: boolean;\n}\n\n/**\n * The entry point to the CameraKit SDK's API. Most of CameraKit's features are accessed via this class.\n *\n * Applications obtain an instance of CameraKit by calling {@link bootstrapCameraKit}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(config)\n * ```\n *\n * Then this class can be used to:\n * - Create a {@link CameraKitSession} instance, which provides the API for setting up media inputs, applying Lenses,\n * and obtaining rendered `<canvas>` outputs.\n * - Query for lenses using {@link LensRepository}.\n * - Listen for lens usage metrics events using {@link MetricsEventTarget}.\n *\n * @category Rendering\n * @category Lenses\n */\nexport class CameraKit {\n    /** @deprecated Use {@link lensRepository} */\n    readonly lenses: { repository: LensRepository };\n\n    /**\n     * Business metrics (e.g. each time a lens is viewed) are emitted here.\n     */\n    readonly metrics: TypedEventTarget<LensMetricsEvents> = new TypedEventTarget();\n\n    private sessions: CameraKitSession[] = [];\n\n    /** @internal */\n    constructor(\n        /**\n         * Used to query for lenses and lens groups.\n         */\n        readonly lensRepository: LensRepository,\n\n        private readonly lensCore: LensCore,\n        private readonly pageVisibility: PageVisibility,\n        private readonly container: Container<RootServices>,\n        allMetrics: MetricsEventTarget\n    ) {\n        this.lenses = { repository: this.lensRepository };\n        // Proxy only a subset of all metrics events to the public-facing emitter -- applications don't need to\n        // know about most events.\n        publicMetricsEventNames.forEach((eventName) => {\n            allMetrics.addEventListener(eventName, (e) => this.metrics.dispatchEvent(e));\n        });\n    }\n\n    /**\n     * Create a CameraKitSession.\n     *\n     * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access\n     * to Lens rendering.\n     *\n     * @example\n     * ```ts\n     * const cameraKit = await bootstrapCameraKit(config)\n     * const session = await cameraKit.createSession()\n     *\n     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n     * session.applyLens(lens)\n     * ```\n     *\n     * @param options\n     */\n    @log\n    async createSession({\n        liveRenderTarget,\n        renderWhileTabHidden,\n    }: CreateSessionOptions = {}): Promise<CameraKitSession> {\n        // Any error happened during lens rendering can be processed by subscribing to sessionErrors\n        const exceptionHandler = (error: LensCoreError) => {\n            if (error.name === \"LensCoreAbortError\") {\n                logger.error(\n                    lensAbortError(\n                        \"Unrecoverable error occurred during lens execution. \" +\n                            \"The CameraKitSession will be destroyed.\",\n                        error\n                    )\n                );\n            } else {\n                logger.error(\n                    lensExecutionError(\n                        \"Error occurred during lens execution. \" +\n                            \"The lens cannot be rendered and will be removed from the CameraKitSession.\",\n                        error\n                    )\n                );\n            }\n        };\n\n        /**\n         * If/when we add support for multiple concurrent sessions, we'll need to create a copy of the LensCore WASM\n         * module. If we move managing web workers into JS, spawing a new worker thread with its own copy of LensCore\n         * probably becomes a lot more straightforward.\n         *\n         * Currently chromium has a bug preventing rendering while tab is hidden when LensCore is in worker mode.\n         * In order to process tab while it is hidden, the current stopgap is to pass in renderWhileTabHidden as true,\n         * which will initiate session in non worker mode, and set the RenderLoopMode to `SetTimeout`.\n         */\n        await this.lensCore.initialize({\n            canvas: liveRenderTarget,\n            shouldUseWorker: !renderWhileTabHidden && this.container.get(configurationToken).shouldUseWorker,\n            exceptionHandler,\n        });\n\n        await this.lensCore.setRenderLoopMode({\n            mode: renderWhileTabHidden\n                ? this.lensCore.RenderLoopMode.SetTimeout\n                : this.lensCore.RenderLoopMode.RequestAnimationFrame,\n        });\n\n        // Each session gets its own DI Container – some Services provided by this Container may be shared with the\n        // root CameraKit Container, but others may be scoped to the session by passing their token to `copy()`.\n        const sessionContainer = this.container\n            // Right now this is a no-op. If/when we add support for multiple concurrent sessions, we may end up\n            // scoping LensCore to the session.\n            .copy()\n\n            .provides(sessionStateFactory)\n            .provides(lensStateFactory)\n            .provides(lensKeyboardFactory)\n            .provides(cameraKitSessionFactory)\n\n            .run(registerLensAssetsProvider)\n            .run(registerLensClientInterfaceHandler)\n            .run(setPreloadedConfiguration)\n\n            // We'll run a PartialContainer containing reporters for session-scoped metrics. Running this container\n            // allows each metric reporter to initialize itself (e.g. by adding event listeners to detect when certain\n            // actions occur).\n            .run(reportSessionScopedMetrics)\n\n            // UriHandlers may have dependencies on session-scoped services (e.g. LensState, LensKeyboard), so they'll\n            // be registered with LensCore here.\n            .run(registerUriHandlers);\n\n        const session = sessionContainer.get(cameraKitSessionFactory.token);\n        this.sessions.push(session);\n        return session;\n    }\n\n    /**\n     * Destroys all sessions and frees all resources.\n     */\n    @log\n    async destroy() {\n        resetLogger();\n        this.pageVisibility.destroy();\n        await Promise.all(this.sessions.map((session) => session.destroy()));\n        this.sessions = [];\n    }\n}\n\n/** @internal */\nexport const cameraKitFactory = Injectable(\n    \"CameraKit\",\n    [\n        lensRepositoryFactory.token,\n        metricsEventTargetFactory.token,\n        lensCoreFactory.token,\n        pageVisibilityFactory.token,\n        CONTAINER,\n    ] as const,\n    (\n        lensRepository: LensRepository,\n        metrics: MetricsEventTarget,\n        lensCore: LensCore,\n        pageVisibility: PageVisibility,\n        container: Container<RootServices>\n    ) => new CameraKit(lensRepository, lensCore, pageVisibility, container, metrics)\n);\n"]}