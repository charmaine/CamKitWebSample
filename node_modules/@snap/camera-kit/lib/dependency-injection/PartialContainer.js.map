{"version":3,"file":"PartialContainer.js","sourceRoot":"","sources":["../../src/dependency-injection/PartialContainer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAY,MAAM,mBAAmB,CAAC;AAwCtD;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,gBAAgB;AAChB,MAAM,OAAO,gBAAgB;IACzB,YAA6B,WAAgD;QAAhD,gBAAW,GAAX,WAAW,CAAqC;IAAG,CAAC;IAEjF;;;;;;;;;;;OAWG;IACH,QAAQ,CAMJ,EAA6E;QAc7E,OAAO,IAAI,gBAAgB,CAAC,gCAAK,IAAI,CAAC,WAAW,KAAE,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE,GAAS,CAAC,CAAC;IAChF,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IACH,YAAY,CAAC,MAA+B;QACxC,OAAO,MAAM,CAAC,WAAW,CACrB,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,EAAE;YAC1C,OAAO;gBACH,KAAK;gBACL,OAAO,CAAC,CAAC,CAAqC,EAAE,EAAE;oBAC9C,OAAO,EAAE,CACL,GAAI,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;wBAC1B,OAAO,CAAC,KAAK,KAAK;4BACd,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAuB,CAAC;4BACrC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAkC,CAAC,CAAC;oBACpD,CAAC,CAAS,CACb,CAAC;gBACN,CAAC,CAAC;aACL,CAAC;QACN,CAAC,CAAC,CACgD,CAAC;IAC3D,CAAC;IAED,SAAS;QACL,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAA0B,CAAC;IAClE,CAAC;CACJ","sourcesContent":["import { entries } from \"../common/entries\";\nimport { memoize, Memoized } from \"../common/memoize\";\nimport { Container } from \"./Container\";\nimport { AddService, InjectableFunction, ServicesFromTokenizedParams, ValidTokens } from \"./types\";\n\n// Using a conditional type forces TS language services to evaluate the type -- so when showing e.g. type hints, we\n// will see the mapped type instead of the AddDependencies type alias. This produces better hints.\ntype AddDependencies<ParentDependencies, Dependencies> = ParentDependencies extends any\n    ? // A mapped type produces better, more concise type hints than an intersection type.\n      {\n          [K in keyof ParentDependencies | keyof Dependencies]: K extends keyof ParentDependencies\n              ? ParentDependencies[K]\n              : K extends keyof Dependencies\n              ? Dependencies[K]\n              : never;\n      }\n    : never;\n\ntype ExcludeKey<T, U> = T extends any ? { [K in Exclude<keyof T, U>]: T[K] } : never;\n\ntype PartialInjectableFunction<\n    Params extends readonly any[],\n    Tokens extends readonly string[],\n    Token extends string,\n    Service\n> = {\n    (...args: Params): Service;\n    token: Token;\n    dependencies: Tokens;\n};\n\ntype Injectables<Services, Dependencies> = {\n    [K in keyof Services]: K extends string\n        ? InjectableFunction<Services & Dependencies, readonly ValidTokens<Services & Dependencies>[], K, Services[K]>\n        : never;\n};\n\ntype PartialContainerFactories<Services, Dependecies> = {\n    [K in keyof Services]: Memoized<(c: Container<Partial<Services> & Dependecies>) => Services[K]>;\n};\n\n/**\n * Similar to [Container], with the exception that Services may be provided to a PartialContainer which *does not*\n * contain all of that Services dependencies.\n *\n * For this to remain safe, Services can not be resolved by PartialContainer – it has no `get` method.\n *\n * Instead, the PartialContainer must be provided to a [Container] which *does* contain all the dependencies required\n * by all the Service in the PartialContainer. The resulting [Container] can then resolve these Services.\n *\n * PartialContainers are used to create a collection of Services which can then be provided via a simple one-line syntax\n * to an existing Container (which fulfills the collection's dependencies). It is an organizational tool, allowing\n * coherent groupings of Services to be defined in one place, then combined elsewhere to form a complete [Container].\n *\n * Here's an example of PartialContainer usage:\n * ```ts\n * // We can provide fooFactory, even though the PartialContainer doesn't fulfill the Bar dependency.\n * const fooFactory = Injectable('Foo', ['Bar'] as const, (bar: Bar) => new Foo(bar))\n * const partialContainer = new PartialContainer({}).provide(fooFactory)\n *\n * const barFactory = Injectable('Bar', () => new Bar())\n * const dependenciesContainer = Container.provides(barFactory)\n *\n * const combinedContainer = dependenciesContainer.provides(partialContainer)\n *\n * // We can resolve Foo, because the combined container includes Bar, so all of Foo's dependencies are now met.\n * const foo = combinedContainer.get('Foo')\n * ```\n */\n/** @internal */\nexport class PartialContainer<Services = {}, Dependencies = {}> {\n    constructor(private readonly injectables: Injectables<Services, Dependencies>) {}\n\n    /**\n     * Create a new PartialContainer which provides a Service created by the given InjectableFunction.\n     *\n     * The InjectableFunction contains metadata specifying the Token by which the created Service will be known, as well\n     * as an ordered list of Tokens to be resolved and provided to the InjectableFunction as arguments.\n     *\n     * This dependencies are allowed to be missing from the PartialContainer, but these dependencies are maintained as a\n     * parameter of the returned PartialContainer. This allows `[Container.provides]` to type check the dependencies and\n     * ensure they can be provided by the Container.\n     *\n     * @param fn A InjectableFunction, taking dependencies as arguments, which returns the Service.\n     */\n    provides<\n        AdditionalDependencies extends readonly any[],\n        Tokens extends readonly string[],\n        Token extends string,\n        Service\n    >(\n        fn: PartialInjectableFunction<AdditionalDependencies, Tokens, Token, Service>\n    ): PartialContainer<\n        AddService<Services, Token, Service>,\n        // The dependencies of the new PartialContainer are the combined dependencies of this container and the\n        // PartialInjectableFunction -- but we exclude any dependencies already provided by this container (i.e. this\n        // container's Services) as well as the new Service being provided.\n        ExcludeKey<\n            AddDependencies<\n                ExcludeKey<Dependencies, Token>,\n                ServicesFromTokenizedParams<Tokens, AdditionalDependencies>\n            >,\n            keyof Services\n        >\n    > {\n        return new PartialContainer({ ...this.injectables, [fn.token]: fn } as any);\n    }\n\n    /**\n     * In order to create a [Container], the InjectableFunctions maintained by the PartialContainer must be memoized\n     * into Factories that can resolve their dependencies and return the correct Service.\n     *\n     * In particular, this requires access to a \"parent\" Container to avoid infinite looping in cases where Service A\n     * depends on Service A – this is allowed (as long as the parent container provides Service A), but requires access\n     * to the parent Container to provide the parent implementation of Service A.\n     *\n     * This also means that Services provided by a PartialContainer to a Container via this function will always be\n     * scoped to the Container. In other words, if a PartialContainer containing Service A is provided to both\n     * Container X and Container Y, when Service A is resolved by Container X the InjectableFunction used to create\n     * Service A will be invoked – and when Service A is resolved by Container Y, the InjectableFunction will be invoked\n     * again.\n     *\n     * @param parent A [Container] which provides all the required Dependencies of this PartialContainer.\n     */\n    getFactories(parent: Container<Dependencies>): PartialContainerFactories<Services, Dependencies> {\n        return Object.fromEntries(\n            entries(this.injectables).map(([token, fn]) => {\n                return [\n                    token,\n                    memoize((c: Container<Services & Dependencies>) => {\n                        return fn(\n                            ...(fn.dependencies.map((t) => {\n                                return t === token\n                                    ? parent.get(t as keyof Dependencies)\n                                    : c.get(t as keyof Services & Dependencies);\n                            }) as any)\n                        );\n                    }),\n                ];\n            })\n        ) as PartialContainerFactories<Services, Dependencies>;\n    }\n\n    getTokens(): Array<keyof Services> {\n        return Object.keys(this.injectables) as Array<keyof Services>;\n    }\n}\n"]}