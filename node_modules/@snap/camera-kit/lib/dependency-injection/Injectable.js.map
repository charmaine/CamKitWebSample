{"version":3,"file":"Injectable.js","sourceRoot":"","sources":["../../src/dependency-injection/Injectable.ts"],"names":[],"mappings":"AA2DA,MAAM,UAAU,UAAU,CACtB,KAAa,EACb,gBAAkD,EAClD,OAAiC;IAEjC,MAAM,YAAY,GAAa,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;IACvF,MAAM,EAAE,GAAG,OAAO,gBAAgB,KAAK,UAAU,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC;IAE/E,IAAI,CAAC,EAAE,EAAE;QACL,MAAM,IAAI,SAAS,CACf,uFAAuF;YACnF,oBAAoB,CAC3B,CAAC;KACL;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE;QACnC,MAAM,IAAI,SAAS,CACf,yFAAyF;YACrF,GAAG,EAAE,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,+BAA+B;YACvE,mBAAmB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CACxD,CAAC;KACL;IAED,MAAM,OAAO,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;IACpC,OAAO,OAAO,CAAC;AACnB,CAAC","sourcesContent":["import { InjectableFunction, ServicesFromTokenizedParams } from \"./types\";\n\n/**\n * Create an Injectable function with no dependencies (i.e. arguments).\n *\n * Ex:\n * ```ts\n * const createMyService = Factory(\n *   'MyService',\n *   () => { ... },\n * )\n * ```\n *\n * @param token A unique string Token which will correspond to the created Service.\n * @param fn A function with no arguments which returns the Service.\n */\nexport function Injectable<Token extends string, Service>(\n    token: Token,\n    fn: () => Service\n): InjectableFunction<any, [], Token, Service>;\n\n/**\n * Create an Injectable function with dependencies (i.e. arguments).\n *\n * **Note:** the list of dependencies must be readonly – that is, a literal tuple marked `as const`. This tuple must\n * contain only string literals or string consts.\n *\n * Ex:\n * ```ts\n * const DependencyB = 'DependencyB'\n * const createMyService = Factory(\n *   'MyService',\n *   ['DependencyA', DependencyB] as const,\n *   (a: A, b: B) => { ... },\n * )\n * ```\n *\n * @param token A unique string Token which will correspond to the created Service.\n * @param dependencies A *readonly* list of Tokens corresponding to dependencies (i.e. arguments to the Factory), which\n * will be resolved by the Container to which this Factory is provided.\n * @param fn A function with arguments matching in type and length to the given list of dependencies. When called, it\n * must return the Service.\n */\nexport function Injectable<\n    Token extends string,\n    Tokens extends readonly string[],\n    Params extends readonly any[],\n    Service\n>(\n    token: Token,\n    dependencies: Tokens,\n    // The function arity (number of arguments) must match the number of dependencies specified – if they don't, we'll\n    // force a compiler error by saying the arguments should be `void[]`. We'll also throw at runtime, so the return\n    // type will be `never`.\n    fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): Tokens[\"length\"] extends Params[\"length\"]\n    ? InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service>\n    : never;\n\nexport function Injectable(\n    token: string,\n    dependenciesOrFn?: readonly string[] | (() => any),\n    maybeFn?: (...args: any[]) => any\n): InjectableFunction<any, readonly string[], string, any> {\n    const dependencies: string[] = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];\n    const fn = typeof dependenciesOrFn === \"function\" ? dependenciesOrFn : maybeFn;\n\n    if (!fn) {\n        throw new TypeError(\n            \"[Factory] Received invalid arguments. The factory function must be either the second \" +\n                \"or third argument.\"\n        );\n    }\n\n    if (fn.length !== dependencies.length) {\n        throw new TypeError(\n            \"[Factory] Function arity does not match the number of dependencies. Function has arity \" +\n                `${fn.length}, but ${dependencies.length} dependencies were specified.` +\n                `\\nDependencies: ${JSON.stringify(dependencies)}`\n        );\n    }\n\n    const factory = (...args: any[]) => fn(...args);\n    factory.token = token;\n    factory.dependencies = dependencies;\n    return factory;\n}\n"]}