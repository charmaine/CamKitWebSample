import { InjectableFunction, ServicesFromTokenizedParams } from "./types";
/**
 * Create an Injectable function with no dependencies (i.e. arguments).
 *
 * Ex:
 * ```ts
 * const createMyService = Factory(
 *   'MyService',
 *   () => { ... },
 * )
 * ```
 *
 * @param token A unique string Token which will correspond to the created Service.
 * @param fn A function with no arguments which returns the Service.
 */
export declare function Injectable<Token extends string, Service>(token: Token, fn: () => Service): InjectableFunction<any, [], Token, Service>;
/**
 * Create an Injectable function with dependencies (i.e. arguments).
 *
 * **Note:** the list of dependencies must be readonly â€“ that is, a literal tuple marked `as const`. This tuple must
 * contain only string literals or string consts.
 *
 * Ex:
 * ```ts
 * const DependencyB = 'DependencyB'
 * const createMyService = Factory(
 *   'MyService',
 *   ['DependencyA', DependencyB] as const,
 *   (a: A, b: B) => { ... },
 * )
 * ```
 *
 * @param token A unique string Token which will correspond to the created Service.
 * @param dependencies A *readonly* list of Tokens corresponding to dependencies (i.e. arguments to the Factory), which
 * will be resolved by the Container to which this Factory is provided.
 * @param fn A function with arguments matching in type and length to the given list of dependencies. When called, it
 * must return the Service.
 */
export declare function Injectable<Token extends string, Tokens extends readonly string[], Params extends readonly any[], Service>(token: Token, dependencies: Tokens, fn: (...args: Tokens["length"] extends Params["length"] ? Params : void[]) => Service): Tokens["length"] extends Params["length"] ? InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service> : never;
