{"version":3,"file":"Container.js","sourceRoot":"","sources":["../../src/dependency-injection/Container.ts"],"names":[],"mappings":"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","sourcesContent":["import { isMemoized, memoize, Memoized } from \"../common/memoize\";\nimport { PartialContainer } from \"./PartialContainer\";\nimport { AddService, InjectableFunction, ValidTokens } from \"./types\";\n\ntype MaybeMemoizedFactories<Services> = {\n    [K in keyof Services]:\n        | ((c: Container<Services>) => Services[K])\n        | Memoized<(c: Container<Services>) => Services[K]>;\n};\n\nexport type Factories<Services> = {\n    [K in keyof Services]: Memoized<(c: Container<Services>) => Services[K]>;\n};\n\nexport const CONTAINER = \"$container\";\nexport type ContainerToken = typeof CONTAINER;\n\n/**\n * A Container of values, indexed each by a unique token, which can be used throughout CameraKit. This is how CameraKit\n * implements simple dependency injection.\n *\n * Dependency injection is a way to decouple the *use* of a dependency from the *creation* of that dependency. This\n * improves modularity and re-usability, since components only care about the *interfaces* of dependencies (since that\n * determines their use) and not about their concrete creation. New implementations of a particular dependency may be\n * provided without the need to change any of the consumers of that dependency.\n *\n * There are a few commonly-used terms used when talking about dependency injection:\n *\n *   - Container (or Injector): Maintains a registry of all available Services and understands how to create them.\n *   - Service: Anything that can be provided by the Container is called a Service – this can be a value of any type.\n *   - Token: Each Service is associated with a unique name, or Token. In order to obtain a Service from the Container,\n *     the consumer must provide the Token corresponding to that Service.\n *   - InjectableFunction: Services are created by InjectableFunctions. When adding a Service to a Container, the\n *     Service provider gives the Container a InjectableFunction which, when called will return the Service. These\n *     InjectableFunctions may themselves use other Services, which will be passed to them as arguments.\n *\n * Services are, by default, singletons – that is, each call to `get()` a particular Service will return a reference\n * to the same value. In other words, InjectableFunctions are only invoked once. If multiple instances of a Service are\n * desired, a new Container can be created using the `copy([Token])` method – passing a Token to this method forces the\n * new Container to recreate the corresponding Service (the InjectableFunction will be invoked again). We say that the\n * Service is then \"scoped\" to the new Container.\n *\n *\n * One common downside of many dependency injection implementations is that the dependency graph formed by the various\n * Services can only be validated at runtime. That is, if a dependency is missing or a circular dependency is found, the\n * developer must wait until runtime to discover the error. These errors can often be confusing and hard to debug.\n *\n * This implementation eliminates this issue by moving these sorts of errors to compile time. If an unknown dependency\n * is used in a InjectableFunction, for example, the code simply won't compile.\n *\n * To achieve this, we do lose the ability to implicitly define the dependency graph, as is common with many dependency\n * injection frameworks that employ decorators to define Services and their dependencies. Instead, the dependency graph\n * must be constructed explicitly, step-by-step, via successive calls to the `provide()` method. This is a suitable\n * trade-off for CameraKit, as there are a relatively small number of Services.\n *\n * Here's a simple example of Container usage:\n * ```ts\n * const fooFactory = Injectable('Foo', () => new Foo())\n * const barFactory = Injectable('Bar', ['Foo'] as const, (foo: Foo) => new Bar(foo))\n * const container = Container.empy()\n *   .provide(fooFactory)\n *   .provide(barFactory)\n *\n * const bar: Bar = container.get('Bar')\n * ```\n */\n/** @internal */\nexport class Container<Services = {}> {\n    /**\n     * Create a new [Container] by providing a [PartialContainer] that has no dependencies.\n     */\n    static provides<Services>(container: PartialContainer<Services, {}> | Container<Services>): Container<Services>;\n\n    /**\n     * Create a new [Container] by providing a Service that has no dependencies.\n     */\n    static provides<Token extends string, Service>(\n        fn: InjectableFunction<{}, [], Token, Service>\n    ): Container<AddService<{}, Token, Service>>;\n\n    static provides(\n        fnOrContainer: InjectableFunction<{}, [], string, any> | PartialContainer<any, {}> | Container<any>\n    ): Container<any> {\n        // Although the `provides` method has overloads that match both members of the union type separately, it does\n        // not match the union type itself, so the compiler forces us to branch and handle each type within the union\n        // separately. (Maybe in the future the compiler will decide to infer this, but for now this is necessary.)\n        if (fnOrContainer instanceof PartialContainer) return new Container({}).provides(fnOrContainer);\n        if (fnOrContainer instanceof Container) return new Container({}).provides(fnOrContainer);\n        return new Container({}).provides(fnOrContainer);\n    }\n\n    private readonly factories: Factories<Services>;\n\n    constructor(factories: MaybeMemoizedFactories<Services>) {\n        this.factories = {} as Factories<Services>;\n        for (const k in factories) {\n            const fn = factories[k];\n            if (isMemoized(fn)) this.factories[k] = fn;\n            else this.factories[k] = memoize(fn);\n        }\n    }\n\n    /**\n     * Create a copy of this Container, optionally providing a list of Services which will be scoped to the copy.\n     *\n     * This can be useful, for example, if different parts of an application wish to use the same Service interface, but\n     * do not want to share a reference to same Service instance.\n     *\n     * Say we have a Service which manages a list of Users. Our application wishes to display two lists of Users, which\n     * may be edited independently. In this case it may be desirable to create a Container for each list component, with\n     * the UserList Service scoped to those Containers – that way, each list component gets a unique copy of the\n     * UserList Service that can be edited independently of the other.\n     *\n     * @param scopedServices A list of Tokens identifying Services which will be scoped to the new Container – that is,\n     * if those Services had already been created by the source Container, they will be re-created by their Factory\n     * functions when provided by the new Container.\n     * @returns A new copy of this Container, sharing all of this Container's Services. Services corresponding to any\n     * Tokens passed to this method will be re-created by the new Container (i.e. they become \"scoped\" to the new\n     * Container).\n     */\n    copy<Tokens extends readonly (keyof Services)[]>(scopedServices?: Tokens): Container<Services> {\n        const factories: MaybeMemoizedFactories<Services> = { ...this.factories };\n\n        // We \"un-memoize\" scoped Service InjectableFunctions so they will create a new copy of their Service when\n        // provided by the new Container – we re-memoize them so the new Container will itself only create one Service\n        // instance.\n        (scopedServices || []).forEach((token: keyof Services) => {\n            factories[token] = this.factories[token].delegate;\n        });\n        return new Container(factories);\n    }\n\n    /**\n     * Gets a reference to this Container.\n     *\n     * @param token The CONTAINER token.\n     * @returns This Container.\n     */\n    get(token: ContainerToken): this;\n\n    /**\n     * Get a specific Service provided by this Container.\n     *\n     * @param token A unique string corresponding to a Service\n     * @returns A Service corresponding to the given Token.\n     */\n    get<Token extends keyof Services>(token: Token): Services[Token];\n\n    get(token: ContainerToken | keyof Services): this | Services[keyof Services] {\n        if (token === CONTAINER) return this;\n        const factory = this.factories[token];\n        if (!factory) {\n            throw new Error(\n                `[Container::get] Could not find Service for Token \"${String(token)}\". This should've caused a ` +\n                    \"compile-time error. If the Token is 'undefined', check all your calls to the Injectable \" +\n                    \"function. Make sure you define dependencies using string literals or string constants that are \" +\n                    \"definitely initialized before the call to Injectable.\"\n            );\n        }\n        return factory(this);\n    }\n\n    /**\n     * Run the services in this [PartialContainer]. \"Run\" simply means that [Container::get] will be called for each\n     * Service, which invokes that Service's factory function, creating the Service.\n     *\n     * This may be useful e.g. if services need to initialize themselves, since generally a Service factory is only\n     * invoked when the Service is needed.\n     *\n     * Note this method cannot be used to add services to a Container. – that is, calling this method does not provide\n     * the services in a new Container.\n     *\n     * @param container Optionally provide a [PartialContainer], which will be used as a filter – the only services\n     * from *this* container that will run are those with a token that is also present in this PartialContainer.\n     * @returns No mutation is done to the Container, it is returned as-is (convenient for chaining).\n     */\n    run<AdditionalServices, Dependencies, FulfilledDependencies extends Dependencies>(\n        // FullfilledDependencies is assignable to Dependencies -- by specifying Container<FulfilledDependencies> as the\n        // `this` type, we ensure this Container can provide all the Dependencies required by the PartialContainer.\n        this: Container<FulfilledDependencies>,\n        container: PartialContainer<AdditionalServices, Dependencies>\n    ): this;\n\n    /**\n     * Run the given Service. \"Run\" simply means that [Container::get] will be called for this Service, which invokes\n     * the Service's factory function, creating the Service.\n     *\n     * This may be useful e.g. if services need to initialize themselves, since generally a Service factory is only\n     * invoked when the Service is needed.\n     *\n     * Note this method cannot be used to add services to a Container. – that is, calling this method does not provide\n     * the services in a new Container.\n     *\n     * @param fn Optionally provide an [InjectableFunction], which will be used as a filter – the only services\n     * from *this* container that will run are those with a token that is also present in this PartialContainer.\n     * @returns No mutation is done to the Container, it is returned as-is (convenient for chaining).\n     */\n    run<Token extends string, Tokens extends readonly ValidTokens<Services>[], Service>(\n        fn: InjectableFunction<Services, Tokens, Token, Service>\n    ): this;\n\n    run<Token extends string, Tokens extends readonly ValidTokens<Services>[], Service, AdditionalServices>(\n        fnOrContainer:\n            | InjectableFunction<Services, Tokens, Token, Service>\n            | PartialContainer<AdditionalServices, Services>\n    ): this {\n        if (fnOrContainer instanceof PartialContainer) {\n            const runnableContainer = this.provides(fnOrContainer);\n            for (const token of fnOrContainer.getTokens()) {\n                runnableContainer.get(token);\n            }\n        } else {\n            this.provides(fnOrContainer).get(fnOrContainer.token);\n        }\n        return this;\n    }\n\n    /**\n     * Create a new Container from this Container with additional services from a given [PartialContainer].\n     *\n     * Services in the provided PartialContainer take precedence if there are service token conflicts.\n     *\n     * Services from the provided PartialContainer become scoped to the new Container – that is, if PartialContainer A\n     * is provided to Container X and Container Y, each resultant Container will contain its own copy of the services\n     * from PartialContainer A.\n     *\n     * @param container A [PartialContainer] providing additional services.\n     */\n    provides<AdditionalServices, Dependencies, FulfilledDependencies extends Dependencies>(\n        // FullfilledDependencies is assignable to Dependencies -- by specifying Container<FulfilledDependencies> as the\n        // `this` type, we ensure this Container can provide all the Dependencies required by the PartialContainer.\n        this: Container<FulfilledDependencies>,\n        container: PartialContainer<AdditionalServices, Dependencies>\n    ): Container<Services & AdditionalServices>;\n\n    /**\n     * Creates a new Container from this Container with additional services from another Container.\n     *\n     * Services in the provided PartialContainer take precedence if there are service token conflicts.\n     *\n     * Services from the provided Container become scoped to both Containers (the one from which they were provided\n     * and the new Container returned by this method) - that is, if Container A is provided to Container B,\n     * they will share the same instances of any Services provided by Container A.\n     * If Container B should re-create new instances of the Services from Container A,\n     * Container A must first be copied before providing it here.\n     *\n     * @param container A [Container] providing additional services.\n     */\n    provides<AdditionalServices>(container: Container<AdditionalServices>): Container<Services & AdditionalServices>;\n\n    /**\n     * Create a new Container which provides a Service created by the given [InjectableFunction].\n     *\n     * The InjectableFunction contains metadata specifying the Token by which the created Service will be known, as well\n     * as an ordered list of Tokens to be resolved and provided to the InjectableFunction as arguments.\n     *\n     * If any of these required dependencies are missing from the Container (or if there is a mismatch between the types\n     * of those dependencies and the arguments of the InjectableFunction), a compiler error will be raised.\n     *\n     * @param fn A factory function, taking dependencies as arguments, which returns the Service.\n     */\n    provides<Token extends string, Tokens extends readonly ValidTokens<Services>[], Service>(\n        fn: InjectableFunction<Services, Tokens, Token, Service>\n    ): Container<AddService<Services, Token, Service>>;\n\n    provides<Token extends string, Tokens extends readonly ValidTokens<Services>[], Service, AdditionalServices>(\n        fnOrContainer:\n            | InjectableFunction<Services, Tokens, Token, Service>\n            | PartialContainer<AdditionalServices, Services>\n            | Container<AdditionalServices>\n    ): Container<any> {\n        if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof Container) {\n            const factories =\n                fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;\n            // Safety: `this.factories` and `factories` are both properly type checked, so merging them produces\n            // a Factories object with keys from both Services and AdditionalServices. The compiler is unable to\n            // infer that Factories<A> & Factories<B> == Factories<A & B>, so the cast is required.\n            return new Container({\n                ...this.factories,\n                ...factories,\n            } as unknown as MaybeMemoizedFactories<Services & AdditionalServices>);\n        }\n        return this.providesService(fnOrContainer);\n    }\n\n    private providesService<Token extends string, Tokens extends readonly ValidTokens<Services>[], Service>(\n        fn: InjectableFunction<Services, Tokens, Token, Service>\n    ): Container<AddService<Services, Token, Service>> {\n        const token = fn.token;\n        const dependencies: readonly any[] = fn.dependencies;\n\n        const factory = memoize((container: Container<Services>) => {\n            return fn(\n                ...(dependencies.map((t) => {\n                    // To support overwriting an already-existing service with a new implementation, it should be\n                    // possibleto do `provide(A, [A], a => createNewServiceFromOld(a))` – that is, inject a dependency\n                    // with the same token as this service's token.\n                    //\n                    // To avoid a circular dependency (in which the factory for service A depends on itself), we always\n                    // use the service defined in the *parent* container (i.e. this) when injecting a dependency with\n                    // the same token as the service we're providing. If we did not do this, calling `container.get(t)`\n                    // would result in an infinite loop.\n                    return t === token ? this.get(t) : container.get(t);\n                }) as any)\n            );\n        });\n\n        // Safety: `token` and `factory` are property type checked, so extending `this.factories` produces a\n        // MaybeMemoizedFactories object with the expected set of services – but when using the spread operation to\n        // merge two objects, the compiler widens the Token type to string. So we must re-narrow via casting.\n        const factories = { ...this.factories, [token]: factory };\n        return new Container(factories as unknown as MaybeMemoizedFactories<AddService<Services, Token, Service>>);\n    }\n}\n"]}