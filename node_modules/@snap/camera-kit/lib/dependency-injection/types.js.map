{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/dependency-injection/types.ts"],"names":[],"mappings":"","sourcesContent":["/* eslint-disable import/exports-last */\nimport { Container, ContainerToken } from \"./Container\";\n\ntype AsTuple<T> = T extends readonly any[] ? T : never;\n\ntype CorrespondingService<Services, Token extends ValidTokens<Services>> = Token extends ContainerToken\n    ? Container<Services>\n    : Token extends keyof Services\n    ? Services[Token]\n    : never;\n\n/**\n * Given a Services object, the valid Tokens are simply the keys of that object or the special Container Token.\n */\nexport type ValidTokens<Services> = ContainerToken | keyof Services;\n\n/**\n * Given Services, map from a list of Tokens to a list of Service types.\n */\nexport type CorrespondingServices<Services, Tokens extends readonly ValidTokens<Services>[]> = {\n    [K in keyof Tokens]: Tokens[K] extends ValidTokens<Services> ? CorrespondingService<Services, Tokens[K]> : never;\n};\n\n/**\n * A valid InjectableFunction is one that can be successfully called, given some Services, to return a new Service. That\n * is, it must satisfy two conditions:\n *\n *   1. All the Tokens it specifies as dependencies are valid given the Services (i.e. they are either the Container\n *   Token or keys of the Services type).\n *   2. The function argument types correspond to the Services specified by the dependency Tokens.\n *\n * A InjectableFunction also includes its own key Token and dependency Tokens as metadata, so it may be resolved by\n * Container<Services> later.\n */\nexport type InjectableFunction<\n    Services,\n    Tokens,\n    Token extends string,\n    Service\n> = Tokens extends readonly ValidTokens<Services>[]\n    ? {\n          (...args: AsTuple<CorrespondingServices<Services, Tokens>>): Service;\n          token: Token;\n          dependencies: Tokens;\n      }\n    : never;\n\nexport type AnyInjectable = InjectableFunction<any, readonly string[], string, any>;\n\nexport type ServicesFromInjectables<Injectables extends readonly AnyInjectable[]> = {\n    [Name in Injectables[number][\"token\"]]: ReturnType<Extract<Injectables[number], { token: Name }>>;\n};\n\n/**\n * Add a Service with a Token to an existing set of Services.\n */\n// Using a conditional type forces TS language services to evaluate the type -- so when showing e.g. type hints, we\n// will see the mapped type instead of the AddService type alias. This produces better hints.\nexport type AddService<ParentServices, Token extends string, Service> = ParentServices extends any\n    ? // A mapped type produces better, more concise type hints than an intersection type.\n      { [K in keyof ParentServices | Token]: K extends keyof ParentServices ? ParentServices[K] : Service }\n    : never;\n\n/**\n * Create an object type from two tuples of the same length. The first tuple contains the object keys (strings) and the\n * second contains the value types corresponding to those keys.\n *\n * Ex:\n * ```ts\n * type FooBar = ServicesFromTokenizedParams<['foo', 'bar'], [string, number]>\n * const foobar: FooBar = {foo: 'foo', bar: 1}\n * const badfoobar: FooBar = {foo: 1, bar: 'bar'} // any extra, missing, or mis-typed properties raise an error.\n * ```\n */\nexport type ServicesFromTokenizedParams<Tokens, Params> = Tokens extends readonly []\n    ? Params extends readonly []\n        ? {}\n        : never\n    : Tokens extends readonly [infer Token, ...infer RemainingTokens]\n    ? Params extends readonly [infer Param, ...infer RemainingParams]\n        ? Tokens[\"length\"] extends Params[\"length\"]\n            ? Token extends ContainerToken\n                ? Param extends Container<infer S>\n                    ? S & ServicesFromTokenizedParams<RemainingTokens, RemainingParams>\n                    : never\n                : Token extends string\n                ? { [K in Token]: Param extends Container<infer S> ? S : Param } & ServicesFromTokenizedParams<\n                      RemainingTokens,\n                      RemainingParams\n                  >\n                : never\n            : never\n        : never\n    : never;\n"]}