var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long31;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e2) {
    }
    function Long31(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long31.prototype.__isLong__;
    Object.defineProperty(Long31.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long31.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long31.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long31.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long31(lowBits, highBits, unsigned);
    }
    Long31.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p2 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long31.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long31.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long31.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long31.UZERO = UZERO;
    var ONE = fromInt(1);
    Long31.ONE = ONE;
    var UONE = fromInt(1, true);
    Long31.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long31.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long31.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long31.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long31.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long31.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not2() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long31.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long31.fromBytesLE(bytes, unsigned) : Long31.fromBytesBE(bytes, unsigned);
    };
    Long31.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long31(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long31.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long31(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p2 = string.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t2;
      while (start < end) {
        var b2 = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t2 | b2 >> 6];
            chunk[i2++] = b64[b2 & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t2];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer2, offset) {
      var start = offset;
      var j = 0, t2;
      for (var i2 = 0; i2 < string.length; ) {
        var c2 = string.charCodeAt(i2++);
        if (c2 === 61 && j > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c2;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t2 & 3) << 6 | c2;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c2 = 0;
      for (var i = 0; i < string.length; ++i) {
        c2 = string.charCodeAt(i);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t2;
      while (start < end) {
        t2 = buffer2[start++];
        if (t2 < 128)
          chunk[i++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i++] = (t2 & 31) << 6 | buffer2[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t2 >> 10);
          chunk[i++] = 56320 + (t2 & 1023);
        } else
          chunk[i++] = (t2 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from2(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet7(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge3(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge3;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip2(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/browser-headers/dist/browser-headers.umd.js
var require_browser_headers_umd = __commonJS({
  "node_modules/browser-headers/dist/browser-headers.umd.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a2 = factory();
        for (var i in a2)
          (typeof exports2 === "object" ? exports2 : root)[i] = a2[i];
      }
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports3, name, getter) {
            if (!__webpack_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var util_1 = __webpack_require__(3);
            function isBrowserHeaders(arg) {
              return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
            }
            var BrowserHeaders3 = function() {
              function BrowserHeaders4(init, options) {
                if (init === void 0) {
                  init = {};
                }
                if (options === void 0) {
                  options = { splitValues: false };
                }
                var _this = this;
                this.headersMap = {};
                if (init) {
                  if (typeof Headers !== "undefined" && init instanceof Headers) {
                    var keys = util_1.getHeaderKeys(init);
                    keys.forEach(function(key) {
                      var values = util_1.getHeaderValues(init, key);
                      values.forEach(function(value) {
                        if (options.splitValues) {
                          _this.append(key, util_1.splitHeaderValue(value));
                        } else {
                          _this.append(key, value);
                        }
                      });
                    });
                  } else if (isBrowserHeaders(init)) {
                    init.forEach(function(key, values) {
                      _this.append(key, values);
                    });
                  } else if (typeof Map !== "undefined" && init instanceof Map) {
                    var asMap = init;
                    asMap.forEach(function(value, key) {
                      _this.append(key, value);
                    });
                  } else if (typeof init === "string") {
                    this.appendFromString(init);
                  } else if (typeof init === "object") {
                    Object.getOwnPropertyNames(init).forEach(function(key) {
                      var asObject = init;
                      var values = asObject[key];
                      if (Array.isArray(values)) {
                        values.forEach(function(value) {
                          _this.append(key, value);
                        });
                      } else {
                        _this.append(key, values);
                      }
                    });
                  }
                }
              }
              BrowserHeaders4.prototype.appendFromString = function(str) {
                var pairs2 = str.split("\r\n");
                for (var i = 0; i < pairs2.length; i++) {
                  var p2 = pairs2[i];
                  var index = p2.indexOf(":");
                  if (index > 0) {
                    var key = p2.substring(0, index).trim();
                    var value = p2.substring(index + 1).trim();
                    this.append(key, value);
                  }
                }
              };
              BrowserHeaders4.prototype.delete = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (value === void 0) {
                  delete this.headersMap[normalizedKey];
                } else {
                  var existing = this.headersMap[normalizedKey];
                  if (existing) {
                    var index = existing.indexOf(value);
                    if (index >= 0) {
                      existing.splice(index, 1);
                    }
                    if (existing.length === 0) {
                      delete this.headersMap[normalizedKey];
                    }
                  }
                }
              };
              BrowserHeaders4.prototype.append = function(key, value) {
                var _this = this;
                var normalizedKey = util_1.normalizeName(key);
                if (!Array.isArray(this.headersMap[normalizedKey])) {
                  this.headersMap[normalizedKey] = [];
                }
                if (Array.isArray(value)) {
                  value.forEach(function(arrayValue) {
                    _this.headersMap[normalizedKey].push(util_1.normalizeValue(arrayValue));
                  });
                } else {
                  this.headersMap[normalizedKey].push(util_1.normalizeValue(value));
                }
              };
              BrowserHeaders4.prototype.set = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (Array.isArray(value)) {
                  var normalized_1 = [];
                  value.forEach(function(arrayValue) {
                    normalized_1.push(util_1.normalizeValue(arrayValue));
                  });
                  this.headersMap[normalizedKey] = normalized_1;
                } else {
                  this.headersMap[normalizedKey] = [util_1.normalizeValue(value)];
                }
              };
              BrowserHeaders4.prototype.has = function(key, value) {
                var keyArray = this.headersMap[util_1.normalizeName(key)];
                var keyExists = Array.isArray(keyArray);
                if (!keyExists) {
                  return false;
                }
                if (value !== void 0) {
                  var normalizedValue = util_1.normalizeValue(value);
                  return keyArray.indexOf(normalizedValue) >= 0;
                } else {
                  return true;
                }
              };
              BrowserHeaders4.prototype.get = function(key) {
                var values = this.headersMap[util_1.normalizeName(key)];
                if (values !== void 0) {
                  return values.concat();
                }
                return [];
              };
              BrowserHeaders4.prototype.forEach = function(callback) {
                var _this = this;
                Object.getOwnPropertyNames(this.headersMap).forEach(function(key) {
                  callback(key, _this.headersMap[key]);
                }, this);
              };
              BrowserHeaders4.prototype.toHeaders = function() {
                if (typeof Headers !== "undefined") {
                  var headers_1 = new Headers();
                  this.forEach(function(key, values) {
                    values.forEach(function(value) {
                      headers_1.append(key, value);
                    });
                  });
                  return headers_1;
                } else {
                  throw new Error("Headers class is not defined");
                }
              };
              return BrowserHeaders4;
            }();
            exports3.BrowserHeaders = BrowserHeaders3;
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var BrowserHeaders_1 = __webpack_require__(0);
            exports3.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;
          },
          /* 2 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            function iterateHeaders(headers, callback) {
              var iterator2 = headers[Symbol.iterator]();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value[0]);
                entry = iterator2.next();
              }
            }
            exports3.iterateHeaders = iterateHeaders;
            function iterateHeadersKeys(headers, callback) {
              var iterator2 = headers.keys();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value);
                entry = iterator2.next();
              }
            }
            exports3.iterateHeadersKeys = iterateHeadersKeys;
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var iterateHeaders_1 = __webpack_require__(2);
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            exports3.normalizeName = normalizeName;
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            exports3.normalizeValue = normalizeValue;
            function getHeaderValues(headersAsNative, key) {
              var headers = toWindowHeaders(headersAsNative);
              if (headers instanceof Headers && headers.getAll) {
                return headers.getAll(key);
              }
              var getValue = headers.get(key);
              if (getValue && typeof getValue === "string") {
                return [getValue];
              }
              return getValue;
            }
            exports3.getHeaderValues = getHeaderValues;
            function toWindowHeaders(headersAsNative) {
              return headersAsNative;
            }
            function getHeaderKeys(headersAsNative) {
              var headers = toWindowHeaders(headersAsNative);
              var asMap = {};
              var keys = [];
              if (headers.keys) {
                iterateHeaders_1.iterateHeadersKeys(headers, function(key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else if (headers.forEach) {
                headers.forEach(function(_, key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else {
                iterateHeaders_1.iterateHeaders(headers, function(entry) {
                  var key = entry[0];
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              }
              return keys;
            }
            exports3.getHeaderKeys = getHeaderKeys;
            function splitHeaderValue(str) {
              var values = [];
              var commaSpaceValues = str.split(", ");
              commaSpaceValues.forEach(function(commaSpaceValue) {
                commaSpaceValue.split(",").forEach(function(commaValue) {
                  values.push(commaValue);
                });
              });
              return values;
            }
            exports3.splitHeaderValue = splitHeaderValue;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js
var require_grpc_web_client_umd = __commonJS({
  "node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js"(exports2, module2) {
    !function(e2, t2) {
      if ("object" == typeof exports2 && "object" == typeof module2)
        module2.exports = t2();
      else if ("function" == typeof define && define.amd)
        define([], t2);
      else {
        var r2 = t2();
        for (var n2 in r2)
          ("object" == typeof exports2 ? exports2 : e2)[n2] = r2[n2];
      }
    }(exports2, function() {
      return e2 = { 418: function(e3, t3) {
        !function(e4, t4) {
          for (var r2 in t4)
            e4[r2] = t4[r2];
        }(t3, function(e4) {
          var t4 = {};
          function r2(n2) {
            if (t4[n2])
              return t4[n2].exports;
            var o = t4[n2] = { i: n2, l: false, exports: {} };
            return e4[n2].call(o.exports, o, o.exports, r2), o.l = true, o.exports;
          }
          return r2.m = e4, r2.c = t4, r2.i = function(e5) {
            return e5;
          }, r2.d = function(e5, t5, n2) {
            r2.o(e5, t5) || Object.defineProperty(e5, t5, { configurable: false, enumerable: true, get: n2 });
          }, r2.n = function(e5) {
            var t5 = e5 && e5.__esModule ? function() {
              return e5.default;
            } : function() {
              return e5;
            };
            return r2.d(t5, "a", t5), t5;
          }, r2.o = function(e5, t5) {
            return Object.prototype.hasOwnProperty.call(e5, t5);
          }, r2.p = "", r2(r2.s = 1);
        }([function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(3), o = function() {
            function e5(e6, t5) {
              void 0 === e6 && (e6 = {}), void 0 === t5 && (t5 = { splitValues: false });
              var r3, o2 = this;
              this.headersMap = {}, e6 && ("undefined" != typeof Headers && e6 instanceof Headers ? n2.getHeaderKeys(e6).forEach(function(r4) {
                n2.getHeaderValues(e6, r4).forEach(function(e7) {
                  t5.splitValues ? o2.append(r4, n2.splitHeaderValue(e7)) : o2.append(r4, e7);
                });
              }) : "object" == typeof (r3 = e6) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e6.forEach(function(e7, t6) {
                o2.append(e7, t6);
              }) : "undefined" != typeof Map && e6 instanceof Map ? e6.forEach(function(e7, t6) {
                o2.append(t6, e7);
              }) : "string" == typeof e6 ? this.appendFromString(e6) : "object" == typeof e6 && Object.getOwnPropertyNames(e6).forEach(function(t6) {
                var r4 = e6[t6];
                Array.isArray(r4) ? r4.forEach(function(e7) {
                  o2.append(t6, e7);
                }) : o2.append(t6, r4);
              }));
            }
            return e5.prototype.appendFromString = function(e6) {
              for (var t5 = e6.split("\r\n"), r3 = 0; r3 < t5.length; r3++) {
                var n3 = t5[r3], o2 = n3.indexOf(":");
                if (o2 > 0) {
                  var s2 = n3.substring(0, o2).trim(), i = n3.substring(o2 + 1).trim();
                  this.append(s2, i);
                }
              }
            }, e5.prototype.delete = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (void 0 === t5)
                delete this.headersMap[r3];
              else {
                var o2 = this.headersMap[r3];
                if (o2) {
                  var s2 = o2.indexOf(t5);
                  s2 >= 0 && o2.splice(s2, 1), 0 === o2.length && delete this.headersMap[r3];
                }
              }
            }, e5.prototype.append = function(e6, t5) {
              var r3 = this, o2 = n2.normalizeName(e6);
              Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t5) ? t5.forEach(function(e7) {
                r3.headersMap[o2].push(n2.normalizeValue(e7));
              }) : this.headersMap[o2].push(n2.normalizeValue(t5));
            }, e5.prototype.set = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (Array.isArray(t5)) {
                var o2 = [];
                t5.forEach(function(e7) {
                  o2.push(n2.normalizeValue(e7));
                }), this.headersMap[r3] = o2;
              } else
                this.headersMap[r3] = [n2.normalizeValue(t5)];
            }, e5.prototype.has = function(e6, t5) {
              var r3 = this.headersMap[n2.normalizeName(e6)];
              if (!Array.isArray(r3))
                return false;
              if (void 0 !== t5) {
                var o2 = n2.normalizeValue(t5);
                return r3.indexOf(o2) >= 0;
              }
              return true;
            }, e5.prototype.get = function(e6) {
              var t5 = this.headersMap[n2.normalizeName(e6)];
              return void 0 !== t5 ? t5.concat() : [];
            }, e5.prototype.forEach = function(e6) {
              var t5 = this;
              Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
                e6(r3, t5.headersMap[r3]);
              }, this);
            }, e5.prototype.toHeaders = function() {
              if ("undefined" != typeof Headers) {
                var e6 = new Headers();
                return this.forEach(function(t5, r3) {
                  r3.forEach(function(r4) {
                    e6.append(t5, r4);
                  });
                }), e6;
              }
              throw new Error("Headers class is not defined");
            }, e5;
          }();
          t4.BrowserHeaders = o;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(0);
          t4.BrowserHeaders = n2.BrowserHeaders;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.iterateHeaders = function(e5, t5) {
            for (var r3 = e5[Symbol.iterator](), n2 = r3.next(); !n2.done; )
              t5(n2.value[0]), n2 = r3.next();
          }, t4.iterateHeadersKeys = function(e5, t5) {
            for (var r3 = e5.keys(), n2 = r3.next(); !n2.done; )
              t5(n2.value), n2 = r3.next();
          };
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(2);
          t4.normalizeName = function(e5) {
            if ("string" != typeof e5 && (e5 = String(e5)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e5))
              throw new TypeError("Invalid character in header field name");
            return e5.toLowerCase();
          }, t4.normalizeValue = function(e5) {
            return "string" != typeof e5 && (e5 = String(e5)), e5;
          }, t4.getHeaderValues = function(e5, t5) {
            var r3 = e5;
            if (r3 instanceof Headers && r3.getAll)
              return r3.getAll(t5);
            var n3 = r3.get(t5);
            return n3 && "string" == typeof n3 ? [n3] : n3;
          }, t4.getHeaderKeys = function(e5) {
            var t5 = e5, r3 = {}, o = [];
            return t5.keys ? n2.iterateHeadersKeys(t5, function(e6) {
              r3[e6] || (r3[e6] = true, o.push(e6));
            }) : t5.forEach ? t5.forEach(function(e6, t6) {
              r3[t6] || (r3[t6] = true, o.push(t6));
            }) : n2.iterateHeaders(t5, function(e6) {
              var t6 = e6[0];
              r3[t6] || (r3[t6] = true, o.push(t6));
            }), o;
          }, t4.splitHeaderValue = function(e5) {
            var t5 = [];
            return e5.split(", ").forEach(function(e6) {
              e6.split(",").forEach(function(e7) {
                t5.push(e7);
              });
            }), t5;
          };
        }]));
      }, 617: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ChunkParser = t3.ChunkType = t3.encodeASCII = t3.decodeASCII = void 0;
        var n2, o = r2(65);
        function s2(e4) {
          return 9 === (t4 = e4) || 10 === t4 || 13 === t4 || e4 >= 32 && e4 <= 126;
          var t4;
        }
        function i(e4) {
          for (var t4 = 0; t4 !== e4.length; ++t4)
            if (!s2(e4[t4]))
              throw new Error("Metadata is not valid (printable) ASCII");
          return String.fromCharCode.apply(String, Array.prototype.slice.call(e4));
        }
        function a2(e4) {
          return 128 == (128 & e4.getUint8(0));
        }
        function u2(e4) {
          return e4.getUint32(1, false);
        }
        function d2(e4, t4, r3) {
          return e4.byteLength - t4 >= r3;
        }
        function c2(e4, t4, r3) {
          if (e4.slice)
            return e4.slice(t4, r3);
          var n3 = e4.length;
          void 0 !== r3 && (n3 = r3);
          for (var o2 = new Uint8Array(n3 - t4), s3 = 0, i2 = t4; i2 < n3; i2++)
            o2[s3++] = e4[i2];
          return o2;
        }
        t3.decodeASCII = i, t3.encodeASCII = function(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0; r3 !== e4.length; ++r3) {
            var n3 = e4.charCodeAt(r3);
            if (!s2(n3))
              throw new Error("Metadata contains invalid ASCII");
            t4[r3] = n3;
          }
          return t4;
        }, function(e4) {
          e4[e4.MESSAGE = 1] = "MESSAGE", e4[e4.TRAILERS = 2] = "TRAILERS";
        }(n2 = t3.ChunkType || (t3.ChunkType = {}));
        var p2 = function() {
          function e4() {
            this.buffer = null, this.position = 0;
          }
          return e4.prototype.parse = function(e5, t4) {
            if (0 === e5.length && t4)
              return [];
            var r3, s3 = [];
            if (null == this.buffer)
              this.buffer = e5, this.position = 0;
            else if (this.position === this.buffer.byteLength)
              this.buffer = e5, this.position = 0;
            else {
              var p3 = this.buffer.byteLength - this.position, h2 = new Uint8Array(p3 + e5.byteLength), f3 = c2(this.buffer, this.position);
              h2.set(f3, 0);
              var l2 = new Uint8Array(e5);
              h2.set(l2, p3), this.buffer = h2, this.position = 0;
            }
            for (; ; ) {
              if (!d2(this.buffer, this.position, 5))
                return s3;
              var g = c2(this.buffer, this.position, this.position + 5), b2 = new DataView(g.buffer, g.byteOffset, g.byteLength), y2 = u2(b2);
              if (!d2(this.buffer, this.position, 5 + y2))
                return s3;
              var v2 = c2(this.buffer, this.position + 5, this.position + 5 + y2);
              if (this.position += 5 + y2, a2(b2))
                return s3.push({ chunkType: n2.TRAILERS, trailers: (r3 = v2, new o.Metadata(i(r3))) }), s3;
              s3.push({ chunkType: n2.MESSAGE, data: v2 });
            }
          }, e4;
        }();
        t3.ChunkParser = p2;
      }, 8: function(e3, t3) {
        "use strict";
        var r2;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.httpStatusToCode = t3.Code = void 0, function(e4) {
          e4[e4.OK = 0] = "OK", e4[e4.Canceled = 1] = "Canceled", e4[e4.Unknown = 2] = "Unknown", e4[e4.InvalidArgument = 3] = "InvalidArgument", e4[e4.DeadlineExceeded = 4] = "DeadlineExceeded", e4[e4.NotFound = 5] = "NotFound", e4[e4.AlreadyExists = 6] = "AlreadyExists", e4[e4.PermissionDenied = 7] = "PermissionDenied", e4[e4.ResourceExhausted = 8] = "ResourceExhausted", e4[e4.FailedPrecondition = 9] = "FailedPrecondition", e4[e4.Aborted = 10] = "Aborted", e4[e4.OutOfRange = 11] = "OutOfRange", e4[e4.Unimplemented = 12] = "Unimplemented", e4[e4.Internal = 13] = "Internal", e4[e4.Unavailable = 14] = "Unavailable", e4[e4.DataLoss = 15] = "DataLoss", e4[e4.Unauthenticated = 16] = "Unauthenticated";
        }(r2 = t3.Code || (t3.Code = {})), t3.httpStatusToCode = function(e4) {
          switch (e4) {
            case 0:
              return r2.Internal;
            case 200:
              return r2.OK;
            case 400:
              return r2.InvalidArgument;
            case 401:
              return r2.Unauthenticated;
            case 403:
              return r2.PermissionDenied;
            case 404:
              return r2.NotFound;
            case 409:
              return r2.Aborted;
            case 412:
              return r2.FailedPrecondition;
            case 429:
              return r2.ResourceExhausted;
            case 499:
              return r2.Canceled;
            case 500:
              return r2.Unknown;
            case 501:
              return r2.Unimplemented;
            case 503:
              return r2.Unavailable;
            case 504:
              return r2.DeadlineExceeded;
            default:
              return r2.Unknown;
          }
        };
      }, 934: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.client = void 0;
        var n2 = r2(65), o = r2(617), s2 = r2(8), i = r2(346), a2 = r2(57), u2 = r2(882);
        t3.client = function(e4, t4) {
          return new d2(e4, t4);
        };
        var d2 = function() {
          function e4(e5, t4) {
            this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e5, this.props = t4, this.createTransport();
          }
          return e4.prototype.createTransport = function() {
            var e5 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t4 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e5, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
            this.props.transport ? this.transport = this.props.transport(t4) : this.transport = a2.makeDefaultTransport(t4);
          }, e4.prototype.onTransportHeaders = function(e5, t4) {
            if (this.props.debug && i.debug("onHeaders", e5, t4), this.closed)
              this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
            else if (0 === t4)
              ;
            else {
              this.responseHeaders = e5, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
              var r3 = c2(e5);
              this.props.debug && i.debug("onHeaders.gRPCStatus", r3);
              var n3 = r3 && r3 >= 0 ? r3 : s2.httpStatusToCode(t4);
              this.props.debug && i.debug("onHeaders.code", n3);
              var o2 = e5.get("grpc-message") || [];
              if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e5), n3 !== s2.Code.OK) {
                var a3 = this.decodeGRPCStatus(o2[0]);
                this.rawOnError(n3, a3, e5);
              }
            }
          }, e4.prototype.onTransportChunk = function(e5) {
            var t4 = this;
            if (this.closed)
              this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
            else {
              var r3 = [];
              try {
                r3 = this.parser.parse(e5);
              } catch (e6) {
                return this.props.debug && i.debug("onChunk.parsing error", e6, e6.message), void this.rawOnError(s2.Code.Internal, "parsing error: " + e6.message);
              }
              r3.forEach(function(e6) {
                if (e6.chunkType === o.ChunkType.MESSAGE) {
                  var r4 = t4.methodDefinition.responseType.deserializeBinary(e6.data);
                  t4.rawOnMessage(r4);
                } else
                  e6.chunkType === o.ChunkType.TRAILERS && (t4.responseHeaders ? (t4.responseTrailers = new n2.Metadata(e6.trailers), t4.props.debug && i.debug("onChunk.trailers", t4.responseTrailers)) : (t4.responseHeaders = new n2.Metadata(e6.trailers), t4.rawOnHeaders(t4.responseHeaders)));
              });
            }
          }, e4.prototype.onTransportEnd = function() {
            if (this.props.debug && i.debug("grpc.onEnd"), this.closed)
              this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
            else if (void 0 !== this.responseTrailers) {
              var e5 = c2(this.responseTrailers);
              if (null !== e5) {
                var t4 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t4[0]);
                this.rawOnEnd(e5, r3, this.responseTrailers);
              } else
                this.rawOnError(s2.Code.Internal, "Response closed without grpc-status (Trailers provided)");
            } else {
              if (void 0 === this.responseHeaders)
                return void this.rawOnError(s2.Code.Unknown, "Response closed without headers");
              var n3 = c2(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
              if (this.props.debug && i.debug("grpc.headers only response ", n3, o2), null === n3)
                return void this.rawOnEnd(s2.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
              var a3 = this.decodeGRPCStatus(o2[0]);
              this.rawOnEnd(n3, a3, this.responseHeaders);
            }
          }, e4.prototype.decodeGRPCStatus = function(e5) {
            if (!e5)
              return "";
            try {
              return decodeURIComponent(e5);
            } catch (t4) {
              return e5;
            }
          }, e4.prototype.rawOnEnd = function(e5, t4, r3) {
            var n3 = this;
            this.props.debug && i.debug("rawOnEnd", e5, t4, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o2) {
              if (!n3.closed)
                try {
                  o2(e5, t4, r3);
                } catch (e6) {
                  setTimeout(function() {
                    throw e6;
                  }, 0);
                }
            }));
          }, e4.prototype.rawOnHeaders = function(e5) {
            this.props.debug && i.debug("rawOnHeaders", e5), this.completed || this.onHeadersCallbacks.forEach(function(t4) {
              try {
                t4(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            });
          }, e4.prototype.rawOnError = function(e5, t4, r3) {
            var o2 = this;
            void 0 === r3 && (r3 = new n2.Metadata()), this.props.debug && i.debug("rawOnError", e5, t4), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n3) {
              if (!o2.closed)
                try {
                  n3(e5, t4, r3);
                } catch (e6) {
                  setTimeout(function() {
                    throw e6;
                  }, 0);
                }
            }));
          }, e4.prototype.rawOnMessage = function(e5) {
            var t4 = this;
            this.props.debug && i.debug("rawOnMessage", e5.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
              if (!t4.closed)
                try {
                  r3(e5);
                } catch (e6) {
                  setTimeout(function() {
                    throw e6;
                  }, 0);
                }
            });
          }, e4.prototype.onHeaders = function(e5) {
            this.onHeadersCallbacks.push(e5);
          }, e4.prototype.onMessage = function(e5) {
            this.onMessageCallbacks.push(e5);
          }, e4.prototype.onEnd = function(e5) {
            this.onEndCallbacks.push(e5);
          }, e4.prototype.start = function(e5) {
            if (this.started)
              throw new Error("Client already started - cannot .start()");
            this.started = true;
            var t4 = new n2.Metadata(e5 || {});
            t4.set("content-type", "application/grpc-web+proto"), t4.set("x-grpc-web", "1"), this.transport.start(t4);
          }, e4.prototype.send = function(e5) {
            if (!this.started)
              throw new Error("Client not started - .start() must be called before .send()");
            if (this.closed)
              throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending)
              throw new Error("Client already finished sending - cannot .send()");
            if (!this.methodDefinition.requestStream && this.sentFirstMessage)
              throw new Error("Message already sent for non-client-streaming method - cannot .send()");
            this.sentFirstMessage = true;
            var t4 = u2.frameRequest(e5);
            this.transport.sendMessage(t4);
          }, e4.prototype.finishSend = function() {
            if (!this.started)
              throw new Error("Client not started - .finishSend() must be called before .close()");
            if (this.closed)
              throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending)
              throw new Error("Client already finished sending - cannot .finishSend()");
            this.finishedSending = true, this.transport.finishSend();
          }, e4.prototype.close = function() {
            if (!this.started)
              throw new Error("Client not started - .start() must be called before .close()");
            if (this.closed)
              throw new Error("Client already closed - cannot .close()");
            this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
          }, e4;
        }();
        function c2(e4) {
          var t4 = e4.get("grpc-status") || [];
          if (t4.length > 0)
            try {
              var r3 = t4[0];
              return parseInt(r3, 10);
            } catch (e5) {
              return null;
            }
          return null;
        }
      }, 346: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.debug = void 0, t3.debug = function() {
          for (var e4 = [], t4 = 0; t4 < arguments.length; t4++)
            e4[t4] = arguments[t4];
          console.debug ? console.debug.apply(null, e4) : console.log.apply(null, e4);
        };
      }, 607: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.grpc = void 0;
        var n2, o = r2(418), s2 = r2(57), i = r2(229), a2 = r2(540), u2 = r2(210), d2 = r2(859), c2 = r2(8), p2 = r2(938), h2 = r2(35), f3 = r2(934);
        (n2 = t3.grpc || (t3.grpc = {})).setDefaultTransport = s2.setDefaultTransportFactory, n2.CrossBrowserHttpTransport = d2.CrossBrowserHttpTransport, n2.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n2.XhrTransport = u2.XhrTransport, n2.WebsocketTransport = a2.WebsocketTransport, n2.Code = c2.Code, n2.Metadata = o.BrowserHeaders, n2.client = function(e4, t4) {
          return f3.client(e4, t4);
        }, n2.invoke = p2.invoke, n2.unary = h2.unary;
      }, 938: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.invoke = void 0;
        var n2 = r2(934);
        t3.invoke = function(e4, t4) {
          if (e4.requestStream)
            throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
          var r3 = n2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return t4.onHeaders && r3.onHeaders(t4.onHeaders), t4.onMessage && r3.onMessage(t4.onMessage), t4.onEnd && r3.onEnd(t4.onEnd), r3.start(t4.metadata), r3.send(t4.request), r3.finishSend(), { close: function() {
            r3.close();
          } };
        };
      }, 65: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Metadata = void 0;
        var n2 = r2(418);
        Object.defineProperty(t3, "Metadata", { enumerable: true, get: function() {
          return n2.BrowserHeaders;
        } });
      }, 57: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.makeDefaultTransport = t3.setDefaultTransportFactory = void 0;
        var n2 = r2(859), o = function(e4) {
          return n2.CrossBrowserHttpTransport({ withCredentials: false })(e4);
        };
        t3.setDefaultTransportFactory = function(e4) {
          o = e4;
        }, t3.makeDefaultTransport = function(e4) {
          return o(e4);
        };
      }, 229: function(e3, t3, r2) {
        "use strict";
        var n2 = this && this.__assign || function() {
          return (n2 = Object.assign || function(e4) {
            for (var t4, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
              for (var o2 in t4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(t4, o2) && (e4[o2] = t4[o2]);
            return e4;
          }).apply(this, arguments);
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectFetchSupport = t3.FetchReadableStreamTransport = void 0;
        var o = r2(65), s2 = r2(346);
        t3.FetchReadableStreamTransport = function(e4) {
          return function(t4) {
            return function(e5, t5) {
              return e5.debug && s2.debug("fetchRequest", e5), new i(e5, t5);
            }(t4, e4);
          };
        };
        var i = function() {
          function e4(e5, t4) {
            this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e5, this.init = t4;
          }
          return e4.prototype.pump = function(e5, t4) {
            var r3 = this;
            if (this.reader = e5, this.cancelled)
              return this.options.debug && s2.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e6) {
                r3.options.debug && s2.debug("Fetch.pump.reader.cancel exception", e6);
              });
            this.reader.read().then(function(e6) {
              if (e6.done)
                return r3.options.onEnd(), t4;
              r3.options.onChunk(e6.value), r3.pump(r3.reader, t4);
            }).catch(function(e6) {
              r3.cancelled ? r3.options.debug && s2.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s2.debug("Fetch.catch", e6.message), r3.options.onEnd(e6));
            });
          }, e4.prototype.send = function(e5) {
            var t4 = this;
            fetch(this.options.url, n2(n2({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e5, signal: this.controller && this.controller.signal })).then(function(e6) {
              if (t4.options.debug && s2.debug("Fetch.response", e6), t4.options.onHeaders(new o.Metadata(e6.headers), e6.status), !e6.body)
                return e6;
              t4.pump(e6.body.getReader(), e6);
            }).catch(function(e6) {
              t4.cancelled ? t4.options.debug && s2.debug("Fetch.catch - request cancelled") : (t4.cancelled = true, t4.options.debug && s2.debug("Fetch.catch", e6.message), t4.options.onEnd(e6));
            });
          }, e4.prototype.sendMessage = function(e5) {
            this.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            this.metadata = e5;
          }, e4.prototype.cancel = function() {
            var e5 = this;
            this.cancelled ? this.options.debug && s2.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s2.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s2.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s2.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t4) {
              e5.options.debug && s2.debug("Fetch.cancel.reader.cancel exception", t4);
            })) : this.options.debug && s2.debug("Fetch.cancel before reader"));
          }, e4;
        }();
        t3.detectFetchSupport = function() {
          return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
        };
      }, 859: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CrossBrowserHttpTransport = void 0;
        var n2 = r2(229), o = r2(210);
        t3.CrossBrowserHttpTransport = function(e4) {
          if (n2.detectFetchSupport()) {
            var t4 = { credentials: e4.withCredentials ? "include" : "same-origin" };
            return n2.FetchReadableStreamTransport(t4);
          }
          return o.XhrTransport({ withCredentials: e4.withCredentials });
        };
      }, 210: function(e3, t3, r2) {
        "use strict";
        var n2, o = this && this.__extends || (n2 = function(e4, t4) {
          return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
            e5.__proto__ = t5;
          } || function(e5, t5) {
            for (var r3 in t5)
              Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
          })(e4, t4);
        }, function(e4, t4) {
          function r3() {
            this.constructor = e4;
          }
          n2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
        });
        Object.defineProperty(t3, "__esModule", { value: true }), t3.stringToArrayBuffer = t3.MozChunkedArrayBufferXHR = t3.XHR = t3.XhrTransport = void 0;
        var s2 = r2(65), i = r2(346), a2 = r2(849);
        t3.XhrTransport = function(e4) {
          return function(t4) {
            if (a2.detectMozXHRSupport())
              return new d2(t4, e4);
            if (a2.detectXHROverrideMimeTypeSupport())
              return new u2(t4, e4);
            throw new Error("This environment's XHR implementation cannot support binary transfer.");
          };
        };
        var u2 = function() {
          function e4(e5, t4) {
            this.options = e5, this.init = t4;
          }
          return e4.prototype.onProgressEvent = function() {
            this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
            var e5 = this.xhr.response.substr(this.index);
            this.index = this.xhr.response.length;
            var t4 = p2(e5);
            this.options.onChunk(t4);
          }, e4.prototype.onLoadEvent = function() {
            this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
          }, e4.prototype.onStateChange = function() {
            this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s2.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
          }, e4.prototype.sendMessage = function(e5) {
            this.xhr.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            var t4 = this;
            this.metadata = e5;
            var r3 = new XMLHttpRequest();
            this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e6, t5) {
              r3.setRequestHeader(e6, t5.join(", "));
            }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e6) {
              t4.options.debug && i.debug("XHR.error", e6), t4.options.onEnd(e6.error);
            });
          }, e4.prototype.configureXhr = function() {
            this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }, e4.prototype.cancel = function() {
            this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
          }, e4;
        }();
        t3.XHR = u2;
        var d2 = function(e4) {
          function t4() {
            return null !== e4 && e4.apply(this, arguments) || this;
          }
          return o(t4, e4), t4.prototype.configureXhr = function() {
            this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
          }, t4.prototype.onProgressEvent = function() {
            var e5 = this.xhr.response;
            this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e5)), this.options.onChunk(new Uint8Array(e5));
          }, t4;
        }(u2);
        function c2(e4, t4) {
          var r3 = e4.charCodeAt(t4);
          if (r3 >= 55296 && r3 <= 56319) {
            var n3 = e4.charCodeAt(t4 + 1);
            n3 >= 56320 && n3 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320));
          }
          return r3;
        }
        function p2(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0, n3 = 0; n3 < e4.length; n3++) {
            var o2 = String.prototype.codePointAt ? e4.codePointAt(n3) : c2(e4, n3);
            t4[r3++] = 255 & o2;
          }
          return t4;
        }
        t3.MozChunkedArrayBufferXHR = d2, t3.stringToArrayBuffer = p2;
      }, 849: function(e3, t3) {
        "use strict";
        var r2;
        function n2() {
          if (void 0 !== r2)
            return r2;
          if (XMLHttpRequest) {
            r2 = new XMLHttpRequest();
            try {
              r2.open("GET", "https://localhost");
            } catch (e4) {
            }
          }
          return r2;
        }
        function o(e4) {
          var t4 = n2();
          if (!t4)
            return false;
          try {
            return t4.responseType = e4, t4.responseType === e4;
          } catch (e5) {
          }
          return false;
        }
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectXHROverrideMimeTypeSupport = t3.detectMozXHRSupport = t3.xhrSupportsResponseType = void 0, t3.xhrSupportsResponseType = o, t3.detectMozXHRSupport = function() {
          return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
        }, t3.detectXHROverrideMimeTypeSupport = function() {
          return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
        };
      }, 540: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WebsocketTransport = void 0;
        var n2, o = r2(346), s2 = r2(617);
        !function(e4) {
          e4[e4.FINISH_SEND = 1] = "FINISH_SEND";
        }(n2 || (n2 = {}));
        var i = new Uint8Array([1]);
        t3.WebsocketTransport = function() {
          return function(e4) {
            return function(e5) {
              e5.debug && o.debug("websocketRequest", e5);
              var t4, r3 = function(e6) {
                if ("https://" === e6.substr(0, 8))
                  return "wss://" + e6.substr(8);
                if ("http://" === e6.substr(0, 7))
                  return "ws://" + e6.substr(7);
                throw new Error("Websocket transport constructed with non-https:// or http:// host.");
              }(e5.url), a2 = [];
              function u2(e6) {
                if (e6 === n2.FINISH_SEND)
                  t4.send(i);
                else {
                  var r4 = e6, o2 = new Int8Array(r4.byteLength + 1);
                  o2.set(new Uint8Array([0])), o2.set(r4, 1), t4.send(o2);
                }
              }
              return { sendMessage: function(e6) {
                t4 && t4.readyState !== t4.CONNECTING ? u2(e6) : a2.push(e6);
              }, finishSend: function() {
                t4 && t4.readyState !== t4.CONNECTING ? u2(n2.FINISH_SEND) : a2.push(n2.FINISH_SEND);
              }, start: function(n3) {
                (t4 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t4.onopen = function() {
                  var r4;
                  e5.debug && o.debug("websocketRequest.onopen"), t4.send((r4 = "", n3.forEach(function(e6, t5) {
                    r4 += e6 + ": " + t5.join(", ") + "\r\n";
                  }), s2.encodeASCII(r4))), a2.forEach(function(e6) {
                    u2(e6);
                  });
                }, t4.onclose = function(t5) {
                  e5.debug && o.debug("websocketRequest.onclose", t5), e5.onEnd();
                }, t4.onerror = function(t5) {
                  e5.debug && o.debug("websocketRequest.onerror", t5);
                }, t4.onmessage = function(t5) {
                  e5.onChunk(new Uint8Array(t5.data));
                };
              }, cancel: function() {
                e5.debug && o.debug("websocket.abort"), t4.close();
              } };
            }(e4);
          };
        };
      }, 35: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.unary = void 0;
        var n2 = r2(65), o = r2(934);
        t3.unary = function(e4, t4) {
          if (e4.responseStream)
            throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
          if (e4.requestStream)
            throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
          var r3 = null, s2 = null, i = o.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return i.onHeaders(function(e5) {
            r3 = e5;
          }), i.onMessage(function(e5) {
            s2 = e5;
          }), i.onEnd(function(e5, o2, i2) {
            t4.onEnd({ status: e5, statusMessage: o2, headers: r3 || new n2.Metadata(), message: s2, trailers: i2 });
          }), i.start(t4.metadata), i.send(t4.request), i.finishSend(), { close: function() {
            i.close();
          } };
        };
      }, 882: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.frameRequest = void 0, t3.frameRequest = function(e4) {
          var t4 = e4.serializeBinary(), r2 = new ArrayBuffer(t4.byteLength + 5);
          return new DataView(r2, 1, 4).setUint32(0, t4.length, false), new Uint8Array(r2, 5).set(t4), new Uint8Array(r2);
        };
      } }, t2 = {}, function r2(n2) {
        if (t2[n2])
          return t2[n2].exports;
        var o = t2[n2] = { exports: {} };
        return e2[n2].call(o.exports, o, o.exports, r2), o.exports;
      }(607);
      var e2, t2;
    });
  }
});

// node_modules/@snap/camera-kit/lib/environment.json
var environment_default = { PACKAGE_VERSION: "0.14.0-alpha.1" };

// node_modules/@snap/camera-kit/lib/lensCoreWasmVersions.json
var lensCoreWasmVersions_default = {
  version: "239",
  buildNumber: "148",
  baseUrl: "https://cf-st.sc-cdn.net/d/vzrhSjRylX02Y8J6eVgUV?go=IgsKCTIBBEgBUFxgAQ%3D%3D&uc=92"
};

// node_modules/@snap/camera-kit/lib/common/copyDefinedProperties.js
function copyDefinedProperties(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== void 0));
}

// node_modules/@snap/camera-kit/lib/configurationOverrides.js
var windowFieldPrefix = "__snap_camkit_override__";
var configPropertiesToOverride = [
  "wasmEndpointOverride",
  "logger",
  "logLevel",
  "userAgentFlavor"
];
configPropertiesToOverride.forEach((fieldToOverride) => {
  defineWindowField(fieldToOverride);
});
function defineWindowField(propertyToOverride) {
  if (typeof window === "undefined")
    return;
  Object.defineProperty(window, `${windowFieldPrefix}${propertyToOverride}`, {
    get() {
      var _a;
      return (_a = getConfigurationOverrides()) === null || _a === void 0 ? void 0 : _a[propertyToOverride];
    },
    set(value) {
      const storedOverrides = Object.assign(Object.assign({}, getConfigurationOverrides()), { [propertyToOverride]: value });
      if (Object.values(storedOverrides).every((value2) => typeof value2 === "undefined")) {
        sessionStorage.removeItem(windowFieldPrefix);
      } else {
        sessionStorage.setItem(windowFieldPrefix, JSON.stringify(storedOverrides));
      }
    },
    enumerable: false,
    configurable: true
  });
}
function getConfigurationOverrides() {
  if (!sessionStorage)
    return void 0;
  const overridesString = sessionStorage.getItem(windowFieldPrefix);
  return overridesString && JSON.parse(overridesString);
}

// node_modules/@snap/camera-kit/lib/dependency-injection/Injectable.js
function Injectable(token, dependenciesOrFn, maybeFn) {
  const dependencies = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];
  const fn = typeof dependenciesOrFn === "function" ? dependenciesOrFn : maybeFn;
  if (!fn) {
    throw new TypeError("[Factory] Received invalid arguments. The factory function must be either the second or third argument.");
  }
  if (fn.length !== dependencies.length) {
    throw new TypeError(`[Factory] Function arity does not match the number of dependencies. Function has arity ${fn.length}, but ${dependencies.length} dependencies were specified.
Dependencies: ${JSON.stringify(dependencies)}`);
  }
  const factory = (...args) => fn(...args);
  factory.token = token;
  factory.dependencies = dependencies;
  return factory;
}

// node_modules/@snap/camera-kit/lib/configuration.js
var defaultConfiguration = {
  // If the applications doesn't provide performance data (e.g. via estimateLensPerformance), we'll use 0 to indicate
  // no performance estimation occurred. This is indicative of typical performance-targeting logic, which often
  // defaults to the lowest-tier experience in the absense of performance cluster data.
  lensPerformance: { cluster: 0, benchmarks: [], webglRendererInfo: "unknown" },
  logger: "noop",
  logLevel: "info",
  shouldUseWorker: true,
  apiHostname: "camera-kit-api.snapar.com",
  userAgentFlavor: "release"
};
var configurationToken = "configuration";
var createCameraKitConfigurationFactory = (configuration) => {
  const overrides = getConfigurationOverrides();
  if (overrides) {
    console.warn("Configuration overrides applied", overrides);
  }
  return Injectable(configurationToken, () => {
    const safeConfig = Object.assign(Object.assign({}, configuration), { lensPerformance: configuration.lensPerformance instanceof Promise ? (
      // Safety: defaultConfiguration.lensPerformance is defined (it's hardcoded above).
      configuration.lensPerformance.catch(() => defaultConfiguration.lensPerformance)
    ) : configuration.lensPerformance });
    return Object.assign(Object.assign(Object.assign({}, defaultConfiguration), copyDefinedProperties(safeConfig)), copyDefinedProperties(overrides !== null && overrides !== void 0 ? overrides : {}));
  });
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2])
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g[n2](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v2) {
    if (f3(v2), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v6) {
      resolve({ value: v6, done: d2 });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay3);
    }
    this.pending = true;
    this.delay = delay3;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay3);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && this.delay === delay3 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay3) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay3);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id2 = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay3);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      immediateProvider.clearImmediate(id2);
      if (scheduler._scheduled === id2) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay3, state) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay3);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 > 0) {
      return _super.prototype.schedule.call(this, state, delay3);
    }
    this.delay = delay3;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay3) {
    return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay3);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay3);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      animationFrameProvider.cancelAnimationFrame(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (Number.isFinite(delay3)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay3);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay3);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    this.delay = scheduler.frame + delay3;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay3) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay3);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay3));
    } else {
      this.unsubscribe();
    }
  }, delay3);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay3);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay3);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay3);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay3));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i) {
      return map(function(b2, ii) {
        return resultSelector(a2, b2, i, ii);
      })(innerFrom(project(a2, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s2 = 0; s2 < subscriptions.length; s2++) {
            s2 !== i2 && subscriptions[s2].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i) {
        return innerFrom(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay3 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay3 != null) {
            var notifier = typeof delay3 === "number" ? timer(delay3) : innerFrom(delay3(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@snap/camera-kit/lib/common/loadScript.js
function loadScript(scriptUri) {
  return new Promise((resolve, reject) => {
    const scriptElement = document.createElement("script");
    scriptElement.src = scriptUri;
    scriptElement.async = true;
    merge(fromEvent(scriptElement, "load").pipe(tap(() => resolve(scriptElement))), fromEvent(scriptElement, "error").pipe(tap((e2) => reject(e2)))).pipe(take(1)).subscribe();
    document.body.appendChild(scriptElement);
  });
}

// node_modules/@snap/camera-kit/lib/common/typeguards.js
function isString(value) {
  return typeof value === "string";
}
function isSafeString(value) {
  return isString(value) && encodeURIComponent(value) === value;
}
function isNumber(value) {
  return typeof value === "number";
}
function isArrayOfType(elementTypeGuard, value) {
  return Array.isArray(value) && value.every((id2) => elementTypeGuard(id2));
}
function isSafeStringArray(value) {
  return isArrayOfType(isSafeString, value);
}
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}
function isTypedArray(value) {
  return value instanceof Object.getPrototypeOf(Uint8Array);
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isFunction2(value) {
  return typeof value === "function";
}
function predicateRecordValues(predicate) {
  return (value) => {
    for (const v2 of Object.values(value))
      if (!predicate(v2))
        return false;
    return true;
  };
}
function isEmptyOrSafeUrl(urlString) {
  if (!urlString)
    return true;
  try {
    const url = new URL(urlString);
    return url.protocol === "https:" || url.protocol === "http:";
  } catch (_a) {
    return false;
  }
}

// node_modules/@snap/camera-kit/lib/handlers/debugHandler.js
var createDebugHandler = () => {
  var _a;
  const noCustomWasmEndpoint = !((_a = getConfigurationOverrides()) === null || _a === void 0 ? void 0 : _a.wasmEndpointOverride);
  if (noCustomWasmEndpoint) {
    return (next) => next;
  }
  return (next) => (input, init) => {
    var _a2;
    const url = isString(input) ? input : (_a2 = input === null || input === void 0 ? void 0 : input.url) !== null && _a2 !== void 0 ? _a2 : "";
    if (url.startsWith("https://lens-core-wasm.sc-corp.net/")) {
      return next(input, Object.assign(Object.assign({}, init), { credentials: "include" }));
    }
    return next(input, init);
  };
};

// node_modules/@snap/camera-kit/lib/handlers/HandlerChainBuilder.js
var HandlerChainBuilder = class _HandlerChainBuilder {
  constructor(inner) {
    this.inner = inner;
  }
  get handler() {
    return this.inner;
  }
  map(outer) {
    const outerHandler = (req, metadata) => {
      var _a;
      const abort = new AbortController();
      const signal = abort.signal;
      let innerCompleted = false;
      const maybeAbort = () => {
        var _a2;
        if (signal.aborted || innerCompleted)
          return;
        abort.abort();
        (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
      };
      (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", maybeAbort);
      const innerHandler = new Proxy(this.inner, {
        apply: (target, thisArg, args) => {
          const [req2, metadata2] = args;
          if (metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.isSideEffect)
            innerCompleted = true;
          const abortListeners = [];
          signal.addEventListener = new Proxy(signal.addEventListener, {
            apply: (target2, thisArg2, args2) => {
              abortListeners.push(args2[1]);
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          const cleanupAndMarkComplete = () => {
            var _a2;
            (_a2 = metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
            abortListeners.forEach((listener) => signal.removeEventListener("abort", listener));
            innerCompleted = true;
          };
          const innerResponse = Reflect.apply(target, thisArg, [
            req2,
            Object.assign(Object.assign({}, metadata2), { isSideEffect: false, signal })
          ]);
          innerResponse.catch(() => {
          }).then(cleanupAndMarkComplete);
          return innerResponse;
        }
      });
      const outerResponse = outer(innerHandler)(req, metadata);
      outerResponse.catch(() => {
      }).then(maybeAbort);
      return outerResponse;
    };
    return new _HandlerChainBuilder(outerHandler);
  }
};

// node_modules/@snap/camera-kit/lib/common/entries.js
var entries = (o) => Object.entries(o);

// node_modules/@snap/camera-kit/lib/logger/logger.js
var logEntriesSubject = new Subject();
var logLevelMap = {
  error: 3,
  warn: 2,
  log: 1,
  info: 1,
  debug: 0
};
function resetLogger() {
  return logEntriesSubject = new Subject();
}
function getLogger(module2) {
  return entries(logLevelMap).reduce((logger21, [level]) => {
    logger21[level] = (...messages) => {
      logEntriesSubject.next({
        time: /* @__PURE__ */ new Date(),
        module: module2,
        level,
        messages
      });
    };
    return logger21;
  }, {});
}

// node_modules/@snap/camera-kit/lib/handlers/retryingHandler.js
var logger = getLogger("retryingHandler");
var logRetry = (responseOrError, sleep3) => {
  logger.warn(`Retrying handler got failed response:`, responseOrError, `Waited ${sleep3} millis, attempting retry now.`);
};
var sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var randomInRange = (min2, max2) => Math.round(Math.random() * (max2 - min2) + min2);
var defaultOptions = {
  backoffMultiple: 3,
  baseSleep: 500,
  maxSleep: 5 * 1e3,
  maxRetries: 10,
  // The Response type is very common, so our default predicate special-cases to retry all failed Responses.
  retryPredicate: (responseOrError) => responseOrError instanceof Response ? !responseOrError.ok : true
};
function ensureClonedRequest(input) {
  return input instanceof Request ? input.clone() : input;
}
var createRetryingHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { backoffMultiple, baseSleep, maxSleep, maxRetries, retryPredicate } = Object.assign(Object.assign({}, defaultOptions), definedOptions);
  let retryCount = -1;
  const jitterSleep = (priorSleep) => __awaiter(void 0, void 0, void 0, function* () {
    const nextSleep = Math.min(maxSleep, randomInRange(baseSleep, priorSleep * backoffMultiple));
    yield sleep(nextSleep);
    return nextSleep;
  });
  const makeRequestAttempt = (next, priorSleep = baseSleep) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    retryCount++;
    try {
      const response = yield next(ensureClonedRequest(req), metadata);
      if (retryCount < maxRetries && retryPredicate(response, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.aborted)
          return response;
        logRetry(response, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      return response;
    } catch (error) {
      if (!(error instanceof Error)) {
        throw new Error(`Invalid type caught by retrying handler. Handlers may only throw Errors. Got ${JSON.stringify(error)}`);
      }
      if (error.name === "AbortError")
        throw error;
      if (retryCount < maxRetries && retryPredicate(error, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _b === void 0 ? void 0 : _b.aborted)
          throw error;
        logRetry(error, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      throw error;
    }
  });
  return (next) => makeRequestAttempt(next);
};

// node_modules/@snap/camera-kit/lib/handlers/noCorsRetryingFetchHandler.js
var logger2 = getLogger("noCorsRetryingFetchHandler");
var logRetry2 = (error) => {
  logger2.warn(`NoCorsRetrying handler got failed response:`, error, `Retrying request with {mode: "no-cors"}.`);
};
var createNoCorsRetryingFetchHandler = () => {
  const noCorsRequests = /* @__PURE__ */ new Map();
  return (next) => (input, init = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let requestKey = typeof input === "string" ? input : input.url;
    try {
      requestKey = new URL(requestKey, location.origin).host;
    } catch (_) {
    }
    try {
      return yield next(ensureClonedRequest(input), init);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError")
        throw error;
      logRetry2(error);
      const noCorsRequest = (_a = noCorsRequests.get(requestKey)) !== null && _a !== void 0 ? _a : next(ensureClonedRequest(input), Object.assign(Object.assign({}, init), { mode: "no-cors" }));
      noCorsRequests.set(requestKey, noCorsRequest);
      yield noCorsRequest;
      noCorsRequests.delete(requestKey);
      return next(ensureClonedRequest(input), init);
    }
  });
};

// node_modules/@snap/camera-kit/lib/handlers/timeoutHandler.js
var sleep2 = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var defaultOptions2 = {
  createError: (request) => {
    const destination = isString(request) ? `for ${request}` : request instanceof Request ? `for ${request.url}` : "";
    return new Error(`Request ${destination} timed out by client timeout handler.`);
  },
  timeout: 30 * 1e3
};
var createTimeoutHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { createError, timeout: timeout2 } = Object.assign(Object.assign({}, defaultOptions2), definedOptions);
  return (next) => (req, meta) => Promise.race([next(req, meta), sleep2(timeout2).then(() => Promise.reject(createError(req, meta)))]);
};

// node_modules/@snap/camera-kit/lib/handlers/defaultFetchHandler.js
var defaultFetchHandlerFactory = Injectable("defaultFetchHandler", () => {
  return (
    // Safety: We're re-typing fetch's second argument from `init?: RequestInit | undefined` to
    // `init: RequestInit | void`  this is semantically equivalent, but the void makes for nicer ergonomics
    // elsewhere (e.g. so that callers can omit the second argument instead of being forced to pass undefined).
    new HandlerChainBuilder(fetch).map(createDebugHandler()).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createNoCorsRetryingFetchHandler()).map(createRetryingHandler({
      maxRetries: 3,
      retryPredicate: (responseOrError) => {
        if (responseOrError instanceof Response) {
          if (responseOrError.ok)
            return false;
          if (responseOrError.status % 400 < 100)
            return false;
        }
        return true;
      }
    })).handler
  );
});

// node_modules/wasm-feature-detect/dist/esm/index.js
var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

// node_modules/@snap/camera-kit/lib/common/memoize.js
function isMemoized(fn) {
  return typeof fn === "function" && typeof fn.delegate === "function";
}
function memoize(delegate) {
  let memo;
  const memoized = (...args) => {
    if (typeof memo !== "undefined")
      return memo;
    memo = delegate(...args);
    return memo;
  };
  memoized.delegate = delegate;
  return memoized;
}

// node_modules/@snap/camera-kit/lib/namedErrors.js
function cleanErrorStack(stack) {
  const [first2, _, ...rest] = stack.split("\n");
  return [first2, ...rest].join("\n");
}
function namedError(name) {
  return (message, cause) => {
    const error = new Error(message, { cause });
    error.name = name;
    error.stack = error.stack && cleanErrorStack(error.stack);
    return error;
  };
}
var legalError = namedError("LegalError");
var lensContentValidationError = namedError("LensContentValidationError");
var lensError = namedError("LensError");
var cameraKitSourceError = namedError("CameraKitSourceError");
var lensImagePickerError = namedError("LensImagePickerError");
var cacheKeyNotFoundError = namedError("CacheKeyNotFoundError");
var configurationError = namedError("ConfigurationError");
var webGLError = namedError("WebGLError");
var benchmarkError = namedError("BenchmarkError");
var platformNotSupportedError = namedError("PlatformNotSupportedError");
var lensExecutionError = namedError("LensExecutionError");
var lensAbortError = namedError("LensAbortError");
var persistentStoreError = namedError("PersistentStoreError");
var lensAssetError = namedError("LensAssetError");
var bootstrapError = namedError("BootstrapError");

// node_modules/@snap/camera-kit/lib/platform/platformInfo.js
function isNavigatorUAData(value) {
  return isRecord(value) && Array.isArray(value["brands"]) && value["brands"].every((brand) => {
    return isRecord(brand) && typeof brand["brand"] === "string" && typeof brand["version"] === "string";
  }) && typeof value["mobile"] === "boolean" && typeof value["platform"] === "string";
}
function parseDeviceModel(userAgent) {
  const userAgentWithModel = userAgent.match(/;[^;]+?;([^\)]+?)\)/);
  if (userAgentWithModel) {
    return userAgentWithModel[1].trim();
  }
  const userAgentWithModel2 = userAgent.match(/\(([^;]+);/);
  if (userAgentWithModel2) {
    return userAgentWithModel2[1].trim();
  }
  return "unknown";
}
function parseOrigin() {
  var _a, _b, _c;
  if (location.hostname !== "")
    return location.hostname;
  const possibleOrigins = location.ancestorOrigins === void 0 && typeof window !== "undefined" ? [window.parent.origin, (_b = (_a = window.top) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : ""] : (_c = location.ancestorOrigins) !== null && _c !== void 0 ? _c : [];
  for (let origin of possibleOrigins) {
    try {
      origin = new URL(origin).hostname;
      if (origin)
        return origin;
    } catch (_) {
    }
  }
  return "unknown";
}
function parseOSName(userAgent) {
  const knownPlatforms = /* @__PURE__ */ new Map([
    ["android", "android"],
    ["linux", "linux"],
    ["iphone os", "ios"],
    ["ipad", "ipados"],
    ["mac os", "macos"],
    ["macos", "macos"],
    ["windows", "windows"]
  ]);
  const normalizedUserAgent = userAgent.toLowerCase();
  for (const [match, platform] of knownPlatforms.entries()) {
    if (normalizedUserAgent.includes(match))
      return platform;
  }
  return "unknown";
}
function parseOSVersion(userAgent) {
  const versionMatch = userAgent.match(/\s([\d][\d_.]*[\d])(;|\)|\s)/);
  if (versionMatch != null) {
    return versionMatch[1].replace(/_/g, ".");
  }
  return "";
}
function parseUserAgentData(userAgent) {
  let brand;
  if (/Chrome/.test(userAgent)) {
    const versionMatch = userAgent.match(/Chrome\/([\d.]+)/);
    brand = {
      brand: "Chrome",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else if (/Safari/.test(userAgent)) {
    let versionMatch = userAgent.match(/Version\/([\d.]+)/);
    if (versionMatch === null)
      versionMatch = userAgent.match(/Safari\/([\d.]+)/);
    brand = {
      brand: "Safari",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else {
    brand = {
      brand: "Firefox",
      version: "0"
    };
  }
  const mobile = false;
  const platform = parseOSName(userAgent);
  return {
    brands: [brand],
    mobile,
    platform
  };
}
function normalizeBrands(brands) {
  const knownBrands = /* @__PURE__ */ new Map([
    ["Google Chrome", "Chrome"],
    ["Chrome", "Chrome"],
    ["Chromium", "Chrome"],
    ["Firefox", "Firefox"],
    ["Microsoft Edge", "Chrome"],
    ["Safari", "Safari"]
  ]);
  const normalizedBrands = brands.filter(({ brand }) => knownBrands.has(brand)).map((brand) => {
    return {
      // Safety: we've filtered out brands which do not appear as keys in `knownBrands`, so this cannot return
      // undefined.
      brand: knownBrands.get(brand.brand),
      version: brand.version
    };
  });
  if (normalizedBrands.length === 0)
    return [{ brand: "Firefox", version: "0" }];
  return normalizedBrands;
}
function normalizeUserAgentData(userAgentData) {
  return {
    brands: normalizeBrands(userAgentData.brands),
    mobile: userAgentData.mobile,
    platform: parseOSName(userAgentData.platform)
  };
}
var getPlatformInfo = memoize(function getPlatformIno() {
  var _a, _b, _c;
  const userAgent = navigator.userAgent;
  const userAgentData = isNavigatorUAData(navigator.userAgentData) ? normalizeUserAgentData(navigator.userAgentData) : parseUserAgentData(userAgent);
  const osVersion = parseOSVersion(userAgent);
  const deviceModel = parseDeviceModel(userAgent);
  const sdkShortVersion = environment_default.PACKAGE_VERSION.replace(/[-+]\S+$/, "");
  const locale = navigator.language;
  const fullLocale = ((_a = navigator.languages) !== null && _a !== void 0 ? _a : []).map((lang, index) => {
    const qvalue = Math.max(0, (10 - index) / 10);
    return `${lang};q=${qvalue.toFixed(1)}`;
  }).join(", ") || locale;
  return {
    sdkShortVersion,
    sdkLongVersion: environment_default.PACKAGE_VERSION,
    lensCore: lensCoreWasmVersions_default,
    // In cases where we've parsed the userAgent string to find the brand, there will only ever be a single brand 
    // in browsers which support NavigatorUAData there could be more than one (e.g. Chrome and Chromium), but they
    // should be equivalent for our purposes -- either way we're okay just picking the first one.
    browser: userAgentData.brands[0],
    osName: userAgentData.platform,
    osVersion,
    deviceModel,
    locale,
    fullLocale,
    origin: parseOrigin(),
    connectionType: (_c = (_b = navigator.connection) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : "unknown"
  };
});

// node_modules/@snap/camera-kit/lib/platform/platformCapabilities.js
var minRequiredMaxTextureSize = 1024;
function getWebGlSupport() {
  const ctx = document.createElement("canvas").getContext("webgl2");
  if (!ctx)
    return {
      supported: false,
      error: platformNotSupportedError("CameraKit requires WebGL2, but this browser does not support WebGL2.")
    };
  const maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
  const supported = maxTextureSize >= minRequiredMaxTextureSize;
  return supported ? { supported, maxTextureSize } : {
    supported,
    error: platformNotSupportedError(`CameraKit requires WebGL's MAX_TEXTURE_SIZE exceed a minimum value of ${minRequiredMaxTextureSize}, but the browser's reported MAX_TEXTURE_SIZE is ${maxTextureSize}.`)
  };
}
var WasmFeatures;
(function(WasmFeatures2) {
  WasmFeatures2[WasmFeatures2["Default"] = 0] = "Default";
  WasmFeatures2[WasmFeatures2["SIMD"] = 1] = "SIMD";
  WasmFeatures2[WasmFeatures2["ExceptionHandling"] = 2] = "ExceptionHandling";
})(WasmFeatures || (WasmFeatures = {}));
function getWebAssemblyCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    if (globalThis.WebAssembly === void 0)
      return {
        supported: false,
        error: platformNotSupportedError("CameraKit requires WebAssembly, but this browser does not support WebAssembly.")
      };
    return {
      supported: true,
      wasmFeatures: (yield Promise.all([
        simd().then((supported) => {
          if (getPlatformInfo().browser.brand === "Safari")
            return WasmFeatures.Default;
          return supported ? WasmFeatures.SIMD : WasmFeatures.Default;
        }),
        exceptions().then((supported) => supported ? WasmFeatures.ExceptionHandling : WasmFeatures.Default)
      ])).reduce((features, feature) => features | feature, WasmFeatures.Default)
    };
  });
}
function getWebXrCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    const notSupported = {
      supported: false,
      error: platformNotSupportedError(`Use of this feature requires WebXR support for immersive AR sessions, but this browser does not support immersive AR sessions.`)
    };
    if (!isSecureContext)
      return notSupported;
    if (!navigator.xr)
      return notSupported;
    const isImmersiveArSupported = yield navigator.xr.isSessionSupported("immersive-ar");
    return isImmersiveArSupported ? {
      supported: true,
      sixDofSupported: true,
      sceneDepthSupported: true
    } : notSupported;
  });
}
var getPlatformCapabilities = memoize(function getPlatformCapabilities2() {
  return __awaiter(this, void 0, void 0, function* () {
    return {
      webgl: getWebGlSupport(),
      wasm: yield getWebAssemblyCapabilities(),
      webxr: yield getWebXrCapabilities()
    };
  });
});

// node_modules/@snap/camera-kit/lib/lens-core-module/lensCoreError.js
var lensCoreErrorValue = {
  LensDeserialization: 0,
  Validation: 1,
  Uncategorized: 2,
  LensExecution: 3,
  Abort: 4,
  Uninitialized: 5
};
var lensCoreErrorName = Object.fromEntries(Object.entries(lensCoreErrorValue).map((entry) => [entry[1], entry[0]]));
function wrapLensCoreError(fn) {
  const handler = (cause) => {
    var _a;
    const error = new Error(cause.message.split("\n")[0], {
      cause: cause.otherExceptions || ((_a = cause.cause) === null || _a === void 0 ? void 0 : _a.metadata) ? {
        otherExceptions: cause.otherExceptions,
        metadata: cause.cause.metadata
      } : void 0
    });
    const name = `LensCore${cause.cause ? lensCoreErrorName[cause.cause.type.value] : "Unknown"}Error`;
    error.name = name;
    if (cause.stack) {
      const [_, ...stackLines] = cause.stack.split("\n");
      if (error.stack) {
        stackLines.unshift(error.stack.split("\n")[0]);
      }
      error.stack = stackLines.join("\n");
    }
    fn(error);
  };
  return handler;
}

// node_modules/@snap/camera-kit/lib/lens-core-module/lensCore.js
var promisifiableMethods = {
  addLens: null,
  clearAllLenses: null,
  imageToYuvBuffer: null,
  pauseCanvas: null,
  playCanvas: null,
  processAudioSampleBuffer: null,
  processFrame: null,
  removeLens: null,
  replaceLenses: null,
  setAudioParameters: null,
  setDeviceClass: null,
  setFPSLimit: null,
  setInputTransform: null,
  setOnFrameProcessedCallback: null,
  setRenderLoopMode: null,
  setRenderSize: null,
  teardown: null,
  useMediaElement: null,
  yuvBufferToBitmap: null
};
var createLensCore = (lensCoreModule) => {
  const customMethods = {
    initialize(input) {
      return new Promise((onSuccess, onFailure) => lensCoreModule.initialize(Object.assign(Object.assign({}, input), { exceptionHandler: input.exceptionHandler && wrapLensCoreError(input.exceptionHandler), onSuccess, onFailure: wrapLensCoreError(onFailure) })));
    },
    provideRemoteAssetsResponse(input) {
      return lensCoreModule.provideRemoteAssetsResponse(Object.assign(Object.assign({}, input), { onFailure: input.onFailure && wrapLensCoreError(input.onFailure) }));
    }
  };
  return new Proxy(lensCoreModule, {
    get: (target, property, receiver) => {
      if (property in customMethods) {
        return customMethods[property];
      }
      if (property in promisifiableMethods) {
        const method = Reflect.get(target, property, receiver);
        if (!method)
          method;
        return (input) => new Promise((onSuccess, onFailure) => method(Object.assign(Object.assign({}, input), { onSuccess, onFailure: wrapLensCoreError(onFailure) })));
      }
      return Reflect.get(target, property, receiver);
    }
    // Safety: We ensured safety by defining types for both custom and promisifiable methods.
  });
};

// node_modules/@snap/camera-kit/lib/lens-core-module/loader/lensCoreFactory.js
var logger3 = getLogger("lensCoreFactory");
var wasmAssets = ["LensCoreWebAssembly.js", "LensCoreWebAssembly.wasm"];
var findMatch = (regex, strings) => strings.find((s2) => regex.test(s2));
var wasmCapabilitiesToLensCoreBuildFlavor = {
  [WasmFeatures.Default]: "release",
  [WasmFeatures.ExceptionHandling]: "rel-neh",
  [WasmFeatures.SIMD]: "release-simd",
  [WasmFeatures.ExceptionHandling | WasmFeatures.SIMD]: "rel-simd-neh"
};
function getRequiredBootstrapURLs(endpointOverride) {
  return __awaiter(this, void 0, void 0, function* () {
    const endpoint = endpointOverride === null || endpointOverride === void 0 ? void 0 : endpointOverride.replace(/[\/]+$/, "");
    const { wasm } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    const { lensCore } = getPlatformInfo();
    const flavor = wasmCapabilitiesToLensCoreBuildFlavor[wasm.wasmFeatures];
    if (!flavor)
      throw new Error(`Could not determine a LensCore build flavor corresponding to the bitstring ${wasm.wasmFeatures.toString(2)}. CameraKit cannot be bootstrapped.`);
    const version = lensCore.version;
    const buildNumber = lensCore.buildNumber;
    return wasmAssets.map((asset) => {
      if (endpoint)
        return `${endpoint}/${asset}`;
      const { origin, pathname, search } = new URL(lensCore.baseUrl);
      return `${origin}${pathname}/${version}/${buildNumber}/${flavor}/${asset}${search}`;
    });
  });
}
var lensCoreFactory = Injectable("lensCore", [defaultFetchHandlerFactory.token, configurationToken], (handler, { lensCoreOverrideUrls, wasmEndpointOverride }) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  let lensCoreJS;
  let lensCoreWASM;
  if (lensCoreOverrideUrls) {
    lensCoreJS = lensCoreOverrideUrls.js;
    lensCoreWASM = lensCoreOverrideUrls.wasm;
  } else {
    const endpointOverride = wasmEndpointOverride !== null && wasmEndpointOverride !== void 0 ? wasmEndpointOverride : void 0;
    const assetURLs = yield getRequiredBootstrapURLs(endpointOverride);
    lensCoreJS = (_a = findMatch(/\.js/, assetURLs)) !== null && _a !== void 0 ? _a : "";
    lensCoreWASM = (_b = findMatch(/\.wasm/, assetURLs)) !== null && _b !== void 0 ? _b : "";
    if (!lensCoreJS || !lensCoreWASM) {
      throw new Error(`Cannot fetch required LensCore assets. Either the JS or WASM filename is missing from this list: ${assetURLs}.`);
    }
    const glueScript = yield handler(lensCoreJS).then((r2) => r2.blob());
    lensCoreJS = URL.createObjectURL(glueScript);
  }
  const scriptElement = yield loadScript(lensCoreJS);
  const lensCore = yield new Promise((resolve, reject) => {
    let initialModule;
    const moduleInit = globalThis.createLensesModule(initialModule = {
      // url will be used for loading glue JS during Worker inialization
      mainScriptUrlOrBlob: lensCoreJS,
      // will be triggered by Emscripten during the initialization
      instantiateWasm: (importObject, receiveInstance) => {
        WebAssembly.instantiateStreaming(handler(lensCoreWASM), importObject).then(function({ instance, module: module2 }) {
          receiveInstance(instance, module2);
          initialModule.compiledModule = module2;
          resolve(moduleInit);
        }).catch(reject);
      }
    });
  });
  scriptElement.remove();
  if (lensCoreWasmVersions_default.version != `${lensCore.getCoreVersion()}`) {
    logger3.warn(`Loaded LensCore version (${lensCore.getCoreVersion()}) differs from expected one (${lensCoreWasmVersions_default.version})`);
  }
  return createLensCore(lensCore);
}));

// node_modules/@snap/camera-kit/lib/benchmark/webglUtils.js
var webGLEntityCreationError = (name) => webGLError(`Could not create ${name}.`);
function createProgram(gl, vertexSource2, fragmentSource2) {
  const vertexShader = createShader(gl, vertexSource2, gl.VERTEX_SHADER);
  const fragmentShader = createShader(gl, fragmentSource2, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  if (!program)
    throw webGLEntityCreationError("WebGLProgram");
  gl.attachShader(program, vertexShader);
  gl.deleteShader(vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.deleteShader(fragmentShader);
  gl.linkProgram(program);
  const success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!success) {
    const message = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    throw webGLError(`WebGLProgram linking failed with status: ${message}.`);
  }
  return program;
}
function createShader(gl, source, type) {
  const shader = gl.createShader(type);
  if (!shader)
    throw webGLEntityCreationError(`WebGLShader (type ${type})`);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!success) {
    const message = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw webGLError(`WebGLShader (type ${type}) compilation failed with status: ${message}.`);
  }
  return shader;
}
function createTexture(gl, width2, height2) {
  const texture = gl.createTexture();
  if (!texture)
    throw webGLEntityCreationError("WebGLTexture");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width2, height2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
}
function createFramebuffer(gl, texture) {
  const framebuffer = gl.createFramebuffer();
  if (!framebuffer)
    throw webGLEntityCreationError("WebGLFramebuffer");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  return framebuffer;
}
function setUniform1i(gl, program, name, data) {
  gl.uniform1i(gl.getUniformLocation(program, name), data);
}
function setUniform4f(gl, program, name, data) {
  gl.uniform4f(gl.getUniformLocation(program, name), ...data);
}
function promiseSync(gl) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  if (!sync)
    throw webGLEntityCreationError("WebGLSync");
  gl.flush();
  return new Promise((resolve, reject) => {
    const waitForSync = () => {
      const glEnum = gl.clientWaitSync(sync, 0, 0);
      switch (glEnum) {
        case gl.TIMEOUT_EXPIRED:
          setTimeout(waitForSync);
          return;
        case gl.WAIT_FAILED:
          gl.deleteSync(sync);
          return reject();
        case gl.ALREADY_SIGNALED:
        case gl.CONDITION_SATISFIED:
          gl.deleteSync(sync);
          return resolve();
      }
    };
    waitForSync();
  });
}

// node_modules/@snap/camera-kit/lib/benchmark/benchmarkGflops.js
var vertexSource = `#version 300 es

precision mediump float;
precision mediump int;

in vec2 pos;

void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;
var fragmentSource = `#version 300 es

precision mediump float;
precision mediump int;

uniform int LOOP_COUNT;
uniform vec4 v0;
uniform vec4 v1;
uniform vec4 v2;

out vec4 fragColor;

#define REPEAT_2(x) x; x
#define REPEAT_4(x) REPEAT_2(x); REPEAT_2(x)
#define REPEAT_8(x) REPEAT_4(x); REPEAT_4(x)
#define REPEAT_16(x) REPEAT_8(x); REPEAT_8(x)
#define REPEAT_32(x) REPEAT_16(x); REPEAT_16(x)

void main() {
    vec4 r = v2;
    for (int i = 0; i < LOOP_COUNT; i++) {
        REPEAT_32(r = r * v1 + v0);
    }
    fragColor = r;
}
`;
var width = 1024;
var height = 1024;
var budgetMs = 300;
var maxLoopCount = 1e3;
function prepareBenchmark(gl) {
  const texture = createTexture(gl, width, height);
  const framebuffer = createFramebuffer(gl, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  const buffer2 = gl.createBuffer();
  if (!buffer2) {
    throw new Error("Failed to create WebGLBuffer.");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  gl.viewport(0, 0, width, height);
  gl.disable(gl.CULL_FACE);
  gl.disable(gl.DEPTH_TEST);
  const program = createProgram(gl, vertexSource, fragmentSource);
  gl.useProgram(program);
  const posLocation = gl.getAttribLocation(program, "pos");
  gl.enableVertexAttribArray(posLocation);
  gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
  setUniform4f(gl, program, "v0", [1.15, 1.23, 1.47, 1.84]);
  setUniform4f(gl, program, "v1", [1.65, 1.22, 1.69, 1.04]);
  setUniform4f(gl, program, "v2", [1.05, 1.3, 1.55, 1.23]);
  return {
    program,
    cleanupBenchmark: () => {
      gl.deleteProgram(program);
      gl.deleteBuffer(buffer2);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
    }
  };
}
function runBenchmark(gl, program) {
  return __awaiter(this, void 0, void 0, function* () {
    yield promiseSync(gl);
    const start = performance.now();
    const flops = [];
    let loopCount = 20;
    while (true) {
      setUniform1i(gl, program, "LOOP_COUNT", loopCount);
      const iterationStart = performance.now();
      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      yield promiseSync(gl);
      const iterationEnd = performance.now();
      const duration = iterationEnd - iterationStart;
      flops.push(loopCount / duration);
      const remainingBudgetMs = budgetMs - (iterationEnd - start);
      if (remainingBudgetMs < 0)
        break;
      if (loopCount < maxLoopCount) {
        loopCount += remainingBudgetMs < duration ? 10 : 0.6 * loopCount * remainingBudgetMs / duration;
      }
    }
    const maxFlops = Math.max(...flops) * (8 * 32) * width * height;
    return maxFlops / 1e6;
  });
}
var gflopsClusterCenters = /* @__PURE__ */ new Map([
  [34, 1],
  [134, 2],
  [385, 3],
  [783, 4],
  [1484, 5],
  [2313, 6]
]);
function benchmarkGflops(gl) {
  return __awaiter(this, void 0, void 0, function* () {
    const { program, cleanupBenchmark } = prepareBenchmark(gl);
    const gflops = yield runBenchmark(gl, program);
    cleanupBenchmark();
    return { name: "gflops", value: gflops };
  });
}

// node_modules/@snap/camera-kit/lib/benchmark/estimateLensPerformanceCluster.js
var findNearest = (n2, arr) => arr.reduce((a2, b2) => Math.abs(a2 - n2) <= Math.abs(b2 - n2) ? a2 : b2);
var webglContextAttributes = {
  alpha: false,
  antialias: false,
  premultipliedAlpha: false,
  preserveDrawingBuffer: false,
  depth: false,
  stencil: false,
  failIfMajorPerformanceCaveat: false,
  powerPreference: "high-performance"
};
function estimateLensPerformance() {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2", webglContextAttributes);
    if (!gl)
      throw benchmarkError("WebGL2 is required to compute performance, but it is not supported.");
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const webglRendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
    const gflops = yield benchmarkGflops(gl);
    const nearestGflopsClusterCenter = findNearest(gflops.value, Array.from(gflopsClusterCenters.keys()));
    const gflopsCluster = (_a = gflopsClusterCenters.get(nearestGflopsClusterCenter)) !== null && _a !== void 0 ? _a : 0;
    return {
      cluster: gflopsCluster,
      benchmarks: [gflops],
      webglRendererInfo
    };
  });
}

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env"] && process["env"]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P2, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P2);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P2, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P2);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P2);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P2);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P2);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P2);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        true
      );
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P2) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P2);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P2);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P2) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator2 = GetIterator(keysObj);
      var k2 = 0;
      while (true) {
        var next = IteratorStep(iterator2);
        if (!next) {
          keys.length = k2;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k2] = nextValue;
        } catch (e2) {
          try {
            IteratorClose(iterator2);
          } finally {
            throw e2;
          }
        }
        k2++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P2) {
      var func = V[P2];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator2 = method.call(obj);
      if (!IsObject(iterator2))
        throw new TypeError();
      return iterator2;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator2) {
      var result = iterator2.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator2) {
      var f3 = iterator2["return"];
      if (f3)
        f3.call(iterator2);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      return (
        /** @class */
        function() {
          function Map2() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map2.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map2.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map2.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map2.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map2.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map2.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map2.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map2.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map2.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map2.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map2.prototype._find = function(key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map2;
        }()
      );
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        function() {
          function Set2() {
            this._map = new _Map();
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set2.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set2.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set2.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set2.prototype.clear = function() {
            this._map.clear();
          };
          Set2.prototype.keys = function() {
            return this._map.keys();
          };
          Set2.prototype.values = function() {
            return this._map.values();
          };
          Set2.prototype.entries = function() {
            return this._map.entries();
          };
          Set2.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set2.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set2;
        }()
      );
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer2, size) {
        for (var i = 0; i < size; ++i)
          buffer2[i] = Math.random() * 255 | 0;
        return buffer2;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@snap/camera-kit/lib/common/validate.js
var predicateMetadataKey = Symbol("validate");
var primitiveMap = {
  string: String,
  number: Number,
  boolean: Boolean
};
var ordinalSuffixMap = {
  1: "st",
  2: "nd",
  3: "rd"
};
function getArgumentInfo(target, methodName, argumentIndex, arg) {
  var _a;
  let argString;
  try {
    argString = JSON.stringify(arg);
  } catch (_b) {
    argString = String(arg);
  }
  return {
    argPosition: `${argumentIndex + 1}${(_a = ordinalSuffixMap[argumentIndex + 1]) !== null && _a !== void 0 ? _a : "th"}`,
    methodPath: `${getTypeName(target)}.${String(methodName)}()`,
    argTypeName: getTypeName(arg),
    argString
  };
}
function guard(predicate) {
  return (target, propertyKey, parameterIndex) => {
    let existingPredicates = Reflect.getOwnMetadata(predicateMetadataKey, target, propertyKey) || [];
    existingPredicates[parameterIndex] = predicate;
    Reflect.defineMetadata(predicateMetadataKey, existingPredicates, target, propertyKey);
  };
}
function validate(target, key, descriptor) {
  const method = descriptor.value;
  const types = Reflect.getMetadata("design:paramtypes", target, key);
  const predicates = Reflect.getMetadata(predicateMetadataKey, target, key);
  descriptor.value = function(...args) {
    for (const [i, type] of types.entries()) {
      let arg = Array.isArray(args) && args[i];
      if (!!predicates && predicates[i] && !predicates[i](arg)) {
        const { methodPath, argPosition, argString } = getArgumentInfo(target, key, i, arg);
        throw new Error(`The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`);
      }
      if (arg === void 0 || arg === null) {
        break;
      }
      if (!isValueOfType(arg, type)) {
        const { methodPath, argPosition, argTypeName } = getArgumentInfo(target, key, i, arg);
        throw new Error(`The ${argPosition} argument to ${methodPath} method is of type ${argTypeName}, which is not assignable to parameter of type ${type.name}.`);
      }
    }
    return method.apply(this, arguments);
  };
}
function isValueOfType(value, type) {
  if (value instanceof type) {
    return true;
  }
  const isPrimitive = value !== Object(value);
  return isPrimitive && primitiveMap[typeof value] === type;
}
function getTypeName(value) {
  if (value === null) {
    return "null";
  }
  const baseType = typeof value;
  if (!["object", "function"].includes(baseType)) {
    return baseType;
  }
  const nonNullValue = value;
  const tag = nonNullValue[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }
  if (baseType === "function" && Function.prototype.toString.call(nonNullValue).startsWith("class")) {
    return "class";
  }
  const className = nonNullValue.constructor.name;
  if (typeof className === "string" && className !== "") {
    return className;
  }
  return baseType;
}

// node_modules/@snap/camera-kit/lib/platform/cameraKitUserAgent.js
var getCameraKitUserAgent = memoize(function getCameraKitUserAgent2() {
  var _a;
  const { browser, deviceModel, origin, osName, osVersion, sdkShortVersion, lensCore } = getPlatformInfo();
  const { userAgentFlavor } = (_a = getConfigurationOverrides()) !== null && _a !== void 0 ? _a : { userAgentFlavor: "release" };
  const flavor = userAgentFlavor === "release" ? "" : "DEBUG ";
  return `CameraKitWeb/${sdkShortVersion} ${flavor}(${deviceModel}; ${osName} ${osVersion}) ${browser.brand}/${browser.version} Core/${lensCore.version} AppId/${origin}`;
});

// node_modules/@snap/camera-kit/lib/handlers/headersModifyingFetchHandler.js
var createHeadersModifyingFetchHandler = (modifyHeaders) => (next) => (input, init) => {
  const headers = init && init.headers ? new Headers(init.headers) : typeof input === "string" ? new Headers() : input.headers;
  const modifiedHeaders = modifyHeaders(headers);
  return next(input, Object.assign(Object.assign({}, init), { headers: modifiedHeaders }));
};

// node_modules/@snap/camera-kit/lib/handlers/cameraKitServiceFetchHandlerFactory.js
var cameraKitServiceFetchHandlerFactory = Injectable("cameraKitServiceFetchHandler", [configurationToken, defaultFetchHandlerFactory.token], ({ apiToken }, defaultFetchHandler) => {
  return new HandlerChainBuilder(defaultFetchHandler).map(createHeadersModifyingFetchHandler((headers) => {
    headers.append("x-snap-client-user-agent", getCameraKitUserAgent());
    headers.append("authorization", `Bearer ${apiToken}`);
    return headers;
  })).handler;
});

// node_modules/@snap/camera-kit/lib/extensions/LensSources.js
var LensSources = class _LensSources {
  /**
   * Returns empty LensSources instance.
   * @internal
   */
  static empty() {
    return new _LensSources();
  }
  /**
   * Creates an instance of Lens sources.
   * @param fallbackSources A fallback sources if given {@link LensSource} doesn't claim a group ownership.
   * @param source Lens source.
   */
  constructor(fallbackSources, source) {
    this.fallbackSources = fallbackSources;
    this.source = source;
  }
  /**
   * Returns envelopes of lens/groups taking into account group ownership.
   * @internal
   * @param groupId A group to test ownership and get lens envelopes of.
   * @param lensId An optional lens ID to narrow envelopes down to a single lens.
   * @returns Envelopes or undefined if not applicable.
   */
  retrieveLenses({ groupId, lensId }) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      if ((_a = this.source) === null || _a === void 0 ? void 0 : _a.isGroupOwner(groupId)) {
        if (isUndefined(lensId)) {
          if (this.source.getLensGroup)
            return this.source.getLensGroup(groupId);
        } else if (this.source.getLens) {
          return this.source.getLens(lensId, groupId).then((envelope) => [envelope]);
        }
      }
      return (_b = this.fallbackSources) === null || _b === void 0 ? void 0 : _b.retrieveLenses({ groupId, lensId });
    });
  }
};
var lensSourcesFactory = Injectable("lensSources", () => LensSources.empty());

// node_modules/@snap/camera-kit/lib/common/errorHelpers.js
function stringifyError(error) {
  var _a;
  const outer = (_a = error.stack) !== null && _a !== void 0 ? _a : "";
  return error.cause ? `${outer}
Caused by:
	${stringifyError(ensureError(error.cause))}` : outer;
}
function ensureError(error) {
  if (error instanceof Error)
    return error;
  try {
    return new Error(`Non-Error type exception thrown. Serialized error value: ${JSON.stringify(error)}`);
  } catch (_) {
    return new Error("Non-Error type exception thrown. Original error value could not be serialized.");
  }
}

// node_modules/@snap/camera-kit/lib/common/time.js
var getTimeMs = () => performance.now();
var convertDaysToSeconds = (days) => days * 24 * 60 * 60;

// node_modules/@snap/camera-kit/lib/events/TypedCustomEvent.js
var TypedCustomEvent = class extends CustomEvent {
  constructor(type, detail, eventInitDict = {}) {
    super(type, Object.assign(Object.assign({}, eventInitDict), { detail }));
  }
};

// node_modules/@snap/camera-kit/lib/events/TypedEventTarget.js
var TypedEventTarget = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.options = /* @__PURE__ */ new Map();
  }
  addEventListener(type, callback, options) {
    var _a;
    const listener = callback;
    const listeners = (_a = this.listeners.get(type)) !== null && _a !== void 0 ? _a : [];
    this.listeners.set(type, [...listeners, listener]);
    if (options)
      this.options.set(listener, options);
  }
  dispatchEvent(event) {
    const listeners = this.listeners.get(event.type);
    if (!listeners)
      return true;
    listeners.forEach((listener) => {
      var _a;
      const options = (_a = this.options.get(listener)) !== null && _a !== void 0 ? _a : {};
      try {
        listener(event);
      } catch (error) {
        if (window)
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
      if (options.once)
        this.removeEventListener(event.type, listener);
    });
    return true;
  }
  removeEventListener(type, callback) {
    const listener = callback;
    const listeners = this.listeners.get(type);
    if (!listeners)
      return;
    this.listeners.set(type, listeners.filter((l2) => l2 !== listener));
    this.options.delete(listener);
  }
};

// node_modules/@snap/camera-kit/lib/handlers/requestStateEmittingHandler.js
var requestId = 0;
var safeParseInt = (str) => {
  if (str == null)
    return 0;
  const maybeInt = parseInt(str);
  return isNaN(maybeInt) ? 0 : maybeInt;
};
var dispatchRequestStarted = (requestStateEventTarget, data) => {
  const started = Object.assign(Object.assign({}, data), { requestId: requestId++, timeMs: getTimeMs() });
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("started", started));
  return started;
};
var dispatchRequestCompleted = (requestStateEventTarget, data) => {
  const completed = Object.assign(Object.assign({}, data), { timeMs: getTimeMs() });
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("completed", completed));
  return completed;
};
var dispatchRequestErrored = (requestStateEventTarget, data) => {
  const errored = Object.assign(Object.assign({}, data), { timeMs: getTimeMs() });
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("errored", errored));
  return errored;
};
var createRequestStateEmittingHandler = (requestStateEventTarget) => (next) => ([request, dimensions], metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
  try {
    const response = yield next(request, metadata);
    const status = response.status;
    const sizeByte = safeParseInt(response.headers.get("content-length"));
    dispatchRequestCompleted(requestStateEventTarget, { requestId: requestId2, dimensions, status, sizeByte });
    return response;
  } catch (error) {
    dispatchRequestErrored(requestStateEventTarget, { requestId: requestId2, dimensions, error: ensureError(error) });
    throw error;
  }
});
var requestStateEventTargetFactory = Injectable("requestStateEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/lib/handlers/arrayBufferParsingHandler.js
var createArrayBufferParsingHandler = () => (next) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const response = yield next(req, metadata);
  let buffer2;
  try {
    buffer2 = yield response.arrayBuffer();
  } catch (_) {
    buffer2 = new ArrayBuffer(0);
  }
  return [buffer2, response];
});

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/lens.js
var import_long2 = __toESM(require_long());
var import_minimal2 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/google/protobuf/any.js
var import_long = __toESM(require_long());
var import_minimal = __toESM(require_minimal2());
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
var Any = {
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : new import_minimal.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.typeUrl = reader.string();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
    message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAny();
    message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
var globalThis2 = (() => {
  if (typeof globalThis2 !== "undefined")
    return globalThis2;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
  const bin = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}
if (import_minimal.default.util.Long !== import_long.default) {
  import_minimal.default.util.Long = import_long.default;
  import_minimal.default.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/lens.js
var Lens_CameraFacing;
(function(Lens_CameraFacing2) {
  Lens_CameraFacing2["CAMERA_FACING_UNSET"] = "CAMERA_FACING_UNSET";
  Lens_CameraFacing2["CAMERA_FACING_FRONT"] = "CAMERA_FACING_FRONT";
  Lens_CameraFacing2["CAMERA_FACING_BACK"] = "CAMERA_FACING_BACK";
  Lens_CameraFacing2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(Lens_CameraFacing || (Lens_CameraFacing = {}));
function lens_CameraFacingFromJSON(object) {
  switch (object) {
    case 0:
    case "CAMERA_FACING_UNSET":
      return Lens_CameraFacing.CAMERA_FACING_UNSET;
    case 1:
    case "CAMERA_FACING_FRONT":
      return Lens_CameraFacing.CAMERA_FACING_FRONT;
    case 2:
    case "CAMERA_FACING_BACK":
      return Lens_CameraFacing.CAMERA_FACING_BACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Lens_CameraFacing.UNRECOGNIZED;
  }
}
function lens_CameraFacingToJSON(object) {
  switch (object) {
    case Lens_CameraFacing.CAMERA_FACING_UNSET:
      return "CAMERA_FACING_UNSET";
    case Lens_CameraFacing.CAMERA_FACING_FRONT:
      return "CAMERA_FACING_FRONT";
    case Lens_CameraFacing.CAMERA_FACING_BACK:
      return "CAMERA_FACING_BACK";
    default:
      return "UNKNOWN";
  }
}
var LensAssetManifestItem_Type;
(function(LensAssetManifestItem_Type2) {
  LensAssetManifestItem_Type2["DEVICE_DEPENDENT_ASSET_UNSET"] = "DEVICE_DEPENDENT_ASSET_UNSET";
  LensAssetManifestItem_Type2["ASSET"] = "ASSET";
  LensAssetManifestItem_Type2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LensAssetManifestItem_Type || (LensAssetManifestItem_Type = {}));
function lensAssetManifestItem_TypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DEVICE_DEPENDENT_ASSET_UNSET":
      return LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET;
    case 1:
    case "ASSET":
      return LensAssetManifestItem_Type.ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LensAssetManifestItem_Type.UNRECOGNIZED;
  }
}
function lensAssetManifestItem_TypeToJSON(object) {
  switch (object) {
    case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:
      return "DEVICE_DEPENDENT_ASSET_UNSET";
    case LensAssetManifestItem_Type.ASSET:
      return "ASSET";
    default:
      return "UNKNOWN";
  }
}
var LensAssetManifestItem_RequestTiming;
(function(LensAssetManifestItem_RequestTiming2) {
  LensAssetManifestItem_RequestTiming2["PRELOAD_UNSET"] = "PRELOAD_UNSET";
  LensAssetManifestItem_RequestTiming2["ON_DEMAND"] = "ON_DEMAND";
  LensAssetManifestItem_RequestTiming2["REQUIRED"] = "REQUIRED";
  LensAssetManifestItem_RequestTiming2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LensAssetManifestItem_RequestTiming || (LensAssetManifestItem_RequestTiming = {}));
function lensAssetManifestItem_RequestTimingFromJSON(object) {
  switch (object) {
    case 0:
    case "PRELOAD_UNSET":
      return LensAssetManifestItem_RequestTiming.PRELOAD_UNSET;
    case 1:
    case "ON_DEMAND":
      return LensAssetManifestItem_RequestTiming.ON_DEMAND;
    case 2:
    case "REQUIRED":
      return LensAssetManifestItem_RequestTiming.REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LensAssetManifestItem_RequestTiming.UNRECOGNIZED;
  }
}
function lensAssetManifestItem_RequestTimingToJSON(object) {
  switch (object) {
    case LensAssetManifestItem_RequestTiming.PRELOAD_UNSET:
      return "PRELOAD_UNSET";
    case LensAssetManifestItem_RequestTiming.ON_DEMAND:
      return "ON_DEMAND";
    case LensAssetManifestItem_RequestTiming.REQUIRED:
      return "REQUIRED";
    default:
      return "UNKNOWN";
  }
}
function createBaseLens() {
  return {
    id: "",
    name: "",
    vendorData: {},
    content: void 0,
    isThirdParty: false,
    cameraFacingPreference: Lens_CameraFacing.CAMERA_FACING_UNSET,
    featureMetadata: [],
    lensCreator: void 0,
    scannable: void 0
  };
}
var Lens = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          const entry3 = Lens_VendorDataEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.vendorData[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.content = Content.decode(reader, reader.uint32());
          break;
        case 5:
          message.isThirdParty = reader.bool();
          break;
        case 6:
          message.cameraFacingPreference = lens_CameraFacingFromJSON(reader.int32());
          break;
        case 7:
          message.featureMetadata.push(Any.decode(reader, reader.uint32()));
          break;
        case 8:
          message.lensCreator = LensCreator.decode(reader, reader.uint32());
          break;
        case 9:
          message.scannable = Scannable.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet2(object.id) ? String(object.id) : "",
      name: isSet2(object.name) ? String(object.name) : "",
      vendorData: isObject(object.vendorData) ? Object.entries(object.vendorData).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      content: isSet2(object.content) ? Content.fromJSON(object.content) : void 0,
      isThirdParty: isSet2(object.isThirdParty) ? Boolean(object.isThirdParty) : false,
      cameraFacingPreference: isSet2(object.cameraFacingPreference) ? lens_CameraFacingFromJSON(object.cameraFacingPreference) : Lens_CameraFacing.CAMERA_FACING_UNSET,
      featureMetadata: Array.isArray(object === null || object === void 0 ? void 0 : object.featureMetadata) ? object.featureMetadata.map((e2) => Any.fromJSON(e2)) : [],
      lensCreator: isSet2(object.lensCreator) ? LensCreator.fromJSON(object.lensCreator) : void 0,
      scannable: isSet2(object.scannable) ? Scannable.fromJSON(object.scannable) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.name !== void 0 && (obj.name = message.name);
    obj.vendorData = {};
    if (message.vendorData) {
      Object.entries(message.vendorData).forEach(([k2, v2]) => {
        obj.vendorData[k2] = v2;
      });
    }
    message.content !== void 0 && (obj.content = message.content ? Content.toJSON(message.content) : void 0);
    message.isThirdParty !== void 0 && (obj.isThirdParty = message.isThirdParty);
    message.cameraFacingPreference !== void 0 && (obj.cameraFacingPreference = lens_CameraFacingToJSON(message.cameraFacingPreference));
    if (message.featureMetadata) {
      obj.featureMetadata = message.featureMetadata.map((e2) => e2 ? Any.toJSON(e2) : void 0);
    } else {
      obj.featureMetadata = [];
    }
    message.lensCreator !== void 0 && (obj.lensCreator = message.lensCreator ? LensCreator.toJSON(message.lensCreator) : void 0);
    message.scannable !== void 0 && (obj.scannable = message.scannable ? Scannable.toJSON(message.scannable) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseLens();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.vendorData = Object.entries((_c = object.vendorData) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.content = object.content !== void 0 && object.content !== null ? Content.fromPartial(object.content) : void 0;
    message.isThirdParty = (_d = object.isThirdParty) !== null && _d !== void 0 ? _d : false;
    message.cameraFacingPreference = (_e = object.cameraFacingPreference) !== null && _e !== void 0 ? _e : Lens_CameraFacing.CAMERA_FACING_UNSET;
    message.featureMetadata = ((_f = object.featureMetadata) === null || _f === void 0 ? void 0 : _f.map((e2) => Any.fromPartial(e2))) || [];
    message.lensCreator = object.lensCreator !== void 0 && object.lensCreator !== null ? LensCreator.fromPartial(object.lensCreator) : void 0;
    message.scannable = object.scannable !== void 0 && object.scannable !== null ? Scannable.fromPartial(object.scannable) : void 0;
    return message;
  }
};
function createBaseLens_VendorDataEntry() {
  return { key: "", value: "" };
}
var Lens_VendorDataEntry = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens_VendorDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet2(object.key) ? String(object.key) : "",
      value: isSet2(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLens_VendorDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseContent() {
  return {
    lnsUrl: "",
    lnsSha256: "",
    iconUrl: "",
    preview: void 0,
    assetManifest: [],
    defaultHintId: "",
    hintTranslations: {},
    lnsUrlBolt: "",
    iconUrlBolt: ""
  };
}
var Content = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lnsUrl = reader.string();
          break;
        case 2:
          message.lnsSha256 = reader.string();
          break;
        case 3:
          message.iconUrl = reader.string();
          break;
        case 4:
          message.preview = Preview.decode(reader, reader.uint32());
          break;
        case 5:
          message.assetManifest.push(LensAssetManifestItem.decode(reader, reader.uint32()));
          break;
        case 6:
          message.defaultHintId = reader.string();
          break;
        case 7:
          const entry7 = Content_HintTranslationsEntry.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.hintTranslations[entry7.key] = entry7.value;
          }
          break;
        case 8:
          message.lnsUrlBolt = reader.string();
          break;
        case 9:
          message.iconUrlBolt = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      lnsUrl: isSet2(object.lnsUrl) ? String(object.lnsUrl) : "",
      lnsSha256: isSet2(object.lnsSha256) ? String(object.lnsSha256) : "",
      iconUrl: isSet2(object.iconUrl) ? String(object.iconUrl) : "",
      preview: isSet2(object.preview) ? Preview.fromJSON(object.preview) : void 0,
      assetManifest: Array.isArray(object === null || object === void 0 ? void 0 : object.assetManifest) ? object.assetManifest.map((e2) => LensAssetManifestItem.fromJSON(e2)) : [],
      defaultHintId: isSet2(object.defaultHintId) ? String(object.defaultHintId) : "",
      hintTranslations: isObject(object.hintTranslations) ? Object.entries(object.hintTranslations).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      lnsUrlBolt: isSet2(object.lnsUrlBolt) ? String(object.lnsUrlBolt) : "",
      iconUrlBolt: isSet2(object.iconUrlBolt) ? String(object.iconUrlBolt) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.lnsUrl !== void 0 && (obj.lnsUrl = message.lnsUrl);
    message.lnsSha256 !== void 0 && (obj.lnsSha256 = message.lnsSha256);
    message.iconUrl !== void 0 && (obj.iconUrl = message.iconUrl);
    message.preview !== void 0 && (obj.preview = message.preview ? Preview.toJSON(message.preview) : void 0);
    if (message.assetManifest) {
      obj.assetManifest = message.assetManifest.map((e2) => e2 ? LensAssetManifestItem.toJSON(e2) : void 0);
    } else {
      obj.assetManifest = [];
    }
    message.defaultHintId !== void 0 && (obj.defaultHintId = message.defaultHintId);
    obj.hintTranslations = {};
    if (message.hintTranslations) {
      Object.entries(message.hintTranslations).forEach(([k2, v2]) => {
        obj.hintTranslations[k2] = v2;
      });
    }
    message.lnsUrlBolt !== void 0 && (obj.lnsUrlBolt = message.lnsUrlBolt);
    message.iconUrlBolt !== void 0 && (obj.iconUrlBolt = message.iconUrlBolt);
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseContent();
    message.lnsUrl = (_a = object.lnsUrl) !== null && _a !== void 0 ? _a : "";
    message.lnsSha256 = (_b = object.lnsSha256) !== null && _b !== void 0 ? _b : "";
    message.iconUrl = (_c = object.iconUrl) !== null && _c !== void 0 ? _c : "";
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.assetManifest = ((_d = object.assetManifest) === null || _d === void 0 ? void 0 : _d.map((e2) => LensAssetManifestItem.fromPartial(e2))) || [];
    message.defaultHintId = (_e = object.defaultHintId) !== null && _e !== void 0 ? _e : "";
    message.hintTranslations = Object.entries((_f = object.hintTranslations) !== null && _f !== void 0 ? _f : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.lnsUrlBolt = (_g = object.lnsUrlBolt) !== null && _g !== void 0 ? _g : "";
    message.iconUrlBolt = (_h = object.iconUrlBolt) !== null && _h !== void 0 ? _h : "";
    return message;
  }
};
function createBaseContent_HintTranslationsEntry() {
  return { key: "", value: "" };
}
var Content_HintTranslationsEntry = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent_HintTranslationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet2(object.key) ? String(object.key) : "",
      value: isSet2(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseContent_HintTranslationsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseLensAssetManifestItem() {
  return {
    type: LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET,
    id: "",
    requestTiming: LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
    assetUrl: "",
    assetChecksum: ""
  };
}
var LensAssetManifestItem = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensAssetManifestItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = lensAssetManifestItem_TypeFromJSON(reader.int32());
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.requestTiming = lensAssetManifestItem_RequestTimingFromJSON(reader.int32());
          break;
        case 4:
          message.assetUrl = reader.string();
          break;
        case 5:
          message.assetChecksum = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? lensAssetManifestItem_TypeFromJSON(object.type) : LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET,
      id: isSet2(object.id) ? String(object.id) : "",
      requestTiming: isSet2(object.requestTiming) ? lensAssetManifestItem_RequestTimingFromJSON(object.requestTiming) : LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
      assetUrl: isSet2(object.assetUrl) ? String(object.assetUrl) : "",
      assetChecksum: isSet2(object.assetChecksum) ? String(object.assetChecksum) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = lensAssetManifestItem_TypeToJSON(message.type));
    message.id !== void 0 && (obj.id = message.id);
    message.requestTiming !== void 0 && (obj.requestTiming = lensAssetManifestItem_RequestTimingToJSON(message.requestTiming));
    message.assetUrl !== void 0 && (obj.assetUrl = message.assetUrl);
    message.assetChecksum !== void 0 && (obj.assetChecksum = message.assetChecksum);
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLensAssetManifestItem();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET;
    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : "";
    message.requestTiming = (_c = object.requestTiming) !== null && _c !== void 0 ? _c : LensAssetManifestItem_RequestTiming.PRELOAD_UNSET;
    message.assetUrl = (_d = object.assetUrl) !== null && _d !== void 0 ? _d : "";
    message.assetChecksum = (_e = object.assetChecksum) !== null && _e !== void 0 ? _e : "";
    return message;
  }
};
function createBasePreview() {
  return { imageUrl: "", imageSequenceSize: 0, imageSequenceWebpUrlPattern: "" };
}
var Preview = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.imageUrl = reader.string();
          break;
        case 2:
          message.imageSequenceSize = reader.int32();
          break;
        case 3:
          message.imageSequenceWebpUrlPattern = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageUrl: isSet2(object.imageUrl) ? String(object.imageUrl) : "",
      imageSequenceSize: isSet2(object.imageSequenceSize) ? Number(object.imageSequenceSize) : 0,
      imageSequenceWebpUrlPattern: isSet2(object.imageSequenceWebpUrlPattern) ? String(object.imageSequenceWebpUrlPattern) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.imageUrl !== void 0 && (obj.imageUrl = message.imageUrl);
    message.imageSequenceSize !== void 0 && (obj.imageSequenceSize = Math.round(message.imageSequenceSize));
    message.imageSequenceWebpUrlPattern !== void 0 && (obj.imageSequenceWebpUrlPattern = message.imageSequenceWebpUrlPattern);
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePreview();
    message.imageUrl = (_a = object.imageUrl) !== null && _a !== void 0 ? _a : "";
    message.imageSequenceSize = (_b = object.imageSequenceSize) !== null && _b !== void 0 ? _b : 0;
    message.imageSequenceWebpUrlPattern = (_c = object.imageSequenceWebpUrlPattern) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseLensCreator() {
  return { displayName: "" };
}
var LensCreator = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.displayName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      displayName: isSet2(object.displayName) ? String(object.displayName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    return obj;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLensCreator();
    message.displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseScannable() {
  return { snapcodeImageUrl: "", snapcodeDeeplink: "" };
}
var Scannable = {
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScannable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snapcodeImageUrl = reader.string();
          break;
        case 2:
          message.snapcodeDeeplink = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      snapcodeImageUrl: isSet2(object.snapcodeImageUrl) ? String(object.snapcodeImageUrl) : "",
      snapcodeDeeplink: isSet2(object.snapcodeDeeplink) ? String(object.snapcodeDeeplink) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.snapcodeImageUrl !== void 0 && (obj.snapcodeImageUrl = message.snapcodeImageUrl);
    message.snapcodeDeeplink !== void 0 && (obj.snapcodeDeeplink = message.snapcodeDeeplink);
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseScannable();
    message.snapcodeImageUrl = (_a = object.snapcodeImageUrl) !== null && _a !== void 0 ? _a : "";
    message.snapcodeDeeplink = (_b = object.snapcodeDeeplink) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
if (import_minimal2.default.util.Long !== import_long2.default) {
  import_minimal2.default.util.Long = import_long2.default;
  import_minimal2.default.configure();
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/logger/errorLoggingDecorator.js
function errorLoggingDecorator(logger21) {
  const handleError = (error) => logger21.error(error);
  return function(_target, _propertyKey, descriptor) {
    const methodName = descriptor.value ? "value" : "get";
    const originalMethod = descriptor[methodName];
    descriptor[methodName] = function(...args) {
      try {
        const result = originalMethod.apply(this, args);
        if (result instanceof Promise) {
          result.catch(handleError);
        }
        return result;
      } catch (error) {
        handleError(error);
        throw error;
      }
    };
    return descriptor;
  };
}

// node_modules/@snap/camera-kit/lib/common/assertions.js
function assertUnreachable(_) {
  throw new Error("Reached unreachable code at runtime.");
}
function assert(condition, error = "Assertion failed") {
  if (!condition) {
    if (error instanceof Error) {
      throw error;
    } else {
      throw new Error(error);
    }
  }
}

// node_modules/@snap/camera-kit/lib/lens/Lens.js
function isLensArray(value) {
  return isArrayOfType(isLens, value);
}
function isLens(value) {
  return isRecord(value) && isString(value.id) && isString(value.name) && (isUndefined(value.iconUrl) || isString(value.iconUrl)) && isRecord(value.vendorData) && predicateRecordValues(isString)(value.vendorData) && isString(value.cameraFacingPreference) && (isUndefined(value.preview) || isPreview(value.preview)) && (isUndefined(value.lensCreator) || isLensCreator(value.lensCreator)) && (isUndefined(value.snapcode) || isSnapcode(value.snapcode)) && isAnyArray(value.featureMetadata);
}
function isLensProto(value) {
  return isRecord(value) && isString(value.id) && isString(value.name) && isRecord(value.vendorData) && predicateRecordValues(isString)(value.vendorData) && (typeof value.content === "undefined" || isLensContent(value.content));
}
function isPreview(value) {
  return isRecord(value) && isString(value.imageUrl);
}
function isLensCreator(value) {
  return isRecord(value) && isString(value.displayName);
}
function isSnapcode(value) {
  return isRecord(value) && isString(value.imageUrl) && isString(value.deepLink);
}
function isLensContent(value) {
  return isRecord(value) && isString(value.iconUrlBolt) && isString(value.lnsSha256) && isString(value.lnsUrlBolt) && isRecord(value.preview) && isString(value.preview.imageUrl);
}
function isGetGroupResponse(value) {
  return isRecord(value) && isString(value.id) && Array.isArray(value.lenses) && value.lenses.every(isLensProto);
}
function isAny(value) {
  return isRecord(value) && isString(value.typeUrl) && isTypedArray(value.value);
}
function isAnyArray(value) {
  return isArrayOfType(isAny, value);
}
function toPublicLens({ id: id2, groupId, name, content, vendorData, cameraFacingPreference, lensCreator, scannable, featureMetadata }) {
  var _a;
  assert(isEmptyOrSafeUrl(content === null || content === void 0 ? void 0 : content.iconUrlBolt), "Unsafe icon URL");
  assert(isEmptyOrSafeUrl((_a = content === null || content === void 0 ? void 0 : content.preview) === null || _a === void 0 ? void 0 : _a.imageUrl), "Unsafe preview URL");
  return {
    id: id2,
    groupId,
    name,
    iconUrl: content === null || content === void 0 ? void 0 : content.iconUrlBolt,
    preview: (content === null || content === void 0 ? void 0 : content.preview) ? { imageUrl: content.preview.imageUrl } : void 0,
    vendorData,
    cameraFacingPreference,
    lensCreator,
    snapcode: scannable ? { imageUrl: scannable.snapcodeImageUrl, deepLink: scannable.snapcodeDeeplink } : void 0,
    featureMetadata
  };
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/features/ranking_info.js
var import_long3 = __toESM(require_long());
var import_minimal3 = __toESM(require_minimal2());
function createBaseRankingInfo() {
  return { rankingRequestId: "" };
}
var RankingInfo = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.rankingRequestId !== "") {
      writer.uint32(10).string(message.rankingRequestId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRankingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rankingRequestId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRankingInfo();
    message.rankingRequestId = (_a = object.rankingRequestId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
if (import_minimal3.default.util.Long !== import_long3.default) {
  import_minimal3.default.util.Long = import_long3.default;
  import_minimal3.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/features/remote_api_info.js
var import_long4 = __toESM(require_long());
var import_minimal4 = __toESM(require_minimal2());
function createBaseRemoteApiInfo() {
  return { apiSpecIds: [] };
}
var RemoteApiInfo = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    for (const v2 of message.apiSpecIds) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteApiInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.apiSpecIds.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRemoteApiInfo();
    message.apiSpecIds = ((_a = object.apiSpecIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
if (import_minimal4.default.util.Long !== import_long4.default) {
  import_minimal4.default.util.Long = import_long4.default;
  import_minimal4.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/google/protobuf/wrappers.js
var import_long5 = __toESM(require_long());
var import_minimal5 = __toESM(require_minimal2());
function createBaseBoolValue() {
  return { value: false };
}
var BoolValue = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.value === true) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBoolValue();
    message.value = (_a = object.value) !== null && _a !== void 0 ? _a : false;
    return message;
  }
};
function createBaseStringValue() {
  return { value: "" };
}
var StringValue = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : new import_minimal5.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStringValue();
    message.value = (_a = object.value) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
var globalThis3 = (() => {
  if (typeof globalThis3 !== "undefined")
    return globalThis3;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
if (import_minimal5.default.util.Long !== import_long5.default) {
  import_minimal5.default.util.Long = import_long5.default;
  import_minimal5.default.configure();
}

// node_modules/@snap/camera-kit/lib/common/any.js
var knownAnyTypes = {
  rankingInfo: "type.googleapis.com/com.snap.camerakit.v3.features.RankingInfo",
  remoteApiInfo: "type.googleapis.com/com.snap.camerakit.v3.features.RemoteApiInfo",
  string: "type.googleapis.com/google.protobuf.StringValue"
};
function encodeKnownAnyJson(jsonAny) {
  const typeUrl = jsonAny["@type"];
  switch (typeUrl) {
    case knownAnyTypes.remoteApiInfo:
      return {
        typeUrl,
        // Safety: we know that spec ensures all message fields to exists
        value: RemoteApiInfo.encode(jsonAny).finish()
      };
    case knownAnyTypes.rankingInfo:
      return {
        typeUrl,
        value: RankingInfo.encode(jsonAny).finish()
      };
    case knownAnyTypes.string:
      return {
        typeUrl,
        value: StringValue.encode(jsonAny).finish()
      };
    default:
      break;
  }
}

// node_modules/@snap/camera-kit/lib/lens/lensHttpUtil.js
var relativePath = "/com.snap.camerakit.v3.Lenses";
function fixAny(lens) {
  const featureMetadata = lens.featureMetadata.reduce((fixedAnys, anyToFix) => {
    const fixedAny = encodeKnownAnyJson(anyToFix);
    return fixedAny ? [...fixedAnys, fixedAny] : fixedAnys;
  }, []);
  return Object.assign(Object.assign({}, lens), { featureMetadata });
}
function getRequestId(res) {
  return res.headers.get("x-request-id");
}
function retrieveCameraKitLens(httpClient, lensId, groupId, apiHostname) {
  return __awaiter(this, void 0, void 0, function* () {
    const url = `https://${apiHostname}${relativePath}/groups/${groupId}/lenses/${lensId}`;
    const response = yield httpClient(url, { credentials: "include" });
    const body = yield response.json();
    const lens = body.lens;
    if (!response.ok) {
      throw new Error(`Cannot load lens ${lensId} in group ${groupId}. GetGroupLens responded with status ${response.status} and body:
	${JSON.stringify(body)} for requestId ${getRequestId(response)}`);
    }
    if (!isLensProto(lens)) {
      throw new Error(`Cannot load lens ${lensId} in group ${groupId}. The response was not a Lens:
	${JSON.stringify(body)} for requestId ${getRequestId(response)}`);
    }
    return fixAny(lens);
  });
}
function retrieveCameraKitLensGroup(httpClient, groupId, apiHostname) {
  return __awaiter(this, void 0, void 0, function* () {
    const url = `https://${apiHostname}${relativePath}/groups/${groupId}`;
    const response = yield httpClient(url, { credentials: "include" });
    const body = yield response.json();
    if (!response.ok) {
      throw new Error(`Cannot load lens group ${groupId}. GetGroup responded with status ${response.status} and body:
	${JSON.stringify(body)} for requestId ${getRequestId(response)}`);
    }
    if (!isGetGroupResponse(body)) {
      throw new Error(`Cannot load lens group ${groupId}. The response was not a LensGroup:
	${JSON.stringify(body)} for requestId ${getRequestId(response)}`);
    }
    return body.lenses.map(fixAny);
  });
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/export.js
var import_long6 = __toESM(require_long());
var import_minimal6 = __toESM(require_minimal2());
var ExportLensesByIdRequest_Context_Extension_Name;
(function(ExportLensesByIdRequest_Context_Extension_Name2) {
  ExportLensesByIdRequest_Context_Extension_Name2["UNSET"] = "UNSET";
  ExportLensesByIdRequest_Context_Extension_Name2["SHOP_KIT"] = "SHOP_KIT";
  ExportLensesByIdRequest_Context_Extension_Name2["LENS_WEB_BUILDER"] = "LENS_WEB_BUILDER";
  ExportLensesByIdRequest_Context_Extension_Name2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdRequest_Context_Extension_Name || (ExportLensesByIdRequest_Context_Extension_Name = {}));
var ExportLensesByIdResponse_ExcludedLens_Code;
(function(ExportLensesByIdResponse_ExcludedLens_Code2) {
  ExportLensesByIdResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  ExportLensesByIdResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  ExportLensesByIdResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  ExportLensesByIdResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  ExportLensesByIdResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdResponse_ExcludedLens_Code || (ExportLensesByIdResponse_ExcludedLens_Code = {}));
function createBaseExtensionRequestContext() {
  return { userAgent: "", locale: "" };
}
var ExtensionRequestContext = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : new import_minimal6.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userAgent = reader.string();
          break;
        case 2:
          message.locale = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseExtensionRequestContext();
    message.userAgent = (_a = object.userAgent) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseEnvelope() {
  return { lenses: [] };
}
var Envelope = {
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : new import_minimal6.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEnvelope();
    message.lenses = ((_a = object.lenses) === null || _a === void 0 ? void 0 : _a.map((e2) => Lens.fromPartial(e2))) || [];
    return message;
  }
};
var globalThis4 = (() => {
  if (typeof globalThis4 !== "undefined")
    return globalThis4;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
if (import_minimal6.default.util.Long !== import_long6.default) {
  import_minimal6.default.util.Long = import_long6.default;
  import_minimal6.default.configure();
}

// node_modules/@snap/camera-kit/lib/lens/lensEnvelopeUtil.js
function decodeEnvelope(envelope) {
  try {
    return Envelope.decode(new Uint8Array(envelope)).lenses;
  } catch (_a) {
    throw new Error("Invalid lens envelope.");
  }
}
function decodeEnvelopes(envelopes) {
  return envelopes.reduce((lenses, envelope) => [...lenses, ...decodeEnvelope(envelope)], []);
}

// node_modules/@snap/camera-kit/lib/metrics/metricsEventTarget.js
var metricsEventTargetFactory = Injectable("metricsEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/namespace.js
var import_long7 = __toESM(require_long());
var import_minimal7 = __toESM(require_minimal2());
var Namespace;
(function(Namespace2) {
  Namespace2[Namespace2["DEFAULT"] = 0] = "DEFAULT";
  Namespace2[Namespace2["LENS_CORE"] = 64] = "LENS_CORE";
  Namespace2[Namespace2["CAMERA_KIT_CORE"] = 65] = "CAMERA_KIT_CORE";
  Namespace2[Namespace2["LENS_CORE_CONFIG"] = 143] = "LENS_CORE_CONFIG";
  Namespace2[Namespace2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Namespace || (Namespace = {}));
if (import_minimal7.default.util.Long !== import_long7.default) {
  import_minimal7.default.util.Long = import_long7.default;
  import_minimal7.default.configure();
}

// node_modules/@snap/camera-kit/lib/remote-configuration/cofHandler.js
var import_browser_headers2 = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/circumstance_service.js
var import_long16 = __toESM(require_long());
var import_grpc_web = __toESM(require_grpc_web_client_umd());
var import_minimal16 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_request.js
var import_long11 = __toESM(require_long());
var import_minimal11 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/benchmark.js
var import_long9 = __toESM(require_long());
var import_minimal9 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/google/protobuf/timestamp.js
var import_long8 = __toESM(require_long());
var import_minimal8 = __toESM(require_minimal2());
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
var Timestamp = {
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : new import_minimal8.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seconds = longToNumber(reader.int64());
          break;
        case 2:
          message.nanos = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet3(object.seconds) ? Number(object.seconds) : 0,
      nanos: isSet3(object.nanos) ? Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));
    message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTimestamp();
    message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : 0;
    message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
var globalThis5 = (() => {
  if (typeof globalThis5 !== "undefined")
    return globalThis5;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function longToNumber(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis5.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal8.default.util.Long !== import_long8.default) {
  import_minimal8.default.util.Long = import_long8.default;
  import_minimal8.default.configure();
}
function isSet3(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/benchmark.js
function createBaseBenchmarkValue() {
  return { intValue: void 0, longValue: void 0, boolValue: void 0, floatValue: void 0 };
}
var BenchmarkValue = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(37).float(message.floatValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.intValue = reader.int32();
          break;
        case 2:
          message.longValue = longToNumber2(reader.int64());
          break;
        case 3:
          message.boolValue = reader.bool();
          break;
        case 4:
          message.floatValue = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseBenchmarkValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.boolValue = (_c = object.boolValue) !== null && _c !== void 0 ? _c : void 0;
    message.floatValue = (_d = object.floatValue) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function createBaseBenchmarkRequest() {
  return { benchmarkNames: [], expirationTimestamp: void 0 };
}
var BenchmarkRequest = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.benchmarkNames) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.expirationTimestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.expirationTimestamp), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.benchmarkNames.push(reader.int32());
            }
          } else {
            message.benchmarkNames.push(reader.int32());
          }
          break;
        case 2:
          message.expirationTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBenchmarkRequest();
    message.benchmarkNames = ((_a = object.benchmarkNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.expirationTimestamp = (_b = object.expirationTimestamp) !== null && _b !== void 0 ? _b : void 0;
    return message;
  }
};
function createBaseBenchmarkResult() {
  return { name: 0, value: void 0 };
}
var BenchmarkResult = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.name !== 0) {
      writer.uint32(8).int32(message.name);
    }
    if (message.value !== void 0) {
      BenchmarkValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : new import_minimal9.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.int32();
          break;
        case 2:
          message.value = BenchmarkValue.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBenchmarkResult();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : 0;
    message.value = object.value !== void 0 && object.value !== null ? BenchmarkValue.fromPartial(object.value) : void 0;
    return message;
  }
};
var globalThis6 = (() => {
  if (typeof globalThis6 !== "undefined")
    return globalThis6;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function toTimestamp(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t2) {
  let millis = t2.seconds * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function longToNumber2(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis6.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal9.default.util.Long !== import_long9.default) {
  import_minimal9.default.util.Long = import_long9.default;
  import_minimal9.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/common/ruid.js
var import_long10 = __toESM(require_long());
var import_minimal10 = __toESM(require_minimal2());
var Ruid_Type;
(function(Ruid_Type2) {
  Ruid_Type2[Ruid_Type2["UNSET"] = 0] = "UNSET";
  Ruid_Type2[Ruid_Type2["USER"] = 1] = "USER";
  Ruid_Type2[Ruid_Type2["DEVICE"] = 2] = "DEVICE";
  Ruid_Type2[Ruid_Type2["WEB_CLIENT"] = 3] = "WEB_CLIENT";
  Ruid_Type2[Ruid_Type2["AD_ACCOUNT"] = 4] = "AD_ACCOUNT";
  Ruid_Type2[Ruid_Type2["USERNAME"] = 5] = "USERNAME";
  Ruid_Type2[Ruid_Type2["AD_MODERATION_AD"] = 6] = "AD_MODERATION_AD";
  Ruid_Type2[Ruid_Type2["WEB_SNAPCHAT_USER"] = 7] = "WEB_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["INTERNAL"] = 8] = "INTERNAL";
  Ruid_Type2[Ruid_Type2["AM_ORGANIZATION"] = 9] = "AM_ORGANIZATION";
  Ruid_Type2[Ruid_Type2["AM_MEMBER"] = 10] = "AM_MEMBER";
  Ruid_Type2[Ruid_Type2["AM_SESSION"] = 11] = "AM_SESSION";
  Ruid_Type2[Ruid_Type2["AM_PROFILE"] = 12] = "AM_PROFILE";
  Ruid_Type2[Ruid_Type2["AM_SNAPCHAT_USER"] = 13] = "AM_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["SNAPCHAT_ADVERTISING"] = 14] = "SNAPCHAT_ADVERTISING";
  Ruid_Type2[Ruid_Type2["AM_CLIENT"] = 15] = "AM_CLIENT";
  Ruid_Type2[Ruid_Type2["MISCHIEF"] = 16] = "MISCHIEF";
  Ruid_Type2[Ruid_Type2["ARES_VISITOR"] = 17] = "ARES_VISITOR";
  Ruid_Type2[Ruid_Type2["POD_NAME"] = 18] = "POD_NAME";
  Ruid_Type2[Ruid_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Ruid_Type || (Ruid_Type = {}));
function createBaseRuid() {
  return { type: 0, stringValue: "", loggingIdValue: "" };
}
var Ruid = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.stringValue !== "") {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.loggingIdValue !== "") {
      writer.uint32(26).string(message.loggingIdValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : new import_minimal10.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;
        case 2:
          message.stringValue = reader.string();
          break;
        case 3:
          message.loggingIdValue = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseRuid();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.stringValue = (_b = object.stringValue) !== null && _b !== void 0 ? _b : "";
    message.loggingIdValue = (_c = object.loggingIdValue) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
if (import_minimal10.default.util.Long !== import_long10.default) {
  import_minimal10.default.util.Long = import_long10.default;
  import_minimal10.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_request.js
var ConfigTargetingTriggerEventType;
(function(ConfigTargetingTriggerEventType2) {
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNKNOWN_EVENT_TYPE"] = 0] = "UNKNOWN_EVENT_TYPE";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["COLD_START"] = 1] = "COLD_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["WARM_START"] = 2] = "WARM_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["FOREGROUND_TRIGGER"] = 3] = "FOREGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["BACKGROUND_TRIGGER"] = 4] = "BACKGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingTriggerEventType || (ConfigTargetingTriggerEventType = {}));
var ConfigTargetingAppState;
(function(ConfigTargetingAppState2) {
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNKNOWN_APP_STATE"] = 0] = "UNKNOWN_APP_STATE";
  ConfigTargetingAppState2[ConfigTargetingAppState2["FOREGROUND"] = 1] = "FOREGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["BACKGROUND"] = 2] = "BACKGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingAppState || (ConfigTargetingAppState = {}));
var ConfigTargetingInstrumentation;
(function(ConfigTargetingInstrumentation2) {
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["DEFAULT_INSTRUMENTATION"] = 0] = "DEFAULT_INSTRUMENTATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["USER_AUTHENTICATION"] = 1] = "USER_AUTHENTICATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingInstrumentation || (ConfigTargetingInstrumentation = {}));
var Connectivity_NetworkType;
(function(Connectivity_NetworkType2) {
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNKNOWN_NETWORK_TYPE"] = 0] = "UNKNOWN_NETWORK_TYPE";
  Connectivity_NetworkType2[Connectivity_NetworkType2["CELLULAR"] = 1] = "CELLULAR";
  Connectivity_NetworkType2[Connectivity_NetworkType2["WIFI"] = 2] = "WIFI";
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Connectivity_NetworkType || (Connectivity_NetworkType = {}));
function createBaseConfigTargetingRequest() {
  return {
    configResultsEtag: "",
    namespaces: [],
    ghostId: "",
    countryCode: "",
    screenWidth: 0,
    screenHeight: 0,
    connectivity: void 0,
    maxVideoWidthPx: 0,
    maxVideoHeightPx: 0,
    benchmarkResults: [],
    deltaSync: false,
    userAgent: "",
    triggerEventType: 0,
    appState: 0,
    locale: "",
    deviceId: "",
    userId: "",
    clientIp: "",
    isUnAuthorized: false,
    appLocale: "",
    instrumentation: 0,
    lastSuccessfulSync: 0,
    isLogout: false,
    packageInstaller: "",
    syncTriggerBlizzardSessionId: "",
    syncExecutionBlizzardSessionId: "",
    cofSyncTriggerDelayFromStartupMs: 0,
    cofSyncExecutionDelayFromStartupMs: 0,
    syncTriggerTime: 0,
    decoderEncoderAvailability: void 0,
    snapkitAppId: "",
    lenscoreVersion: 0,
    ruid: void 0,
    configNames: [],
    includeTestUserTreatments: false,
    disableExposureLogging: false,
    lensClusterOrig4: 0,
    clientId: ""
  };
}
var ConfigTargetingRequest = {
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.configResultsEtag !== "") {
      writer.uint32(10).string(message.configResultsEtag);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.ghostId !== "") {
      writer.uint32(26).string(message.ghostId);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.screenWidth !== 0) {
      writer.uint32(40).int32(message.screenWidth);
    }
    if (message.screenHeight !== 0) {
      writer.uint32(48).int32(message.screenHeight);
    }
    if (message.connectivity !== void 0) {
      Connectivity.encode(message.connectivity, writer.uint32(58).fork()).ldelim();
    }
    if (message.maxVideoWidthPx !== 0) {
      writer.uint32(64).int32(message.maxVideoWidthPx);
    }
    if (message.maxVideoHeightPx !== 0) {
      writer.uint32(72).int32(message.maxVideoHeightPx);
    }
    for (const v2 of message.benchmarkResults) {
      BenchmarkResult.encode(v2, writer.uint32(82).fork()).ldelim();
    }
    if (message.deltaSync === true) {
      writer.uint32(88).bool(message.deltaSync);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.triggerEventType !== 0) {
      writer.uint32(104).int32(message.triggerEventType);
    }
    if (message.appState !== 0) {
      writer.uint32(112).int32(message.appState);
    }
    if (message.locale !== "") {
      writer.uint32(122).string(message.locale);
    }
    if (message.deviceId !== "") {
      writer.uint32(130).string(message.deviceId);
    }
    if (message.userId !== "") {
      writer.uint32(138).string(message.userId);
    }
    if (message.clientIp !== "") {
      writer.uint32(146).string(message.clientIp);
    }
    if (message.isUnAuthorized === true) {
      writer.uint32(152).bool(message.isUnAuthorized);
    }
    if (message.appLocale !== "") {
      writer.uint32(162).string(message.appLocale);
    }
    if (message.instrumentation !== 0) {
      writer.uint32(168).int32(message.instrumentation);
    }
    if (message.lastSuccessfulSync !== 0) {
      writer.uint32(176).int64(message.lastSuccessfulSync);
    }
    if (message.isLogout === true) {
      writer.uint32(184).bool(message.isLogout);
    }
    if (message.packageInstaller !== "") {
      writer.uint32(194).string(message.packageInstaller);
    }
    if (message.syncTriggerBlizzardSessionId !== "") {
      writer.uint32(202).string(message.syncTriggerBlizzardSessionId);
    }
    if (message.syncExecutionBlizzardSessionId !== "") {
      writer.uint32(210).string(message.syncExecutionBlizzardSessionId);
    }
    if (message.cofSyncTriggerDelayFromStartupMs !== 0) {
      writer.uint32(216).int32(message.cofSyncTriggerDelayFromStartupMs);
    }
    if (message.cofSyncExecutionDelayFromStartupMs !== 0) {
      writer.uint32(224).int32(message.cofSyncExecutionDelayFromStartupMs);
    }
    if (message.syncTriggerTime !== 0) {
      writer.uint32(232).int64(message.syncTriggerTime);
    }
    if (message.decoderEncoderAvailability !== void 0) {
      DecoderEncoderAvailablity.encode(message.decoderEncoderAvailability, writer.uint32(242).fork()).ldelim();
    }
    if (message.snapkitAppId !== "") {
      writer.uint32(250).string(message.snapkitAppId);
    }
    if (message.lenscoreVersion !== 0) {
      writer.uint32(256).int32(message.lenscoreVersion);
    }
    if (message.ruid !== void 0) {
      Ruid.encode(message.ruid, writer.uint32(266).fork()).ldelim();
    }
    for (const v2 of message.configNames) {
      writer.uint32(274).string(v2);
    }
    if (message.includeTestUserTreatments === true) {
      writer.uint32(288).bool(message.includeTestUserTreatments);
    }
    if (message.disableExposureLogging === true) {
      writer.uint32(296).bool(message.disableExposureLogging);
    }
    if (message.lensClusterOrig4 !== 0) {
      writer.uint32(304).int32(message.lensClusterOrig4);
    }
    if (message.clientId !== "") {
      writer.uint32(314).string(message.clientId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : new import_minimal11.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResultsEtag = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 3:
          message.ghostId = reader.string();
          break;
        case 4:
          message.countryCode = reader.string();
          break;
        case 5:
          message.screenWidth = reader.int32();
          break;
        case 6:
          message.screenHeight = reader.int32();
          break;
        case 7:
          message.connectivity = Connectivity.decode(reader, reader.uint32());
          break;
        case 8:
          message.maxVideoWidthPx = reader.int32();
          break;
        case 9:
          message.maxVideoHeightPx = reader.int32();
          break;
        case 10:
          message.benchmarkResults.push(BenchmarkResult.decode(reader, reader.uint32()));
          break;
        case 11:
          message.deltaSync = reader.bool();
          break;
        case 12:
          message.userAgent = reader.string();
          break;
        case 13:
          message.triggerEventType = reader.int32();
          break;
        case 14:
          message.appState = reader.int32();
          break;
        case 15:
          message.locale = reader.string();
          break;
        case 16:
          message.deviceId = reader.string();
          break;
        case 17:
          message.userId = reader.string();
          break;
        case 18:
          message.clientIp = reader.string();
          break;
        case 19:
          message.isUnAuthorized = reader.bool();
          break;
        case 20:
          message.appLocale = reader.string();
          break;
        case 21:
          message.instrumentation = reader.int32();
          break;
        case 22:
          message.lastSuccessfulSync = longToNumber3(reader.int64());
          break;
        case 23:
          message.isLogout = reader.bool();
          break;
        case 24:
          message.packageInstaller = reader.string();
          break;
        case 25:
          message.syncTriggerBlizzardSessionId = reader.string();
          break;
        case 26:
          message.syncExecutionBlizzardSessionId = reader.string();
          break;
        case 27:
          message.cofSyncTriggerDelayFromStartupMs = reader.int32();
          break;
        case 28:
          message.cofSyncExecutionDelayFromStartupMs = reader.int32();
          break;
        case 29:
          message.syncTriggerTime = longToNumber3(reader.int64());
          break;
        case 30:
          message.decoderEncoderAvailability = DecoderEncoderAvailablity.decode(reader, reader.uint32());
          break;
        case 31:
          message.snapkitAppId = reader.string();
          break;
        case 32:
          message.lenscoreVersion = reader.int32();
          break;
        case 33:
          message.ruid = Ruid.decode(reader, reader.uint32());
          break;
        case 34:
          message.configNames.push(reader.string());
          break;
        case 36:
          message.includeTestUserTreatments = reader.bool();
          break;
        case 37:
          message.disableExposureLogging = reader.bool();
          break;
        case 38:
          message.lensClusterOrig4 = reader.int32();
          break;
        case 39:
          message.clientId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
    const message = createBaseConfigTargetingRequest();
    message.configResultsEtag = (_a = object.configResultsEtag) !== null && _a !== void 0 ? _a : "";
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.ghostId = (_c = object.ghostId) !== null && _c !== void 0 ? _c : "";
    message.countryCode = (_d = object.countryCode) !== null && _d !== void 0 ? _d : "";
    message.screenWidth = (_e = object.screenWidth) !== null && _e !== void 0 ? _e : 0;
    message.screenHeight = (_f = object.screenHeight) !== null && _f !== void 0 ? _f : 0;
    message.connectivity = object.connectivity !== void 0 && object.connectivity !== null ? Connectivity.fromPartial(object.connectivity) : void 0;
    message.maxVideoWidthPx = (_g = object.maxVideoWidthPx) !== null && _g !== void 0 ? _g : 0;
    message.maxVideoHeightPx = (_h = object.maxVideoHeightPx) !== null && _h !== void 0 ? _h : 0;
    message.benchmarkResults = ((_j = object.benchmarkResults) === null || _j === void 0 ? void 0 : _j.map((e2) => BenchmarkResult.fromPartial(e2))) || [];
    message.deltaSync = (_k = object.deltaSync) !== null && _k !== void 0 ? _k : false;
    message.userAgent = (_l = object.userAgent) !== null && _l !== void 0 ? _l : "";
    message.triggerEventType = (_m = object.triggerEventType) !== null && _m !== void 0 ? _m : 0;
    message.appState = (_o = object.appState) !== null && _o !== void 0 ? _o : 0;
    message.locale = (_p = object.locale) !== null && _p !== void 0 ? _p : "";
    message.deviceId = (_q = object.deviceId) !== null && _q !== void 0 ? _q : "";
    message.userId = (_r = object.userId) !== null && _r !== void 0 ? _r : "";
    message.clientIp = (_s = object.clientIp) !== null && _s !== void 0 ? _s : "";
    message.isUnAuthorized = (_t = object.isUnAuthorized) !== null && _t !== void 0 ? _t : false;
    message.appLocale = (_u = object.appLocale) !== null && _u !== void 0 ? _u : "";
    message.instrumentation = (_v = object.instrumentation) !== null && _v !== void 0 ? _v : 0;
    message.lastSuccessfulSync = (_w = object.lastSuccessfulSync) !== null && _w !== void 0 ? _w : 0;
    message.isLogout = (_x = object.isLogout) !== null && _x !== void 0 ? _x : false;
    message.packageInstaller = (_y = object.packageInstaller) !== null && _y !== void 0 ? _y : "";
    message.syncTriggerBlizzardSessionId = (_z = object.syncTriggerBlizzardSessionId) !== null && _z !== void 0 ? _z : "";
    message.syncExecutionBlizzardSessionId = (_0 = object.syncExecutionBlizzardSessionId) !== null && _0 !== void 0 ? _0 : "";
    message.cofSyncTriggerDelayFromStartupMs = (_1 = object.cofSyncTriggerDelayFromStartupMs) !== null && _1 !== void 0 ? _1 : 0;
    message.cofSyncExecutionDelayFromStartupMs = (_2 = object.cofSyncExecutionDelayFromStartupMs) !== null && _2 !== void 0 ? _2 : 0;
    message.syncTriggerTime = (_3 = object.syncTriggerTime) !== null && _3 !== void 0 ? _3 : 0;
    message.decoderEncoderAvailability = object.decoderEncoderAvailability !== void 0 && object.decoderEncoderAvailability !== null ? DecoderEncoderAvailablity.fromPartial(object.decoderEncoderAvailability) : void 0;
    message.snapkitAppId = (_4 = object.snapkitAppId) !== null && _4 !== void 0 ? _4 : "";
    message.lenscoreVersion = (_5 = object.lenscoreVersion) !== null && _5 !== void 0 ? _5 : 0;
    message.ruid = object.ruid !== void 0 && object.ruid !== null ? Ruid.fromPartial(object.ruid) : void 0;
    message.configNames = ((_6 = object.configNames) === null || _6 === void 0 ? void 0 : _6.map((e2) => e2)) || [];
    message.includeTestUserTreatments = (_7 = object.includeTestUserTreatments) !== null && _7 !== void 0 ? _7 : false;
    message.disableExposureLogging = (_8 = object.disableExposureLogging) !== null && _8 !== void 0 ? _8 : false;
    message.lensClusterOrig4 = (_9 = object.lensClusterOrig4) !== null && _9 !== void 0 ? _9 : 0;
    message.clientId = (_10 = object.clientId) !== null && _10 !== void 0 ? _10 : "";
    return message;
  }
};
function createBaseConnectivity() {
  return { networkType: 0, isMetered: void 0, isRoaming: void 0, carrier: "" };
}
var Connectivity = {
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.networkType !== 0) {
      writer.uint32(8).int32(message.networkType);
    }
    if (message.isMetered !== void 0) {
      BoolValue.encode({ value: message.isMetered }, writer.uint32(18).fork()).ldelim();
    }
    if (message.isRoaming !== void 0) {
      BoolValue.encode({ value: message.isRoaming }, writer.uint32(26).fork()).ldelim();
    }
    if (message.carrier !== "") {
      writer.uint32(34).string(message.carrier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : new import_minimal11.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.networkType = reader.int32();
          break;
        case 2:
          message.isMetered = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.isRoaming = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.carrier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseConnectivity();
    message.networkType = (_a = object.networkType) !== null && _a !== void 0 ? _a : 0;
    message.isMetered = (_b = object.isMetered) !== null && _b !== void 0 ? _b : void 0;
    message.isRoaming = (_c = object.isRoaming) !== null && _c !== void 0 ? _c : void 0;
    message.carrier = (_d = object.carrier) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseDecoderEncoderAvailablity() {
  return { isSnapVp9DecoderAvailable: false, isSnapAv1DecoderAvailable: false };
}
var DecoderEncoderAvailablity = {
  encode(message, writer = import_minimal11.default.Writer.create()) {
    if (message.isSnapVp9DecoderAvailable === true) {
      writer.uint32(8).bool(message.isSnapVp9DecoderAvailable);
    }
    if (message.isSnapAv1DecoderAvailable === true) {
      writer.uint32(16).bool(message.isSnapAv1DecoderAvailable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal11.default.Reader ? input : new import_minimal11.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDecoderEncoderAvailablity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isSnapVp9DecoderAvailable = reader.bool();
          break;
        case 2:
          message.isSnapAv1DecoderAvailable = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseDecoderEncoderAvailablity();
    message.isSnapVp9DecoderAvailable = (_a = object.isSnapVp9DecoderAvailable) !== null && _a !== void 0 ? _a : false;
    message.isSnapAv1DecoderAvailable = (_b = object.isSnapAv1DecoderAvailable) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
var globalThis7 = (() => {
  if (typeof globalThis7 !== "undefined")
    return globalThis7;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function longToNumber3(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis7.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal11.default.util.Long !== import_long11.default) {
  import_minimal11.default.util.Long = import_long11.default;
  import_minimal11.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_response.js
var import_long14 = __toESM(require_long());
var import_minimal14 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_result.js
var import_long13 = __toESM(require_long());
var import_minimal13 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/common/value.js
var import_long12 = __toESM(require_long());
var import_minimal12 = __toESM(require_minimal2());
function createBaseMapRecord() {
  return { key: "", value: "" };
}
var MapRecord = {
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMapRecord();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseMapRecords() {
  return { records: [] };
}
var MapRecords = {
  encode(message, writer = import_minimal12.default.Writer.create()) {
    for (const v2 of message.records) {
      MapRecord.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.records.push(MapRecord.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMapRecords();
    message.records = ((_a = object.records) === null || _a === void 0 ? void 0 : _a.map((e2) => MapRecord.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseStringArray() {
  return { value: [] };
}
var StringArray = {
  encode(message, writer = import_minimal12.default.Writer.create()) {
    for (const v2 of message.value) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStringArray();
    message.value = ((_a = object.value) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseValue() {
  return {
    intValue: void 0,
    longValue: void 0,
    floatValue: void 0,
    doubleValue: void 0,
    boolValue: void 0,
    stringValue: void 0,
    anyValue: void 0,
    mapValue: void 0,
    intPairValue: void 0,
    stringArrayValue: void 0
  };
}
var Value = {
  encode(message, writer = import_minimal12.default.Writer.create()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(29).float(message.floatValue);
    }
    if (message.doubleValue !== void 0) {
      writer.uint32(73).double(message.doubleValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(42).string(message.stringValue);
    }
    if (message.anyValue !== void 0) {
      Any.encode(message.anyValue, writer.uint32(50).fork()).ldelim();
    }
    if (message.mapValue !== void 0) {
      MapRecords.encode(message.mapValue, writer.uint32(58).fork()).ldelim();
    }
    if (message.intPairValue !== void 0) {
      writer.uint32(65).fixed64(message.intPairValue);
    }
    if (message.stringArrayValue !== void 0) {
      StringArray.encode(message.stringArrayValue, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal12.default.Reader ? input : new import_minimal12.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.intValue = reader.int32();
          break;
        case 2:
          message.longValue = longToNumber4(reader.int64());
          break;
        case 3:
          message.floatValue = reader.float();
          break;
        case 9:
          message.doubleValue = reader.double();
          break;
        case 4:
          message.boolValue = reader.bool();
          break;
        case 5:
          message.stringValue = reader.string();
          break;
        case 6:
          message.anyValue = Any.decode(reader, reader.uint32());
          break;
        case 7:
          message.mapValue = MapRecords.decode(reader, reader.uint32());
          break;
        case 8:
          message.intPairValue = longToNumber4(reader.fixed64());
          break;
        case 10:
          message.stringArrayValue = StringArray.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.floatValue = (_c = object.floatValue) !== null && _c !== void 0 ? _c : void 0;
    message.doubleValue = (_d = object.doubleValue) !== null && _d !== void 0 ? _d : void 0;
    message.boolValue = (_e = object.boolValue) !== null && _e !== void 0 ? _e : void 0;
    message.stringValue = (_f = object.stringValue) !== null && _f !== void 0 ? _f : void 0;
    message.anyValue = object.anyValue !== void 0 && object.anyValue !== null ? Any.fromPartial(object.anyValue) : void 0;
    message.mapValue = object.mapValue !== void 0 && object.mapValue !== null ? MapRecords.fromPartial(object.mapValue) : void 0;
    message.intPairValue = (_g = object.intPairValue) !== null && _g !== void 0 ? _g : void 0;
    message.stringArrayValue = object.stringArrayValue !== void 0 && object.stringArrayValue !== null ? StringArray.fromPartial(object.stringArrayValue) : void 0;
    return message;
  }
};
var globalThis8 = (() => {
  if (typeof globalThis8 !== "undefined")
    return globalThis8;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function longToNumber4(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis8.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal12.default.util.Long !== import_long12.default) {
  import_minimal12.default.util.Long = import_long12.default;
  import_minimal12.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_result.js
var ConfigResult_ServePlatform;
(function(ConfigResult_ServePlatform2) {
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNKNOWN_CONTEXT_PLATFORM"] = 0] = "UNKNOWN_CONTEXT_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["IOS_PLATFORM"] = 1] = "IOS_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["ANDROID_PLATFORM"] = 2] = "ANDROID_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["SERVER_PLATFORM"] = 3] = "SERVER_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigResult_ServePlatform || (ConfigResult_ServePlatform = {}));
var ClientTargetingExpression_Operator;
(function(ClientTargetingExpression_Operator2) {
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNKNOWN_OPERATOR"] = 0] = "UNKNOWN_OPERATOR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["AND"] = 1] = "AND";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["OR"] = 2] = "OR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Operator || (ClientTargetingExpression_Operator = {}));
var ClientTargetingExpression_PredicateOperator;
(function(ClientTargetingExpression_PredicateOperator2) {
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNKNOWN_PREDICATE_OPERATOR"] = 0] = "UNKNOWN_PREDICATE_OPERATOR";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["EQUAL"] = 1] = "EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["NOT_EQUAL"] = 2] = "NOT_EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["GREATER_THAN_OR_EQUAL_TO"] = 3] = "GREATER_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["LESS_THAN_OR_EQUAL_TO"] = 4] = "LESS_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PredicateOperator || (ClientTargetingExpression_PredicateOperator = {}));
var ClientTargetingExpression_Property;
(function(ClientTargetingExpression_Property2) {
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNKNOWN_PROPERTY"] = 0] = "UNKNOWN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BATTERY_LEVEL"] = 1] = "BATTERY_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFLINE"] = 2] = "IS_OFFLINE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_CHARGING"] = 3] = "IS_CHARGING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BANDWIDTH"] = 4] = "BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_SIZE"] = 5] = "DISK_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_AVAILABLE"] = 6] = "DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE_DEPRECATED"] = 7] = "MEDIA_TYPE_DEPRECATED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_STORY"] = 8] = "IS_PUBLIC_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFICIAL_STORY"] = 9] = "IS_OFFICIAL_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_DIRECTION"] = 10] = "CAMERA_DIRECTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_CONTEXT"] = 11] = "CAMERA_CONTEXT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_API"] = 12] = "CAMERA_API";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_FLASH_STATE"] = 13] = "CAMERA_FLASH_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_SOURCE"] = 14] = "SNAP_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LEGACY_MUSHROOM_CONTENT_TYPE"] = 15] = "LEGACY_MUSHROOM_CONTENT_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPLOAD_BANDWIDTH"] = 16] = "UPLOAD_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_LEVEL"] = 17] = "CAMERA2_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_NIGHT_MODE_STATE"] = 18] = "CAMERA_NIGHT_MODE_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_LANGUAGE"] = 19] = "USER_LANGUAGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VIDEO_DURATION"] = 20] = "VIDEO_DURATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_MOBILE_NETWORK_GENERATION"] = 21] = "REALTIME_MOBILE_NETWORK_GENERATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_TYPE"] = 22] = "REALTIME_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_METERED"] = 23] = "REALTIME_NETWORK_IS_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_ROAMING"] = 24] = "REALTIME_NETWORK_IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_IS_FIRST_CAPTURE"] = 25] = "CAMERA_IS_FIRST_CAPTURE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PICTURE_MODE"] = 26] = "PICTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_USE_CASE"] = 27] = "BOLT_USE_CASE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CDN_EXPERIMENTATION_ID"] = 28] = "BOLT_CDN_EXPERIMENTATION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_LENS_ACTIVATION"] = 29] = "MINS_SINCE_LAST_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION"] = 30] = "MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_LOGIN_OR_OPEN"] = 31] = "DAYS_SINCE_LAST_LOGIN_OR_OPEN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPECTACLES_VERSION"] = 32] = "SPECTACLES_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STICKY_MAX_CONNECTION_TYPE"] = 33] = "STICKY_MAX_CONNECTION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_ANIMATED_OVERLAY"] = 34] = "WITH_ANIMATED_OVERLAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ESTIMATED_DURATION_FOR_EVENT_MS"] = 35] = "ESTIMATED_DURATION_FOR_EVENT_MS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["URL"] = 36] = "URL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_SOURCE"] = 37] = "MEDIA_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ASSET_TYPE"] = 38] = "ASSET_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_IS_CONTENT_POPULAR"] = 39] = "BOLT_IS_CONTENT_POPULAR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAPTURE_MODE"] = 40] = "CAPTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VP9_SOFTWARE_DECODING_SUPPORTED"] = 41] = "VP9_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SOFTWARE_DECODING_SUPPORTED"] = 42] = "AV1_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_MUSIC"] = 43] = "WITH_MUSIC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FEATURE_PROVIDED_SIZE"] = 44] = "FEATURE_PROVIDED_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE"] = 45] = "MEDIA_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCANNED_CATEGORY_IDS"] = 46] = "SCANNED_CATEGORY_IDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTENT_VIEW_SOURCE"] = 47] = "CONTENT_VIEW_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_HEVC"] = 48] = "RECIPIENTS_SUPPORT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COGNAC_APP_ID"] = 49] = "COGNAC_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_VERIFIED"] = 50] = "EMAIL_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PHONE_VERIFIED"] = 51] = "PHONE_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NOTIFICATION_PERM_GRANTED"] = 52] = "NOTIFICATION_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_GRANTED"] = 53] = "CONTACT_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_COUNT"] = 54] = "MUTUAL_FRIENDS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GROUPS_COUNT"] = 55] = "GROUPS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS"] = 56] = "HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLAYBACK_ITEM_TYPE"] = 57] = "PLAYBACK_ITEM_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_BOOLEAN_PROPERTY"] = 58] = "SUP_BOOLEAN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_INTEGER_PROPERTY"] = 59] = "SUP_INTEGER_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_LONG_PROPERTY"] = 60] = "SUP_LONG_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_STRING_PROPERTY"] = 61] = "SUP_STRING_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_DOUBLE_PROPERTY"] = 62] = "SUP_DOUBLE_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_MILLIS_PROPERTY_TO_NOW"] = 63] = "SUP_MILLIS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USED_SPECTACLES"] = 64] = "HAS_USED_SPECTACLES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_SECS_PROPERTY_TO_NOW"] = 65] = "SUP_SECS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CLIENT_APP_STATE"] = 66] = "BOLT_CLIENT_APP_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_SET"] = 67] = "EMAIL_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BITMOJI_SET"] = 68] = "BITMOJI_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["QUICK_TAP_CAMERA_SUPPORTED_ENABLED"] = 69] = "QUICK_TAP_CAMERA_SUPPORTED_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ADD_FRIENDS_REQUEST"] = 70] = "HAS_ADD_FRIENDS_REQUEST";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_FROM_PUSH"] = 71] = "APP_LAUNCH_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_TYPE"] = 72] = "APP_LAUNCH_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT"] = 73] = "BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 74] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT"] = 75] = "BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_NUM_IN_APP_WARNINGS"] = 76] = "FST_NUM_IN_APP_WARNINGS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_SHOULD_CHANGE_PASSWORD"] = 77] = "FST_SHOULD_CHANGE_PASSWORD";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_IS_BACKGROUND_CHECK"] = 78] = "FST_IS_BACKGROUND_CHECK";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AUDIO_RECORD_PERM_GRANTED"] = 79] = "AUDIO_RECORD_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT"] = 80] = "MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT"] = 81] = "BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USE_VERTICAL_NAVIGATION"] = 82] = "USE_VERTICAL_NAVIGATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FREEABLE_DISK_AVAILABLE"] = 83] = "FREEABLE_DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEMORIES_COUNT"] = 84] = "MEMORIES_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MODEL"] = 85] = "DEVICE_MODEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COUNTRY"] = 86] = "COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS"] = 87] = "OS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS_VERSION"] = 88] = "OS_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_VERSION"] = 89] = "APP_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_FLAVOR"] = 90] = "BUILD_FLAVOR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_ID"] = 91] = "USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LOCALE"] = 92] = "LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_CLUSTER"] = 93] = "DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_BRAND"] = 94] = "DEVICE_BRAND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_EMPLOYEE"] = 95] = "IS_EMPLOYEE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USERNAME"] = 96] = "USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TEST_USER"] = 97] = "IS_TEST_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PROFILE"] = 98] = "USER_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_WIDTH"] = 99] = "SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_HEIGHT"] = 100] = "SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SUPPORT"] = 101] = "HEVC_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_TYPE"] = 102] = "NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_WIDTH"] = 103] = "MAX_VIDEO_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_HEIGHT"] = 104] = "MAX_VIDEO_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_NETWORK_METERED"] = 105] = "IS_NETWORK_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ROAMING"] = 106] = "IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_ENGAGEMENT_LEVEL"] = 107] = "APP_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_ENGAGEMENT_LEVEL"] = 108] = "COMMUNICATION_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FRIEND_STORY_ENGAGEMENT_LEVEL"] = 109] = "FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLIC_USER_STORY_ENGAGEMENT_LEVEL"] = 110] = "PUBLIC_USER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLISHER_STORY_ENGAGEMENT_LEVEL"] = 111] = "PUBLISHER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_ENGAGEMENT_LEVEL"] = 112] = "LENS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NON_FRIEND_STORY_ENGAGEMENT_LEVEL"] = 113] = "NON_FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FOLLOWER_SIZE_LEVEL"] = 114] = "FOLLOWER_SIZE_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION"] = 115] = "DAYS_SINCE_CREATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA"] = 116] = "USER_PERSONA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_CREATION_TIME"] = 117] = "USER_CREATION_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MOBILE_NETWORK_TYPE"] = 118] = "MOBILE_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AGGREGATED_USER_BANDWIDTH"] = 119] = "AGGREGATED_USER_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED"] = 120] = "LENS_CLUSTER_BIASED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_LOG"] = 121] = "LENS_CLUSTER_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG"] = 122] = "LENS_CLUSTER_ORIG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG_4"] = 123] = "LENS_CLUSTER_ORIG_4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED_LOG"] = 124] = "LENS_CLUSTER_BIASED_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LOCALE"] = 125] = "APP_LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_COMMON_NAME"] = 126] = "DEVICE_COMMON_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_FRIEND_COUNT"] = 127] = "USER_FRIEND_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["L90_COUNTRY"] = 128] = "L90_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STUB"] = 129] = "STUB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TRUE"] = 130] = "IS_TRUE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_RATIO"] = 131] = "STORY_POST_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GENDER"] = 132] = "GENDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INFERRED_AGE_BUCKET"] = 133] = "INFERRED_AGE_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORIES"] = 134] = "STORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SENDS"] = 135] = "SENDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_CREATE_L7"] = 136] = "SNAP_CREATE_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_L7"] = 137] = "STORY_POST_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_L7"] = 138] = "COMMUNICATION_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DF_L7"] = 139] = "DF_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_L7"] = 140] = "APP_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION_BUCKET"] = 141] = "DAYS_SINCE_CREATION_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS"] = 142] = "BIDIRECTIONAL_FRIEND_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_PREDICTION"] = 143] = "STORY_POST_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPENS"] = 144] = "APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES"] = 145] = "LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SNAPS"] = 146] = "LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_OPS"] = 147] = "LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_APP_OPENS"] = 148] = "W1_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SWIPES"] = 149] = "W1_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SNAPS"] = 150] = "W1_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_OPS"] = 151] = "W1_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_APP_OPENS"] = 152] = "W2_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SWIPES"] = 153] = "W2_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SNAPS"] = 154] = "W2_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_OPS"] = 155] = "W2_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_APP_OPENS"] = 156] = "W34_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SWIPES"] = 157] = "W34_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SNAPS"] = 158] = "W34_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_OPS"] = 159] = "W34_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES_PREDICTION"] = 160] = "LENS_SWIPES_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_COUNTRY"] = 161] = "REGISTRATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_ASN"] = 162] = "IP_ASN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_REGION"] = 163] = "IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_CITY"] = 164] = "IP_CITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USER_ID"] = 165] = "HAS_USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BITMOJI"] = 166] = "HAS_BITMOJI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_APP_OPENS_LAST_8_DAYS"] = 167] = "NUM_APP_OPENS_LAST_8_DAYS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_VIEW_DAYS_L7"] = 168] = "NUM_FEATURE_STORY_VIEW_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_SYNC_DAYS_L7"] = 169] = "NUM_FEATURE_STORY_SYNC_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEXAGON_NN_SUPPORTED_VERSION"] = 170] = "HEXAGON_NN_SUPPORTED_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_QUALITY"] = 171] = "NETWORK_QUALITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MEMORY_MB"] = 172] = "DEVICE_MEMORY_MB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_GL_VERSION"] = 173] = "DEVICE_GL_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRO_STATUS"] = 174] = "SNAP_PRO_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_VP9_DECODING_SUPPORT"] = 175] = "DEVICE_VP9_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AVG_FRIEND_STORY_VIEW_COUNT_L7"] = 176] = "AVG_FRIEND_STORY_VIEW_COUNT_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_JOIN_TIME"] = 177] = "GAME_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_LAST_ACTIVE_TIME"] = 178] = "GAME_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_GAME_ACTIVITY"] = 179] = "DAYS_SINCE_FIRST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_GAME_ACTIVITY"] = 180] = "DAYS_SINCE_LAST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PF_PAGE_SESSIONS_WITH_LONG_IMP"] = 181] = "PF_PAGE_SESSIONS_WITH_LONG_IMP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WIRELESS_CARRIER"] = 182] = "WIRELESS_CARRIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_JOIN_TIME"] = 183] = "MINIS_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_LAST_ACTIVE_TIME"] = 184] = "MINIS_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_MINIS_ACTIVITY"] = 185] = "DAYS_SINCE_FIRST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_MINIS_ACTIVITY"] = 186] = "DAYS_SINCE_LAST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_AV1_DECODING_SUPPORT"] = 187] = "DEVICE_AV1_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_PACKAGE_INSTALLER"] = 188] = "APP_PACKAGE_INSTALLER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL"] = 189] = "STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REPORTED_AGE"] = 190] = "REPORTED_AGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ANDROID_MOBILE_SERVICES_PROVIDER"] = 191] = "ANDROID_MOBILE_SERVICES_PROVIDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACQUIRED_USER"] = 192] = "IS_ACQUIRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["YDPI"] = 193] = "YDPI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS_VELLUM"] = 194] = "BIDIRECTIONAL_FRIEND_STATUS_VELLUM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORIGIN"] = 195] = "ORIGIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENSCORE_VERSION"] = 196] = "LENSCORE_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPKIT_APP_ID"] = 197] = "SNAPKIT_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GPU"] = 198] = "GPU";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_NAME"] = 199] = "CHIPSET_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_VERSION"] = 200] = "CHIPSET_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ZERO_IDFA"] = 201] = "HAS_ZERO_IDFA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LIMIT_AD_TRACKING"] = 202] = "LIMIT_AD_TRACKING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATT_AUTH_STATUS"] = 203] = "ATT_AUTH_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_FRONT_SS_GAIN_OVER_TPA"] = 204] = "CAMERA2_FRONT_SS_GAIN_OVER_TPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATTACHMENT_TOOL_V2"] = 205] = "ATTACHMENT_TOOL_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA_V3"] = 206] = "USER_PERSONA_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITH_HEVC"] = 207] = "SNAPS_SEND_WITH_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITHOUT_HEVC"] = 208] = "SNAPS_SEND_WITHOUT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_NATIVE_CRASH_OVER_CAMERA1"] = 209] = "CAMERA2_NATIVE_CRASH_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_G2S_LATENCY_OVER_CAMERA1"] = 210] = "CAMERA2_G2S_LATENCY_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_INTERNAL"] = 211] = "IS_INTERNAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_WEB"] = 212] = "IS_WEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MAP"] = 213] = "APP_OPEN_TO_MAP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_FRIENDSFEED"] = 214] = "APP_OPEN_TO_FRIENDSFEED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_LENSES"] = 215] = "APP_OPEN_TO_LENSES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MEMORIES"] = 216] = "APP_OPEN_TO_MEMORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_COMMUNITY"] = 217] = "APP_OPEN_TO_COMMUNITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_SPOTLIGHT"] = 218] = "APP_OPEN_TO_SPOTLIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_IMPACTED_BY_PINC_893"] = 219] = "IS_IMPACTED_BY_PINC_893";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_BEFORE_BIRTHDAY"] = 220] = "DAYS_BEFORE_BIRTHDAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BIPA"] = 221] = "HAS_BIPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_ENGAGEMENT_STATUS"] = 222] = "SPOTLIGHT_STORY_ENGAGEMENT_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INCLUSION_PANEL_MEMBER"] = 223] = "INCLUSION_PANEL_MEMBER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_HW_DECODER"] = 224] = "HEVC_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SW_DECODER"] = 225] = "HEVC_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HASH_MURMUR3_128_MOD_100"] = 226] = "HASH_MURMUR3_128_MOD_100";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ACTIVE_SNAPCHAT_PLUS"] = 227] = "HAS_ACTIVE_SNAPCHAT_PLUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_KIT_OAUTH_ID"] = 228] = "SNAP_KIT_OAUTH_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_TYPE"] = 229] = "ORGANIZATION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHUNK_UPLOAD_SUPPORT_REQUIRED"] = 230] = "CHUNK_UPLOAD_SUPPORT_REQUIRED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CLOUDFRONT_POP"] = 231] = "CLOUDFRONT_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 232] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT"] = 233] = "BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT"] = 234] = "BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 235] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH"] = 236] = "FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_WIDTH"] = 237] = "WEB_SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_HEIGHT"] = 238] = "WEB_SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED"] = 239] = "SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRIVACY"] = 240] = "SNAP_PRIVACY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADS_INTERFACES_IS_NEW_ORGANIZATION"] = 241] = "ADS_INTERFACES_IS_NEW_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SERVER_ONLY"] = 242] = "SERVER_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_ORGANIZATION"] = 243] = "GHE_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_REPOSITORY"] = 244] = "GHE_REPOSITORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_USER_EMAIL"] = 245] = "GHE_USER_EMAIL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_ID"] = 246] = "BUILD_DEFINITION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_NAME"] = 247] = "BUILD_DEFINITION_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LCA_PRINCIPAL"] = 248] = "LCA_PRINCIPAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_PERFORMANCE_CLASS"] = 249] = "MEDIA_PERFORMANCE_CLASS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNITY_COUNT"] = 250] = "COMMUNITY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_FMP4"] = 251] = "RECIPIENTS_SUPPORT_FMP4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_ASPECT_RATIO"] = 252] = "SCREEN_ASPECT_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_GROUP"] = 253] = "USER_GROUP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_HAS_DENIED_CAMERA_PERM"] = 254] = "USER_HAS_DENIED_CAMERA_PERM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMEOS_ENGAGEMENT_LEVEL"] = 255] = "CAMEOS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CAMEOS"] = 256] = "HAS_CAMEOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACTIVE_LENS_VIDEO_CHAT_USER"] = 257] = "IS_ACTIVE_LENS_VIDEO_CHAT_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_SPOTLIGHT_POSTS_L7"] = 258] = "NUM_SPOTLIGHT_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_MAP_POSTS_L7"] = 259] = "NUM_MAP_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CREATED_PUBLIC_PROFILE"] = 260] = "HAS_CREATED_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE"] = 261] = "HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_CAMERA_PERM_DENY"] = 262] = "DAYS_SINCE_LAST_CAMERA_PERM_DENY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_AD_ORG_JOIN"] = 263] = "DAYS_SINCE_AD_ORG_JOIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_CREATE"] = 264] = "DAYS_SINCE_FIRST_AD_CREATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_COUNTRY"] = 265] = "ORGANIZATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_DWEB_VISIT"] = 266] = "DAYS_SINCE_FIRST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_DWEB_VISIT"] = 267] = "DAYS_SINCE_LAST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEEKS_SINCE_USING_DWEB"] = 268] = "WEEKS_SINCE_USING_DWEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_LENS"] = 269] = "HAS_LENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_IMPRESSION_COUNT"] = 270] = "BILLBOARD_SERVER_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CLICK_COUNT"] = 271] = "BILLBOARD_SERVER_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_DISMISS_COUNT"] = 272] = "BILLBOARD_SERVER_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_INTERACTION_COUNT"] = 273] = "BILLBOARD_SERVER_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 274] = "BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 275] = "BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW"] = 276] = "BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW"] = 277] = "BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 278] = "BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW"] = 279] = "BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 280] = "BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 281] = "BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT"] = 282] = "BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW"] = 283] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW"] = 284] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 285] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW"] = 286] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 287] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_SPEND"] = 288] = "DAYS_SINCE_FIRST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_AD_SPEND"] = 289] = "DAYS_SINCE_LAST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 290] = "SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 291] = "SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED"] = 292] = "SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LAST_USER_ACCEPTED_TOS"] = 293] = "LAST_USER_ACCEPTED_TOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPDATED_DEVICE_CLUSTER"] = 294] = "UPDATED_DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CREATOR_TIER"] = 295] = "CREATOR_TIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SW_DECODER"] = 296] = "AV1_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_HW_DECODER"] = 297] = "AV1_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_EXPLICIT_PUBLIC_PROFILE"] = 298] = "HAS_EXPLICIT_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LARGER_TEXT_DISPLAY_OPTION_ENABLED"] = 299] = "LARGER_TEXT_DISPLAY_OPTION_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_POSTING_PREFERRED_USER"] = 300] = "IS_PUBLIC_POSTING_PREFERRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID"] = 301] = "RUID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTABLE_USERNAME"] = 302] = "MUTABLE_USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUDGET_GROUP_ID"] = 303] = "BUDGET_GROUP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_POPULATION_RANGE_HASH_FUNC"] = 304] = "AB_POPULATION_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_TREATMENT_RANGE_HASH_FUNC"] = 305] = "AB_TREATMENT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_IP_REGION"] = 306] = "REGISTRATION_IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID_TYPE"] = 307] = "RUID_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLUS_INTERNAL_ONLY"] = 308] = "PLUS_INTERNAL_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COF_ROLLOUT_RANGE_HASH_FUNC"] = 309] = "COF_ROLLOUT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_AI_SELFIE"] = 341] = "HAS_AI_SELFIE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_DREAMS"] = 342] = "HAS_DREAMS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_ACTIVITY"] = 343] = "DAYS_SINCE_LAST_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_OS_GRANTED"] = 344] = "CONTACT_PERM_OS_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_USER_GRANTED"] = 345] = "CONTACT_PERM_USER_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_GPU_V2"] = 346] = "LENS_CLUSTER_GPU_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAN_ACCESS_ADS_TAB"] = 347] = "CAN_ACCESS_ADS_TAB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GOOGLE_CDN_POP"] = 348] = "GOOGLE_CDN_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_STRONG_RELATIONSHIPS_V3"] = 349] = "NUM_STRONG_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_CLOSE_PLUS_RELATIONSHIPS_V3"] = 350] = "NUM_CLOSE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3"] = 351] = "NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Property || (ClientTargetingExpression_Property = {}));
var ClientTargetingExpression_PropertyMetadata_SignalToHash;
(function(ClientTargetingExpression_PropertyMetadata_SignalToHash2) {
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNKNOWN_SIGNAL_TO_HASH"] = 0] = "UNKNOWN_SIGNAL_TO_HASH";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_SEED_AND_USER_ID"] = 1] = "HASH_SEED_AND_USER_ID";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_USER_ID_AND_NAMESPACE"] = 2] = "HASH_USER_ID_AND_NAMESPACE";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PropertyMetadata_SignalToHash || (ClientTargetingExpression_PropertyMetadata_SignalToHash = {}));
function createBaseConfigResult() {
  return {
    configId: "",
    value: void 0,
    targetingExpression: void 0,
    ttlSeconds: 0,
    configRuleUuidBytes: new Uint8Array(),
    priority: 0,
    namespace: 0,
    studyName: "",
    experimentId: 0,
    delete: false,
    servePlatforms: [],
    sequenceId: 0,
    ruidType: 0,
    segmentOrdinal: 0,
    generatedFromAbAllowlists: false,
    internalFields: void 0
  };
}
var ConfigResult = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.configId !== "") {
      writer.uint32(10).string(message.configId);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(26).fork()).ldelim();
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(32).int64(message.ttlSeconds);
    }
    if (message.configRuleUuidBytes.length !== 0) {
      writer.uint32(42).bytes(message.configRuleUuidBytes);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.namespace !== 0) {
      writer.uint32(56).int32(message.namespace);
    }
    if (message.studyName !== "") {
      writer.uint32(66).string(message.studyName);
    }
    if (message.experimentId !== 0) {
      writer.uint32(72).int32(message.experimentId);
    }
    if (message.delete === true) {
      writer.uint32(80).bool(message.delete);
    }
    writer.uint32(90).fork();
    for (const v2 of message.servePlatforms) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.sequenceId !== 0) {
      writer.uint32(96).int32(message.sequenceId);
    }
    if (message.ruidType !== 0) {
      writer.uint32(104).int32(message.ruidType);
    }
    if (message.segmentOrdinal !== 0) {
      writer.uint32(112).int32(message.segmentOrdinal);
    }
    if (message.generatedFromAbAllowlists === true) {
      writer.uint32(120).bool(message.generatedFromAbAllowlists);
    }
    if (message.internalFields !== void 0) {
      ConfigResult_InternalFields.encode(message.internalFields, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configId = reader.string();
          break;
        case 2:
          message.value = Value.decode(reader, reader.uint32());
          break;
        case 3:
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          break;
        case 4:
          message.ttlSeconds = longToNumber5(reader.int64());
          break;
        case 5:
          message.configRuleUuidBytes = reader.bytes();
          break;
        case 6:
          message.priority = reader.int32();
          break;
        case 7:
          message.namespace = reader.int32();
          break;
        case 8:
          message.studyName = reader.string();
          break;
        case 9:
          message.experimentId = reader.int32();
          break;
        case 10:
          message.delete = reader.bool();
          break;
        case 11:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.servePlatforms.push(reader.int32());
            }
          } else {
            message.servePlatforms.push(reader.int32());
          }
          break;
        case 12:
          message.sequenceId = reader.int32();
          break;
        case 13:
          message.ruidType = reader.int32();
          break;
        case 14:
          message.segmentOrdinal = reader.int32();
          break;
        case 15:
          message.generatedFromAbAllowlists = reader.bool();
          break;
        case 16:
          message.internalFields = ConfigResult_InternalFields.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const message = createBaseConfigResult();
    message.configId = (_a = object.configId) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.ttlSeconds = (_b = object.ttlSeconds) !== null && _b !== void 0 ? _b : 0;
    message.configRuleUuidBytes = (_c = object.configRuleUuidBytes) !== null && _c !== void 0 ? _c : new Uint8Array();
    message.priority = (_d = object.priority) !== null && _d !== void 0 ? _d : 0;
    message.namespace = (_e = object.namespace) !== null && _e !== void 0 ? _e : 0;
    message.studyName = (_f = object.studyName) !== null && _f !== void 0 ? _f : "";
    message.experimentId = (_g = object.experimentId) !== null && _g !== void 0 ? _g : 0;
    message.delete = (_h = object.delete) !== null && _h !== void 0 ? _h : false;
    message.servePlatforms = ((_j = object.servePlatforms) === null || _j === void 0 ? void 0 : _j.map((e2) => e2)) || [];
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : 0;
    message.ruidType = (_l = object.ruidType) !== null && _l !== void 0 ? _l : 0;
    message.segmentOrdinal = (_m = object.segmentOrdinal) !== null && _m !== void 0 ? _m : 0;
    message.generatedFromAbAllowlists = (_o = object.generatedFromAbAllowlists) !== null && _o !== void 0 ? _o : false;
    message.internalFields = object.internalFields !== void 0 && object.internalFields !== null ? ConfigResult_InternalFields.fromPartial(object.internalFields) : void 0;
    return message;
  }
};
function createBaseConfigResult_InternalFields() {
  return {
    configBitmapIndex: 0,
    configResultBitmapIndex: 0,
    hasServerPropertiesOnly: false,
    globalPriority: 0,
    sequenceIds: [],
    studySegmentOrdinal: 0,
    experimentGuid: 0,
    isAbStudyStatusCompleted: false
  };
}
var ConfigResult_InternalFields = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.configBitmapIndex !== 0) {
      writer.uint32(8).int32(message.configBitmapIndex);
    }
    if (message.configResultBitmapIndex !== 0) {
      writer.uint32(16).int32(message.configResultBitmapIndex);
    }
    if (message.hasServerPropertiesOnly === true) {
      writer.uint32(24).bool(message.hasServerPropertiesOnly);
    }
    if (message.globalPriority !== 0) {
      writer.uint32(32).int32(message.globalPriority);
    }
    for (const v2 of message.sequenceIds) {
      ConfigResult_InternalFields_SequenceIdCandidate.encode(v2, writer.uint32(42).fork()).ldelim();
    }
    if (message.studySegmentOrdinal !== 0) {
      writer.uint32(48).int32(message.studySegmentOrdinal);
    }
    if (message.experimentGuid !== 0) {
      writer.uint32(56).uint64(message.experimentGuid);
    }
    if (message.isAbStudyStatusCompleted === true) {
      writer.uint32(64).bool(message.isAbStudyStatusCompleted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configBitmapIndex = reader.int32();
          break;
        case 2:
          message.configResultBitmapIndex = reader.int32();
          break;
        case 3:
          message.hasServerPropertiesOnly = reader.bool();
          break;
        case 4:
          message.globalPriority = reader.int32();
          break;
        case 5:
          message.sequenceIds.push(ConfigResult_InternalFields_SequenceIdCandidate.decode(reader, reader.uint32()));
          break;
        case 6:
          message.studySegmentOrdinal = reader.int32();
          break;
        case 7:
          message.experimentGuid = longToNumber5(reader.uint64());
          break;
        case 8:
          message.isAbStudyStatusCompleted = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseConfigResult_InternalFields();
    message.configBitmapIndex = (_a = object.configBitmapIndex) !== null && _a !== void 0 ? _a : 0;
    message.configResultBitmapIndex = (_b = object.configResultBitmapIndex) !== null && _b !== void 0 ? _b : 0;
    message.hasServerPropertiesOnly = (_c = object.hasServerPropertiesOnly) !== null && _c !== void 0 ? _c : false;
    message.globalPriority = (_d = object.globalPriority) !== null && _d !== void 0 ? _d : 0;
    message.sequenceIds = ((_e = object.sequenceIds) === null || _e === void 0 ? void 0 : _e.map((e2) => ConfigResult_InternalFields_SequenceIdCandidate.fromPartial(e2))) || [];
    message.studySegmentOrdinal = (_f = object.studySegmentOrdinal) !== null && _f !== void 0 ? _f : 0;
    message.experimentGuid = (_g = object.experimentGuid) !== null && _g !== void 0 ? _g : 0;
    message.isAbStudyStatusCompleted = (_h = object.isAbStudyStatusCompleted) !== null && _h !== void 0 ? _h : false;
    return message;
  }
};
function createBaseConfigResult_InternalFields_SequenceIdCandidate() {
  return { targetingExpression: void 0, sequenceId: 0 };
}
var ConfigResult_InternalFields_SequenceIdCandidate = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(10).fork()).ldelim();
    }
    if (message.sequenceId !== 0) {
      writer.uint32(16).int32(message.sequenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          break;
        case 2:
          message.sequenceId = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
function createBaseClientTargetingExpression() {
  return {
    operator: 0,
    children: [],
    property: 0,
    predicateOperator: 0,
    value: void 0,
    propertyMetadata: void 0
  };
}
var ClientTargetingExpression = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    for (const v2 of message.children) {
      ClientTargetingExpression.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    if (message.property !== 0) {
      writer.uint32(24).int32(message.property);
    }
    if (message.predicateOperator !== 0) {
      writer.uint32(32).int32(message.predicateOperator);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(42).fork()).ldelim();
    }
    if (message.propertyMetadata !== void 0) {
      ClientTargetingExpression_PropertyMetadata.encode(message.propertyMetadata, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.operator = reader.int32();
          break;
        case 2:
          message.children.push(ClientTargetingExpression.decode(reader, reader.uint32()));
          break;
        case 3:
          message.property = reader.int32();
          break;
        case 4:
          message.predicateOperator = reader.int32();
          break;
        case 5:
          message.value = Value.decode(reader, reader.uint32());
          break;
        case 6:
          message.propertyMetadata = ClientTargetingExpression_PropertyMetadata.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseClientTargetingExpression();
    message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : 0;
    message.children = ((_b = object.children) === null || _b === void 0 ? void 0 : _b.map((e2) => ClientTargetingExpression.fromPartial(e2))) || [];
    message.property = (_c = object.property) !== null && _c !== void 0 ? _c : 0;
    message.predicateOperator = (_d = object.predicateOperator) !== null && _d !== void 0 ? _d : 0;
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.propertyMetadata = object.propertyMetadata !== void 0 && object.propertyMetadata !== null ? ClientTargetingExpression_PropertyMetadata.fromPartial(object.propertyMetadata) : void 0;
    return message;
  }
};
function createBaseClientTargetingExpression_PropertyMetadata() {
  return {
    itemId: 0,
    signalToHash: 0,
    abNamespaceForHashing: "",
    abSeedForHashing: "",
    ruidType: void 0,
    cofRolloutSeedForHashing: ""
  };
}
var ClientTargetingExpression_PropertyMetadata = {
  encode(message, writer = import_minimal13.default.Writer.create()) {
    if (message.itemId !== 0) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.signalToHash !== 0) {
      writer.uint32(16).int32(message.signalToHash);
    }
    if (message.abNamespaceForHashing !== "") {
      writer.uint32(26).string(message.abNamespaceForHashing);
    }
    if (message.abSeedForHashing !== "") {
      writer.uint32(34).string(message.abSeedForHashing);
    }
    if (message.ruidType !== void 0) {
      writer.uint32(40).int32(message.ruidType);
    }
    if (message.cofRolloutSeedForHashing !== "") {
      writer.uint32(50).string(message.cofRolloutSeedForHashing);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal13.default.Reader ? input : new import_minimal13.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.int32();
          break;
        case 2:
          message.signalToHash = reader.int32();
          break;
        case 3:
          message.abNamespaceForHashing = reader.string();
          break;
        case 4:
          message.abSeedForHashing = reader.string();
          break;
        case 5:
          message.ruidType = reader.int32();
          break;
        case 6:
          message.cofRolloutSeedForHashing = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : 0;
    message.signalToHash = (_b = object.signalToHash) !== null && _b !== void 0 ? _b : 0;
    message.abNamespaceForHashing = (_c = object.abNamespaceForHashing) !== null && _c !== void 0 ? _c : "";
    message.abSeedForHashing = (_d = object.abSeedForHashing) !== null && _d !== void 0 ? _d : "";
    message.ruidType = (_e = object.ruidType) !== null && _e !== void 0 ? _e : void 0;
    message.cofRolloutSeedForHashing = (_f = object.cofRolloutSeedForHashing) !== null && _f !== void 0 ? _f : "";
    return message;
  }
};
var globalThis9 = (() => {
  if (typeof globalThis9 !== "undefined")
    return globalThis9;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function longToNumber5(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis9.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal13.default.util.Long !== import_long13.default) {
  import_minimal13.default.util.Long = import_long13.default;
  import_minimal13.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/config_response.js
function createBaseConfigTargetingResponseDebugData() {
  return { abResultChecksumInput: "" };
}
var ConfigTargetingResponseDebugData = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    if (message.abResultChecksumInput !== "") {
      writer.uint32(10).string(message.abResultChecksumInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponseDebugData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.abResultChecksumInput = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigTargetingResponseDebugData();
    message.abResultChecksumInput = (_a = object.abResultChecksumInput) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseConfigTargetingResponse() {
  return {
    configResults: [],
    configResultsEtag: "",
    benchmarkRequest: void 0,
    fullResults: false,
    abResultChecksum: 0,
    iso3166Alpha2CountryCodeFromRequestIp: "",
    debugData: void 0
  };
}
var ConfigTargetingResponse = {
  encode(message, writer = import_minimal14.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.configResultsEtag !== "") {
      writer.uint32(18).string(message.configResultsEtag);
    }
    if (message.benchmarkRequest !== void 0) {
      BenchmarkRequest.encode(message.benchmarkRequest, writer.uint32(26).fork()).ldelim();
    }
    if (message.fullResults === true) {
      writer.uint32(32).bool(message.fullResults);
    }
    if (message.abResultChecksum !== 0) {
      writer.uint32(40).int32(message.abResultChecksum);
    }
    if (message.iso3166Alpha2CountryCodeFromRequestIp !== "") {
      writer.uint32(50).string(message.iso3166Alpha2CountryCodeFromRequestIp);
    }
    if (message.debugData !== void 0) {
      ConfigTargetingResponseDebugData.encode(message.debugData, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal14.default.Reader ? input : new import_minimal14.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        case 2:
          message.configResultsEtag = reader.string();
          break;
        case 3:
          message.benchmarkRequest = BenchmarkRequest.decode(reader, reader.uint32());
          break;
        case 4:
          message.fullResults = reader.bool();
          break;
        case 5:
          message.abResultChecksum = reader.int32();
          break;
        case 6:
          message.iso3166Alpha2CountryCodeFromRequestIp = reader.string();
          break;
        case 7:
          message.debugData = ConfigTargetingResponseDebugData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseConfigTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.configResultsEtag = (_b = object.configResultsEtag) !== null && _b !== void 0 ? _b : "";
    message.benchmarkRequest = object.benchmarkRequest !== void 0 && object.benchmarkRequest !== null ? BenchmarkRequest.fromPartial(object.benchmarkRequest) : void 0;
    message.fullResults = (_c = object.fullResults) !== null && _c !== void 0 ? _c : false;
    message.abResultChecksum = (_d = object.abResultChecksum) !== null && _d !== void 0 ? _d : 0;
    message.iso3166Alpha2CountryCodeFromRequestIp = (_e = object.iso3166Alpha2CountryCodeFromRequestIp) !== null && _e !== void 0 ? _e : "";
    message.debugData = object.debugData !== void 0 && object.debugData !== null ? ConfigTargetingResponseDebugData.fromPartial(object.debugData) : void 0;
    return message;
  }
};
if (import_minimal14.default.util.Long !== import_long14.default) {
  import_minimal14.default.util.Long = import_long14.default;
  import_minimal14.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/circumstance_service.js
var import_browser_headers = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/debug_info.js
var import_long15 = __toESM(require_long());
var import_minimal15 = __toESM(require_minimal2());
var AbStep;
(function(AbStep2) {
  AbStep2[AbStep2["USER_WHITELISTED"] = 0] = "USER_WHITELISTED";
  AbStep2[AbStep2["USER_GROUP_WHITELISTED"] = 1] = "USER_GROUP_WHITELISTED";
  AbStep2[AbStep2["FILTER_CONDITIONS"] = 2] = "FILTER_CONDITIONS";
  AbStep2[AbStep2["SLICE_RANGE"] = 3] = "SLICE_RANGE";
  AbStep2[AbStep2["TRAFFIC_ALLOCATED"] = 4] = "TRAFFIC_ALLOCATED";
  AbStep2[AbStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AbStep || (AbStep = {}));
var CofStep;
(function(CofStep2) {
  CofStep2[CofStep2["VALIDATE_REQUEST"] = 0] = "VALIDATE_REQUEST";
  CofStep2[CofStep2["REQUEST_ATLAS"] = 1] = "REQUEST_ATLAS";
  CofStep2[CofStep2["BUILD_TARGETING_INFO"] = 2] = "BUILD_TARGETING_INFO";
  CofStep2[CofStep2["QUERY_INDEX"] = 3] = "QUERY_INDEX";
  CofStep2[CofStep2["REQUEST_AB"] = 4] = "REQUEST_AB";
  CofStep2[CofStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CofStep || (CofStep = {}));
function createBaseAbStepInfo() {
  return { abStep: 0, info: "" };
}
var AbStepInfo = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.abStep !== 0) {
      writer.uint32(8).int32(message.abStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAbStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.abStep = reader.int32();
          break;
        case 2:
          message.info = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAbStepInfo();
    message.abStep = (_a = object.abStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseCofStepInfo() {
  return { cofStep: 0, info: "" };
}
var CofStepInfo = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.cofStep !== 0) {
      writer.uint32(8).int32(message.cofStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCofStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cofStep = reader.int32();
          break;
        case 2:
          message.info = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCofStepInfo();
    message.cofStep = (_a = object.cofStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseDebugTrace() {
  return { lastCofStep: void 0, lastAbStep: void 0, budgetGroupId: 0 };
}
var DebugTrace = {
  encode(message, writer = import_minimal15.default.Writer.create()) {
    if (message.lastCofStep !== void 0) {
      CofStepInfo.encode(message.lastCofStep, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastAbStep !== void 0) {
      AbStepInfo.encode(message.lastAbStep, writer.uint32(18).fork()).ldelim();
    }
    if (message.budgetGroupId !== 0) {
      writer.uint32(24).uint32(message.budgetGroupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal15.default.Reader ? input : new import_minimal15.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDebugTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastCofStep = CofStepInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.lastAbStep = AbStepInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.budgetGroupId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseDebugTrace();
    message.lastCofStep = object.lastCofStep !== void 0 && object.lastCofStep !== null ? CofStepInfo.fromPartial(object.lastCofStep) : void 0;
    message.lastAbStep = object.lastAbStep !== void 0 && object.lastAbStep !== null ? AbStepInfo.fromPartial(object.lastAbStep) : void 0;
    message.budgetGroupId = (_a = object.budgetGroupId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
if (import_minimal15.default.util.Long !== import_long15.default) {
  import_minimal15.default.util.Long = import_long15.default;
  import_minimal15.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/cdp/cof/circumstance_service.js
function createBaseGetAbConfigValuesRequest() {
  return {
    configNames: [],
    namespaces: [],
    cofConfigNames: [],
    includeAllConfigs: false,
    disableExposureLogging: false,
    enableDebug: false
  };
}
var GetAbConfigValuesRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configNames) {
      writer.uint32(10).string(v2);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    for (const v2 of message.cofConfigNames) {
      writer.uint32(26).string(v2);
    }
    if (message.includeAllConfigs === true) {
      writer.uint32(32).bool(message.includeAllConfigs);
    }
    if (message.disableExposureLogging === true) {
      writer.uint32(40).bool(message.disableExposureLogging);
    }
    if (message.enableDebug === true) {
      writer.uint32(104).bool(message.enableDebug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configNames.push(reader.string());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 3:
          message.cofConfigNames.push(reader.string());
          break;
        case 4:
          message.includeAllConfigs = reader.bool();
          break;
        case 5:
          message.disableExposureLogging = reader.bool();
          break;
        case 13:
          message.enableDebug = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseGetAbConfigValuesRequest();
    message.configNames = ((_a = object.configNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.cofConfigNames = ((_c = object.cofConfigNames) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.includeAllConfigs = (_d = object.includeAllConfigs) !== null && _d !== void 0 ? _d : false;
    message.disableExposureLogging = (_e = object.disableExposureLogging) !== null && _e !== void 0 ? _e : false;
    message.enableDebug = (_f = object.enableDebug) !== null && _f !== void 0 ? _f : false;
    return message;
  }
};
function createBaseGetAbConfigValuesResponse() {
  return { configResults: [], debugTrace: void 0 };
}
var GetAbConfigValuesResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.debugTrace !== void 0) {
      DebugTrace.encode(message.debugTrace, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        case 2:
          message.debugTrace = DebugTrace.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetAbConfigValuesResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.debugTrace = object.debugTrace !== void 0 && object.debugTrace !== null ? DebugTrace.fromPartial(object.debugTrace) : void 0;
    return message;
  }
};
function createBaseConfigSetGenerationRequest() {
  return { targetingParameters: void 0, overrides: [] };
}
var ConfigSetGenerationRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.targetingParameters !== void 0) {
      ConfigTargetingRequest.encode(message.targetingParameters, writer.uint32(10).fork()).ldelim();
    }
    for (const v2 of message.overrides) {
      ConfigResult.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingParameters = ConfigTargetingRequest.decode(reader, reader.uint32());
          break;
        case 2:
          message.overrides.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigSetGenerationRequest();
    message.targetingParameters = object.targetingParameters !== void 0 && object.targetingParameters !== null ? ConfigTargetingRequest.fromPartial(object.targetingParameters) : void 0;
    message.overrides = ((_a = object.overrides) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseConfigSetGenerationResponse() {
  return { targetingResponse: void 0 };
}
var ConfigSetGenerationResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.targetingResponse !== void 0) {
      ConfigTargetingResponse.encode(message.targetingResponse, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.targetingResponse = ConfigTargetingResponse.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    const message = createBaseConfigSetGenerationResponse();
    message.targetingResponse = object.targetingResponse !== void 0 && object.targetingResponse !== null ? ConfigTargetingResponse.fromPartial(object.targetingResponse) : void 0;
    return message;
  }
};
function createBasePinConfigRequest() {
  return { configSetToken: "", userId: "", ttlSeconds: 0 };
}
var PinConfigRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(24).int32(message.ttlSeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configSetToken = reader.string();
          break;
        case 2:
          message.userId = reader.string();
          break;
        case 3:
          message.ttlSeconds = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    message.ttlSeconds = (_c = object.ttlSeconds) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBasePinConfigResponse() {
  return { debug: "" };
}
var PinConfigResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.debug = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBasePinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseUnpinConfigRequest() {
  return { configSetToken: "", userId: "" };
}
var UnpinConfigRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configSetToken = reader.string();
          break;
        case 2:
          message.userId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUnpinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseUnpinConfigResponse() {
  return { debug: "" };
}
var UnpinConfigResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.debug = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUnpinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseConfigWithNamespace() {
  return { configName: "", namespace: 0 };
}
var ConfigWithNamespace = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.configName !== "") {
      writer.uint32(10).string(message.configName);
    }
    if (message.namespace !== 0) {
      writer.uint32(16).int32(message.namespace);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigWithNamespace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configName = reader.string();
          break;
        case 2:
          message.namespace = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseConfigWithNamespace();
    message.configName = (_a = object.configName) !== null && _a !== void 0 ? _a : "";
    message.namespace = (_b = object.namespace) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseGetConfigValuesByTokenRequest() {
  return { token: "", configNames: [], namespaces: [], disableExposureLogging: false, getAllConfigs: false };
}
var GetConfigValuesByTokenRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    for (const v2 of message.configNames) {
      ConfigWithNamespace.encode(v2, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.disableExposureLogging === true) {
      writer.uint32(32).bool(message.disableExposureLogging);
    }
    if (message.getAllConfigs === true) {
      writer.uint32(40).bool(message.getAllConfigs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          message.configNames.push(ConfigWithNamespace.decode(reader, reader.uint32()));
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 4:
          message.disableExposureLogging = reader.bool();
          break;
        case 5:
          message.getAllConfigs = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseGetConfigValuesByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => ConfigWithNamespace.fromPartial(e2))) || [];
    message.namespaces = ((_c = object.namespaces) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.disableExposureLogging = (_d = object.disableExposureLogging) !== null && _d !== void 0 ? _d : false;
    message.getAllConfigs = (_e = object.getAllConfigs) !== null && _e !== void 0 ? _e : false;
    return message;
  }
};
function createBaseGetConfigValuesByTokenResponse() {
  return { configResults: [] };
}
var GetConfigValuesByTokenResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigValuesByTokenResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsRequest() {
  return {};
}
var GetCachedConfigResultSequenceIdsRequest = {
  encode(_, writer = import_minimal16.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsResponse() {
  return { serializedBitmap: new Uint8Array() };
}
var GetCachedConfigResultSequenceIdsResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.serializedBitmap.length !== 0) {
      writer.uint32(10).bytes(message.serializedBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.serializedBitmap = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    message.serializedBitmap = (_a = object.serializedBitmap) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsRequest() {
  return { sequenceIds: [] };
}
var GetConfigResultsBySequenceIdsRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.sequenceIds) {
      writer.int32(v2);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sequenceIds.push(reader.int32());
            }
          } else {
            message.sequenceIds.push(reader.int32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    message.sequenceIds = ((_a = object.sequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseConfigResultWithSequenceId() {
  return { sequenceId: 0, configResult: void 0 };
}
var ConfigResultWithSequenceId = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.sequenceId !== 0) {
      writer.uint32(8).int32(message.sequenceId);
    }
    if (message.configResult !== void 0) {
      ConfigResult.encode(message.configResult, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResultWithSequenceId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sequenceId = reader.int32();
          break;
        case 2:
          message.configResult = ConfigResult.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResultWithSequenceId();
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    message.configResult = object.configResult !== void 0 && object.configResult !== null ? ConfigResult.fromPartial(object.configResult) : void 0;
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsResponse() {
  return { configResultWithSequenceIds: [] };
}
var GetConfigResultsBySequenceIdsResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configResultWithSequenceIds) {
      ConfigResultWithSequenceId.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResultWithSequenceIds.push(ConfigResultWithSequenceId.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    message.configResultWithSequenceIds = ((_a = object.configResultWithSequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResultWithSequenceId.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetBitmapByTokenRequest() {
  return { token: "" };
}
var GetBitmapByTokenRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseGetBitmapByTokenResponse() {
  return { idBitmap: new Uint8Array() };
}
var GetBitmapByTokenResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    if (message.idBitmap.length !== 0) {
      writer.uint32(10).bytes(message.idBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.idBitmap = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenResponse();
    message.idBitmap = (_a = object.idBitmap) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest() {
  return { namespaces: [], edgeConfigClientVersion: "" };
}
var GetUnevaluatedConfigResultsWithAbTargetingRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.ldelim();
    if (message.edgeConfigClientVersion !== "") {
      writer.uint32(18).string(message.edgeConfigClientVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
          } else {
            message.namespaces.push(reader.int32());
          }
          break;
        case 2:
          message.edgeConfigClientVersion = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    message.namespaces = ((_a = object.namespaces) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.edgeConfigClientVersion = (_b = object.edgeConfigClientVersion) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse() {
  return { configResults: [] };
}
var GetUnevaluatedConfigResultsWithAbTargetingResponse = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseAddRuidsForDebuggingRequest() {
  return { ruids: [], configNames: [], maxSnapshots: 0 };
}
var AddRuidsForDebuggingRequest = {
  encode(message, writer = import_minimal16.default.Writer.create()) {
    for (const v2 of message.ruids) {
      Ruid.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    for (const v2 of message.configNames) {
      writer.uint32(18).string(v2);
    }
    if (message.maxSnapshots !== 0) {
      writer.uint32(24).int32(message.maxSnapshots);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ruids.push(Ruid.decode(reader, reader.uint32()));
          break;
        case 2:
          message.configNames.push(reader.string());
          break;
        case 3:
          message.maxSnapshots = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseAddRuidsForDebuggingRequest();
    message.ruids = ((_a = object.ruids) === null || _a === void 0 ? void 0 : _a.map((e2) => Ruid.fromPartial(e2))) || [];
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.maxSnapshots = (_c = object.maxSnapshots) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseAddRuidsForDebuggingResponse() {
  return {};
}
var AddRuidsForDebuggingResponse = {
  encode(_, writer = import_minimal16.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal16.default.Reader ? input : new import_minimal16.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(_) {
    const message = createBaseAddRuidsForDebuggingResponse();
    return message;
  }
};
var CircumstancesServiceClientImpl = class {
  constructor(rpc) {
    this.rpc = rpc;
    this.targetingQuery = this.targetingQuery.bind(this);
    this.getAbConfigValues = this.getAbConfigValues.bind(this);
    this.getConfigValuesByToken = this.getConfigValuesByToken.bind(this);
    this.getConfigResultsBySequenceIds = this.getConfigResultsBySequenceIds.bind(this);
    this.getCachedConfigResultSequenceIds = this.getCachedConfigResultSequenceIds.bind(this);
    this.getBitmapByToken = this.getBitmapByToken.bind(this);
    this.generateConfigSet = this.generateConfigSet.bind(this);
    this.pinConfigSet = this.pinConfigSet.bind(this);
    this.unpinConfigSet = this.unpinConfigSet.bind(this);
    this.getUnevaluatedConfigResultsWithAbTargeting = this.getUnevaluatedConfigResultsWithAbTargeting.bind(this);
    this.addRuidsForDebugging = this.addRuidsForDebugging.bind(this);
  }
  targetingQuery(request, metadata) {
    return this.rpc.unary(CircumstancesServicetargetingQueryDesc, ConfigTargetingRequest.fromPartial(request), metadata);
  }
  getAbConfigValues(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetAbConfigValuesDesc, GetAbConfigValuesRequest.fromPartial(request), metadata);
  }
  getConfigValuesByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigValuesByTokenDesc, GetConfigValuesByTokenRequest.fromPartial(request), metadata);
  }
  getConfigResultsBySequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigResultsBySequenceIdsDesc, GetConfigResultsBySequenceIdsRequest.fromPartial(request), metadata);
  }
  getCachedConfigResultSequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetCachedConfigResultSequenceIdsDesc, GetCachedConfigResultSequenceIdsRequest.fromPartial(request), metadata);
  }
  getBitmapByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetBitmapByTokenDesc, GetBitmapByTokenRequest.fromPartial(request), metadata);
  }
  generateConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicegenerateConfigSetDesc, ConfigSetGenerationRequest.fromPartial(request), metadata);
  }
  pinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicepinConfigSetDesc, PinConfigRequest.fromPartial(request), metadata);
  }
  unpinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServiceunpinConfigSetDesc, UnpinConfigRequest.fromPartial(request), metadata);
  }
  getUnevaluatedConfigResultsWithAbTargeting(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc, GetUnevaluatedConfigResultsWithAbTargetingRequest.fromPartial(request), metadata);
  }
  addRuidsForDebugging(request, metadata) {
    return this.rpc.unary(CircumstancesServiceaddRuidsForDebuggingDesc, AddRuidsForDebuggingRequest.fromPartial(request), metadata);
  }
};
var CircumstancesServiceDesc = {
  serviceName: "snapchat.cdp.cof.CircumstancesService"
};
var CircumstancesServicetargetingQueryDesc = {
  methodName: "targetingQuery",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, ConfigTargetingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetAbConfigValuesDesc = {
  methodName: "getAbConfigValues",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetAbConfigValuesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetAbConfigValuesResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetConfigValuesByTokenDesc = {
  methodName: "getConfigValuesByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigValuesByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetConfigValuesByTokenResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetConfigResultsBySequenceIdsDesc = {
  methodName: "getConfigResultsBySequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigResultsBySequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetConfigResultsBySequenceIdsResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetCachedConfigResultSequenceIdsDesc = {
  methodName: "getCachedConfigResultSequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetCachedConfigResultSequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetCachedConfigResultSequenceIdsResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetBitmapByTokenDesc = {
  methodName: "getBitmapByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetBitmapByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetBitmapByTokenResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegenerateConfigSetDesc = {
  methodName: "generateConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigSetGenerationRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, ConfigSetGenerationResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicepinConfigSetDesc = {
  methodName: "pinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, PinConfigResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServiceunpinConfigSetDesc = {
  methodName: "unpinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnpinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, UnpinConfigResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc = {
  methodName: "getUnevaluatedConfigResultsWithAbTargeting",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUnevaluatedConfigResultsWithAbTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, GetUnevaluatedConfigResultsWithAbTargetingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var CircumstancesServiceaddRuidsForDebuggingDesc = {
  methodName: "addRuidsForDebugging",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AddRuidsForDebuggingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return Object.assign(Object.assign({}, AddRuidsForDebuggingResponse.decode(data)), { toObject() {
        return this;
      } });
    }
  }
};
var GrpcWebImpl = class {
  constructor(host, options) {
    this.host = host;
    this.options = options;
  }
  unary(methodDesc, _request, metadata) {
    var _a;
    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
    const maybeCombinedMetadata = metadata && this.options.metadata ? new import_browser_headers.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      import_grpc_web.grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function(response) {
          if (response.status === import_grpc_web.grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new Error(response.statusMessage);
            err.code = response.status;
            err.metadata = response.trailers;
            reject(err);
          }
        }
      });
    });
  }
};
if (import_minimal16.default.util.Long !== import_long16.default) {
  import_minimal16.default.util.Long = import_long16.default;
  import_minimal16.default.configure();
}

// node_modules/@snap/camera-kit/lib/handlers/responseCachingHandler.js
var logger4 = getLogger("responseCachingHandler");
var notFound = (key) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);
var strategyFailed = (key, cause) => new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });
var staleWhileRevalidateStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const cachedResponse = yield cache.retrieve(key);
    if (!cachedResponse)
      throw notFound(key);
    network({ isSideEffect: true }).then((response) => cache.store(key, response)).catch((error) => {
      logger4.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);
    });
    return cachedResponse;
  } catch (cacheError) {
    options === null || options === void 0 ? void 0 : options.reporter.count("cache_miss", 1, /* @__PURE__ */ new Map([["request_type", options.requestType]]));
    try {
      const response = yield network();
      cache.store(key, response).catch((error) => {
        logger4.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);
      });
      logger4.debug(`staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`, cacheError);
      return response;
    } catch (networkError) {
      const error = ensureError(networkError);
      error.cause = cacheError;
      throw strategyFailed(key, error);
    }
  }
});
var createResponseCachingHandler = (cache, resolveKey, strategy) => {
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    const network = (additionalMetadata = {}) => {
      const m2 = Object.assign(Object.assign({}, metadata), additionalMetadata);
      return next(request, m2);
    };
    let key;
    try {
      key = resolveKey(request, metadata);
    } catch (error) {
      logger4.warn("Cache lookup failed because the cache key could not be resolved.", error);
      return network();
    }
    return strategy(key, cache, network);
  });
};

// node_modules/@snap/camera-kit/lib/persistence/ExpiringPersistence.js
var logger5 = getLogger("ExpiringPersistence");
var ExpiringPersistence = class {
  constructor(expiration, persistence) {
    this.expiration = expiration;
    this.persistence = persistence;
    this.removeExpired().catch(() => {
      logger5.warn("Failed to cleanup expired entries on startup.");
    });
  }
  get size() {
    return this.persistence.size;
  }
  retrieve(key) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const [expiry, value] = (_a = yield this.persistence.retrieve(key)) !== null && _a !== void 0 ? _a : [];
      if (value === void 0 || expiry === void 0)
        return void 0;
      if (Date.now() > expiry) {
        yield this.persistence.remove(key).catch((error) => {
          logger5.warn(`Key ${key} is expired, but removing it from persistence failed.`, ensureError(error));
        });
        return void 0;
      }
      return value;
    });
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const now = Date.now();
      return (yield this.persistence.retrieveAll()).filter(([, [expiry]]) => expiry >= now).map(([, v2]) => v2);
    });
  }
  remove(key) {
    return this.persistence.remove(key);
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = yield this.persistence.removeAll();
      return results.map(([, v2]) => v2);
    });
  }
  removeExpired() {
    return __awaiter(this, void 0, void 0, function* () {
      for (const [key, [expiry]] of yield this.persistence.retrieveAll()) {
        if (Date.now() >= expiry) {
          yield this.persistence.remove(key).catch((error) => logger5.warn(`Failed to remove expired key ${key}.`, error));
        }
      }
    });
  }
  store(keyOrValue, maybeValue) {
    const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
    const expiry = Date.now() + this.expiration(value) * 1e3;
    return key === void 0 ? this.persistence.store([expiry, value]) : this.persistence.store(key, [expiry, value]);
  }
};

// node_modules/@snap/camera-kit/lib/persistence/Persistence.js
var isValidKey = (key) => typeof key === "string" || typeof key === "number";

// node_modules/@snap/camera-kit/lib/persistence/IndexedDBPersistence.js
function wrapRequest(request) {
  const p2 = new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
  p2.request = request;
  return p2;
}
function wrapCursorRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => {
      const cursor = request.result;
      if (!cursor)
        resolve({ cursor: null, continue: () => Promise.reject() });
      else
        resolve({
          cursor,
          continue: () => {
            cursor.continue();
            return wrapCursorRequest(request);
          }
        });
    };
    request.onerror = () => reject(request.error);
  });
}
var IndexedDBPersistence = class {
  /**
   * Construct an {@link IndexedDBPersistence} instance corresponding to a given IndexedDB database version.
   *
   * Throws `ConstraintError` if the version number is invalid (e.g. NaN, or less than 1).
   */
  constructor(options) {
    var _a;
    this.databaseName = `Snap.CameraKit.${options.databaseName}`;
    this.databaseVersion = options.databaseVersion;
    this.objectStore = (_a = options.objectStore) !== null && _a !== void 0 ? _a : options.databaseName;
    this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
    this.size = 0;
  }
  retrieve(key) {
    return this.simpleTransaction("readonly", (store) => store.get(key));
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readonly");
      let request = yield wrapCursorRequest(store.openCursor());
      while (request.cursor) {
        results.push([request.cursor.primaryKey, request.cursor.value]);
        request = yield request.continue();
      }
      yield done;
      return results;
    });
  }
  remove(key) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.simpleTransaction("readwrite", (store) => store.delete(key));
      this.size--;
    });
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readwrite");
      let request = yield wrapCursorRequest(store.openCursor());
      const deleteRequests = [];
      while (request.cursor) {
        results.push(request.cursor.value);
        deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));
        request = yield request.continue();
      }
      yield Promise.all(deleteRequests.concat(done));
      this.size = 0;
      return results;
    });
  }
  store(keyOrValue, maybeValue) {
    return __awaiter(this, void 0, void 0, function* () {
      const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
      if (!isValidKey(key) && typeof key !== "undefined")
        throw new TypeError(`IndexedDBPersistence failed to store a value. Invalid key type: ${typeof key}`);
      const storedKey = yield this.simpleTransaction("readwrite", (store) => store.put(value, key));
      this.size++;
      return storedKey;
    });
  }
  openDatabase(request) {
    return __awaiter(this, void 0, void 0, function* () {
      const dbPromise = wrapRequest(request);
      dbPromise.request.onupgradeneeded = () => {
        try {
          dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });
        } catch (error) {
          if (error instanceof DOMException && error.name === "ConstraintError")
            return;
          throw error;
        }
      };
      const db = yield dbPromise;
      db.onclose = () => {
        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
      };
      return db;
    });
  }
  simpleTransaction(mode, operation) {
    return __awaiter(this, void 0, void 0, function* () {
      const { store, done } = yield this.transaction(mode);
      const [result] = yield Promise.all([wrapRequest(operation(store)), done]);
      return result;
    });
  }
  transaction(mode) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this.db;
      const tx = db.transaction(this.objectStore, mode);
      const store = tx.objectStore(this.objectStore);
      const done = new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(new DOMException("The transaction was aborted", "AbortError"));
      });
      return { tx, store, done };
    });
  }
};

// node_modules/@snap/camera-kit/lib/handlers/mappingHandler.js
var createMappingHandler = (map2, pageVisibility, maxMapConcurrency = Number.POSITIVE_INFINITY) => {
  const buffer2 = [];
  let mapConcurrency = 0;
  const processRequest = (request) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      mapConcurrency++;
      const mapped = request.map();
      if (mapped instanceof Promise)
        request.next(yield mapped);
      else if (mapped)
        request.next(mapped);
    } catch (error) {
      request.reject(error);
    } finally {
      mapConcurrency--;
    }
    while (buffer2.length > 0 && mapConcurrency < maxMapConcurrency) {
      processRequest(buffer2.shift());
    }
  });
  if (pageVisibility) {
    pageVisibility.onPageHidden(() => {
      while (buffer2.length > 0)
        processRequest(buffer2.shift());
    });
  }
  return (next) => (request, metadata) => {
    return new Promise((resolve, reject) => {
      const mappableRequest = {
        map: () => map2(request),
        next: (mappedRequest) => next(mappedRequest, metadata).then(resolve).catch(reject),
        reject
      };
      if (mapConcurrency < maxMapConcurrency)
        processRequest(mappableRequest);
      else
        buffer2.push(mappableRequest);
    });
  };
};

// node_modules/@snap/camera-kit/lib/handlers/batchingHandler.js
var createBatchingHandler = ({ batchReduce, isBatchComplete, maxBatchAge, pageVisibility }) => {
  let batchTimeout;
  let currentBatch = void 0;
  let clearOnHidden = () => {
  };
  const reducingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    currentBatch = yield batchReduce(currentBatch, request);
    return currentBatch;
  }), pageVisibility, 1);
  const batchAndSend = (next, request, metadata) => {
    const batch = request ? batchReduce(currentBatch, request) : currentBatch;
    if (!batch)
      return;
    const complete = batch instanceof Promise ? batch.then((b2) => next(b2, metadata)).catch(() => {
    }) : next(batch, metadata).catch(() => {
    });
    currentBatch = void 0;
    clearTimeout(batchTimeout);
    clearOnHidden();
    return complete;
  };
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden")) {
      yield batchAndSend(next, request, metadata);
      return;
    }
    if (currentBatch === void 0) {
      const sendBatch = () => batchAndSend(next, void 0, metadata);
      if (maxBatchAge !== void 0)
        batchTimeout = setTimeout(sendBatch, maxBatchAge);
      if (pageVisibility)
        clearOnHidden = pageVisibility.onPageHidden(sendBatch);
    }
    const handle = reducingHandler(() => __awaiter(void 0, void 0, void 0, function* () {
      if (!currentBatch)
        return;
      if (!isBatchComplete(currentBatch))
        return;
      yield batchAndSend(next, void 0, metadata);
    }));
    return handle(request, metadata);
  });
};

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/service.js
var import_long21 = __toESM(require_long());
var import_minimal21 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/ranking.js
var import_long17 = __toESM(require_long());
var import_minimal17 = __toESM(require_minimal2());
var RankingData_OSType;
(function(RankingData_OSType2) {
  RankingData_OSType2["OS_TYPE_UNSET"] = "OS_TYPE_UNSET";
  RankingData_OSType2["OS_TYPE_ANDROID"] = "OS_TYPE_ANDROID";
  RankingData_OSType2["OS_TYPE_IOS"] = "OS_TYPE_IOS";
  RankingData_OSType2["OS_TYPE_IPAD_OS"] = "OS_TYPE_IPAD_OS";
  RankingData_OSType2["OS_TYPE_MAC_OS"] = "OS_TYPE_MAC_OS";
  RankingData_OSType2["OS_TYPE_WINDOWS"] = "OS_TYPE_WINDOWS";
  RankingData_OSType2["OS_TYPE_LINUX"] = "OS_TYPE_LINUX";
  RankingData_OSType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(RankingData_OSType || (RankingData_OSType = {}));
var RankingData_ConnectivityType;
(function(RankingData_ConnectivityType2) {
  RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNSET"] = "CONNECTIVITY_TYPE_UNSET";
  RankingData_ConnectivityType2["CONNECTIVITY_TYPE_WIFI"] = "CONNECTIVITY_TYPE_WIFI";
  RankingData_ConnectivityType2["CONNECTIVITY_TYPE_MOBILE"] = "CONNECTIVITY_TYPE_MOBILE";
  RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNREACHABLE"] = "CONNECTIVITY_TYPE_UNREACHABLE";
  RankingData_ConnectivityType2["CONNECTIVITY_TYPE_BLUETOOTH"] = "CONNECTIVITY_TYPE_BLUETOOTH";
  RankingData_ConnectivityType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(RankingData_ConnectivityType || (RankingData_ConnectivityType = {}));
if (import_minimal17.default.util.Long !== import_long17.default) {
  import_minimal17.default.util.Long = import_long17.default;
  import_minimal17.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/legal_prompt.js
var import_long18 = __toESM(require_long());
var import_minimal18 = __toESM(require_minimal2());
var LegalDocument_Type;
(function(LegalDocument_Type2) {
  LegalDocument_Type2["UNSET"] = "UNSET";
  LegalDocument_Type2["TERMS_OF_SERVICE"] = "TERMS_OF_SERVICE";
  LegalDocument_Type2["PRIVACY_POLICY"] = "PRIVACY_POLICY";
  LegalDocument_Type2["LEARN_MORE"] = "LEARN_MORE";
  LegalDocument_Type2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LegalDocument_Type || (LegalDocument_Type = {}));
function legalDocument_TypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSET":
      return LegalDocument_Type.UNSET;
    case 1:
    case "TERMS_OF_SERVICE":
      return LegalDocument_Type.TERMS_OF_SERVICE;
    case 2:
    case "PRIVACY_POLICY":
      return LegalDocument_Type.PRIVACY_POLICY;
    case 3:
    case "LEARN_MORE":
      return LegalDocument_Type.LEARN_MORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LegalDocument_Type.UNRECOGNIZED;
  }
}
function legalDocument_TypeToJSON(object) {
  switch (object) {
    case LegalDocument_Type.UNSET:
      return "UNSET";
    case LegalDocument_Type.TERMS_OF_SERVICE:
      return "TERMS_OF_SERVICE";
    case LegalDocument_Type.PRIVACY_POLICY:
      return "PRIVACY_POLICY";
    case LegalDocument_Type.LEARN_MORE:
      return "LEARN_MORE";
    default:
      return "UNKNOWN";
  }
}
function legalDocument_TypeToNumber(object) {
  switch (object) {
    case LegalDocument_Type.UNSET:
      return 0;
    case LegalDocument_Type.TERMS_OF_SERVICE:
      return 1;
    case LegalDocument_Type.PRIVACY_POLICY:
      return 2;
    case LegalDocument_Type.LEARN_MORE:
      return 3;
    default:
      return 0;
  }
}
function createBaseLegalPrompt() {
  return { documents: [], disabled: false };
}
var LegalPrompt = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    for (const v2 of message.documents) {
      LegalDocument.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.disabled === true) {
      writer.uint32(16).bool(message.disabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documents.push(LegalDocument.decode(reader, reader.uint32()));
          break;
        case 2:
          message.disabled = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      documents: Array.isArray(object === null || object === void 0 ? void 0 : object.documents) ? object.documents.map((e2) => LegalDocument.fromJSON(e2)) : [],
      disabled: isSet4(object.disabled) ? Boolean(object.disabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.documents) {
      obj.documents = message.documents.map((e2) => e2 ? LegalDocument.toJSON(e2) : void 0);
    } else {
      obj.documents = [];
    }
    message.disabled !== void 0 && (obj.disabled = message.disabled);
    return obj;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLegalPrompt();
    message.documents = ((_a = object.documents) === null || _a === void 0 ? void 0 : _a.map((e2) => LegalDocument.fromPartial(e2))) || [];
    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function createBaseLegalDocument() {
  return { type: LegalDocument_Type.UNSET, webUrl: "", version: "", timestamp: void 0 };
}
var LegalDocument = {
  encode(message, writer = import_minimal18.default.Writer.create()) {
    if (message.type !== LegalDocument_Type.UNSET) {
      writer.uint32(8).int32(legalDocument_TypeToNumber(message.type));
    }
    if (message.webUrl !== "") {
      writer.uint32(18).string(message.webUrl);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal18.default.Reader ? input : new import_minimal18.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = legalDocument_TypeFromJSON(reader.int32());
          break;
        case 2:
          message.webUrl = reader.string();
          break;
        case 3:
          message.version = reader.string();
          break;
        case 4:
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet4(object.type) ? legalDocument_TypeFromJSON(object.type) : LegalDocument_Type.UNSET,
      webUrl: isSet4(object.webUrl) ? String(object.webUrl) : "",
      version: isSet4(object.version) ? String(object.version) : "",
      timestamp: isSet4(object.timestamp) ? fromJsonTimestamp(object.timestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = legalDocument_TypeToJSON(message.type));
    message.webUrl !== void 0 && (obj.webUrl = message.webUrl);
    message.version !== void 0 && (obj.version = message.version);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseLegalDocument();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : LegalDocument_Type.UNSET;
    message.webUrl = (_b = object.webUrl) !== null && _b !== void 0 ? _b : "";
    message.version = (_c = object.version) !== null && _c !== void 0 ? _c : "";
    message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function toTimestamp2(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp2(t2) {
  let millis = t2.seconds * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp2(Timestamp.fromJSON(o));
  }
}
if (import_minimal18.default.util.Long !== import_long18.default) {
  import_minimal18.default.util.Long = import_long18.default;
  import_minimal18.default.configure();
}
function isSet4(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/operational_metrics.js
var import_long19 = __toESM(require_long());
var import_minimal19 = __toESM(require_minimal2());
function createBaseOperationalMetric() {
  return { name: "", timestamp: void 0, metric: void 0 };
}
var OperationalMetric = {
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.timestamp = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.metric = { $case: "count", count: longToNumber6(reader.uint64()) };
          break;
        case 4:
          message.metric = { $case: "latencyMillis", latencyMillis: longToNumber6(reader.uint64()) };
          break;
        case 5:
          message.metric = { $case: "histogram", histogram: longToNumber6(reader.int64()) };
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet5(object.name) ? String(object.name) : "",
      timestamp: isSet5(object.timestamp) ? fromJsonTimestamp2(object.timestamp) : void 0,
      metric: isSet5(object.count) ? { $case: "count", count: Number(object.count) } : isSet5(object.latencyMillis) ? { $case: "latencyMillis", latencyMillis: Number(object.latencyMillis) } : isSet5(object.histogram) ? { $case: "histogram", histogram: Number(object.histogram) } : void 0
    };
  },
  toJSON(message) {
    var _a, _b, _c, _d, _e, _f;
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp.toISOString());
    ((_a = message.metric) === null || _a === void 0 ? void 0 : _a.$case) === "count" && (obj.count = Math.round((_b = message.metric) === null || _b === void 0 ? void 0 : _b.count));
    ((_c = message.metric) === null || _c === void 0 ? void 0 : _c.$case) === "latencyMillis" && (obj.latencyMillis = Math.round((_d = message.metric) === null || _d === void 0 ? void 0 : _d.latencyMillis));
    ((_e = message.metric) === null || _e === void 0 ? void 0 : _e.$case) === "histogram" && (obj.histogram = Math.round((_f = message.metric) === null || _f === void 0 ? void 0 : _f.histogram));
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseOperationalMetric();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : void 0;
    if (((_c = object.metric) === null || _c === void 0 ? void 0 : _c.$case) === "count" && ((_d = object.metric) === null || _d === void 0 ? void 0 : _d.count) !== void 0 && ((_e = object.metric) === null || _e === void 0 ? void 0 : _e.count) !== null) {
      message.metric = { $case: "count", count: object.metric.count };
    }
    if (((_f = object.metric) === null || _f === void 0 ? void 0 : _f.$case) === "latencyMillis" && ((_g = object.metric) === null || _g === void 0 ? void 0 : _g.latencyMillis) !== void 0 && ((_h = object.metric) === null || _h === void 0 ? void 0 : _h.latencyMillis) !== null) {
      message.metric = { $case: "latencyMillis", latencyMillis: object.metric.latencyMillis };
    }
    if (((_j = object.metric) === null || _j === void 0 ? void 0 : _j.$case) === "histogram" && ((_k = object.metric) === null || _k === void 0 ? void 0 : _k.histogram) !== void 0 && ((_l = object.metric) === null || _l === void 0 ? void 0 : _l.histogram) !== null) {
      message.metric = { $case: "histogram", histogram: object.metric.histogram };
    }
    return message;
  }
};
function createBaseOperationalMetricsBundle() {
  return { metrics: [] };
}
var OperationalMetricsBundle = {
  decode(input, length) {
    const reader = input instanceof import_minimal19.default.Reader ? input : new import_minimal19.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetricsBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metrics.push(OperationalMetric.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      metrics: Array.isArray(object === null || object === void 0 ? void 0 : object.metrics) ? object.metrics.map((e2) => OperationalMetric.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.metrics) {
      obj.metrics = message.metrics.map((e2) => e2 ? OperationalMetric.toJSON(e2) : void 0);
    } else {
      obj.metrics = [];
    }
    return obj;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseOperationalMetricsBundle();
    message.metrics = ((_a = object.metrics) === null || _a === void 0 ? void 0 : _a.map((e2) => OperationalMetric.fromPartial(e2))) || [];
    return message;
  }
};
var globalThis10 = (() => {
  if (typeof globalThis10 !== "undefined")
    return globalThis10;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function fromTimestamp3(t2) {
  let millis = t2.seconds * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function fromJsonTimestamp2(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp3(Timestamp.fromJSON(o));
  }
}
function longToNumber6(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis10.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal19.default.util.Long !== import_long19.default) {
  import_minimal19.default.util.Long = import_long19.default;
  import_minimal19.default.configure();
}
function isSet5(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/business_events.js
var import_long20 = __toESM(require_long());
var import_minimal20 = __toESM(require_minimal2());
var CameraKitFlavor;
(function(CameraKitFlavor3) {
  CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNSET"] = "CAMERA_KIT_FLAVOR_UNSET";
  CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3["UNRECOGNIZED"] = "UNRECOGNIZED";
})(CameraKitFlavor || (CameraKitFlavor = {}));
var CameraKitConnectivityType;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNSET"] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNSET";
  CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3["UNRECOGNIZED"] = "UNRECOGNIZED";
})(CameraKitConnectivityType || (CameraKitConnectivityType = {}));
var CameraKitEnvironment;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNSET"] = "CAMERA_KIT_ENVIRONMENT_UNSET";
  CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3["UNRECOGNIZED"] = "UNRECOGNIZED";
})(CameraKitEnvironment || (CameraKitEnvironment = {}));
var globalThis11 = (() => {
  if (typeof globalThis11 !== "undefined")
    return globalThis11;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
if (import_minimal20.default.util.Long !== import_long20.default) {
  import_minimal20.default.util.Long = import_long20.default;
  import_minimal20.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/camera_kit/v3/service.js
function createBaseGetInitializationConfigResponse() {
  return {
    appVendorUuidOptIn: false,
    watermarkEnabled: false,
    childrenProtectionActRestricted: false,
    legalPrompt: void 0
  };
}
var GetInitializationConfigResponse = {
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInitializationConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appVendorUuidOptIn = reader.bool();
          break;
        case 2:
          message.watermarkEnabled = reader.bool();
          break;
        case 3:
          message.childrenProtectionActRestricted = reader.bool();
          break;
        case 4:
          message.legalPrompt = LegalPrompt.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      appVendorUuidOptIn: isSet6(object.appVendorUuidOptIn) ? Boolean(object.appVendorUuidOptIn) : false,
      watermarkEnabled: isSet6(object.watermarkEnabled) ? Boolean(object.watermarkEnabled) : false,
      childrenProtectionActRestricted: isSet6(object.childrenProtectionActRestricted) ? Boolean(object.childrenProtectionActRestricted) : false,
      legalPrompt: isSet6(object.legalPrompt) ? LegalPrompt.fromJSON(object.legalPrompt) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.appVendorUuidOptIn !== void 0 && (obj.appVendorUuidOptIn = message.appVendorUuidOptIn);
    message.watermarkEnabled !== void 0 && (obj.watermarkEnabled = message.watermarkEnabled);
    message.childrenProtectionActRestricted !== void 0 && (obj.childrenProtectionActRestricted = message.childrenProtectionActRestricted);
    message.legalPrompt !== void 0 && (obj.legalPrompt = message.legalPrompt ? LegalPrompt.toJSON(message.legalPrompt) : void 0);
    return obj;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseGetInitializationConfigResponse();
    message.appVendorUuidOptIn = (_a = object.appVendorUuidOptIn) !== null && _a !== void 0 ? _a : false;
    message.watermarkEnabled = (_b = object.watermarkEnabled) !== null && _b !== void 0 ? _b : false;
    message.childrenProtectionActRestricted = (_c = object.childrenProtectionActRestricted) !== null && _c !== void 0 ? _c : false;
    message.legalPrompt = object.legalPrompt !== void 0 && object.legalPrompt !== null ? LegalPrompt.fromPartial(object.legalPrompt) : void 0;
    return message;
  }
};
function createBaseSetOperationalMetricsRequest() {
  return { metrics: void 0 };
}
var SetOperationalMetricsRequest = {
  decode(input, length) {
    const reader = input instanceof import_minimal21.default.Reader ? input : new import_minimal21.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetOperationalMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metrics = OperationalMetricsBundle.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      metrics: isSet6(object.metrics) ? OperationalMetricsBundle.fromJSON(object.metrics) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.metrics !== void 0 && (obj.metrics = message.metrics ? OperationalMetricsBundle.toJSON(message.metrics) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSetOperationalMetricsRequest();
    message.metrics = object.metrics !== void 0 && object.metrics !== null ? OperationalMetricsBundle.fromPartial(object.metrics) : void 0;
    return message;
  }
};
if (import_minimal21.default.util.Long !== import_long21.default) {
  import_minimal21.default.util.Long = import_long21.default;
  import_minimal21.default.configure();
}
function isSet6(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/camera-kit/lib/common/pageVisibility.js
var PageVisibility = class {
  constructor() {
    this.onHiddenHandlers = /* @__PURE__ */ new Set();
    this.onVisibleHandlers = /* @__PURE__ */ new Set();
    this.previousVisibilityState = document.visibilityState;
    this.visibilityTransition = false;
    this.onVisibilityChange = this.onVisibilityChange.bind(this);
    this.isDuringVisibilityTransition = this.isDuringVisibilityTransition.bind(this);
    this.onPageHidden = this.onPageHidden.bind(this);
    this.onPageVisible = this.onPageVisible.bind(this);
    this.destroy = this.destroy.bind(this);
    document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  isDuringVisibilityTransition(test) {
    return test === this.visibilityTransition;
  }
  /**
   * Run a function when the page is hidden. If this occurs due to tab / browser closure,
   * only synchronous functions will run to completion.
   *
   * If the given handler throws an error, it will be silently swallowed.
   *
   * @param handler
   * @returns A function which, when called, removes the function from the set of visibility change handlers.
   */
  onPageHidden(handler) {
    this.onHiddenHandlers.add(handler);
    return () => this.onHiddenHandlers.delete(handler);
  }
  /**
   * Run a function when the page is made visible.
   *
   * If the given handler throws an error, it will be silently swallowed.
   *
   * @param handler
   * @returns A function which, when called, removes the function from the set of visibility change handlers.
   */
  onPageVisible(handler) {
    this.onVisibleHandlers.add(handler);
    return () => this.onVisibleHandlers.delete(handler);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.onVisibilityChange);
    this.onHiddenHandlers.clear();
    this.onVisibleHandlers.clear();
  }
  onVisibilityChange() {
    const handlers = this.previousVisibilityState === "visible" && document.visibilityState === "hidden" ? this.onHiddenHandlers : this.previousVisibilityState === "hidden" && document.visibilityState === "visible" ? this.onVisibleHandlers : /* @__PURE__ */ new Set();
    this.visibilityTransition = document.visibilityState;
    for (const handler of handlers) {
      try {
        handler();
      } catch (error) {
        if (typeof window !== "undefined")
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
    }
    this.previousVisibilityState = this.visibilityTransition;
    this.visibilityTransition = false;
  }
};
var pageVisibilityFactory = Injectable("pageVisibility", () => new PageVisibility());

// node_modules/@snap/camera-kit/lib/handlers/rateLimitingHandler.js
var delay2 = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
var createRateLimitingHandler = (duration, pageVisibility) => {
  let mostRecentSendTime = void 0;
  const mappingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    if (mostRecentSendTime !== void 0) {
      const millisUntilNextSend = duration - (Date.now() - mostRecentSendTime);
      if (millisUntilNextSend > 0)
        yield delay2(millisUntilNextSend);
    }
    mostRecentSendTime = Date.now();
    return request;
  }), pageVisibility, 1);
  return (next) => (request, metadata) => {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden"))
      return next(request, metadata);
    return mappingHandler(next)(request, metadata);
  };
};

// node_modules/@snap/camera-kit/lib/metrics/metricsHandler.js
var METRIC_REQUEST_RATE_LIMIT_MS = 1e3;
var metricsHandlerFactory = Injectable("metricsHandler", [cameraKitServiceFetchHandlerFactory.token, pageVisibilityFactory.token], (fetchHandler, pageVisibility) => {
  return new HandlerChainBuilder(fetchHandler).map(createRateLimitingHandler(METRIC_REQUEST_RATE_LIMIT_MS, pageVisibility)).handler;
});

// node_modules/@snap/camera-kit/lib/metrics/operational/operationalMetricsReporter.js
var DIMENSION_DELIMITER = ".";
var METRIC_BATCH_MAX_SIZE = 100;
var METRIC_BATCH_MAX_AGE_MS = 5e3;
var OperationalMetricsReporter = class {
  constructor(metricsHandler) {
    this.metricsHandler = metricsHandler;
  }
  /**
   * Record a count.
   *
   * @param name
   * @param count
   * @param dimensions An optional Map containing dimensions which describe the metric.
   * For example: `new Map([['status', '200']])`
   * @returns Promise which resolves when the metric has been handled.
   */
  count(name, count2, dimensions) {
    return this.record(name, { $case: "count", count: count2 }, dimensions);
  }
  /**
   * Record a duration in milliseconds.
   *
   * @param name
   * @param latencyMillis
   * @param dimensions An optional Map containing dimensions which describe the metric.
   * For example: `new Map([['status', '200']])`
   * @returns Promise which resolves when the metric has been handled.
   */
  timer(name, latencyMillis, dimensions) {
    return this.record(name, { $case: "latencyMillis", latencyMillis }, dimensions);
  }
  /**
   * Record a histogram.
   *
   * @param name
   * @param histogram
   * @param dimensions An optional Map containing dimensions which describe the metric.
   * For example: `new Map([['status', '200']])`
   * @returns Promise which resolves when the metric has been handled.
   */
  histogram(name, histogram, dimensions) {
    return this.record(name, { $case: "histogram", histogram }, dimensions);
  }
  /**
   * TODO: This entire class in no longer necessary, since the new Timer/Count/Histogram classes offer a cleaner API
   * for recording metrics. Once we migrate all operational metrics to use those new APIs, this class can be removed
   * and call sites will just call the metrics handler directly.
   *
   * @param metric Any concrete Metric (e.g. Count, Timer, Histogram)
   * @returns
   */
  report(metric) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(metric.toOperationalMetric().map((metric2) => this.metricsHandler(metric2)));
    });
  }
  record(name, metric, dimensions) {
    const serializedDimensions = dimensions ? `.${Array.from(dimensions.entries()).map((d2) => d2.join(DIMENSION_DELIMITER)).join(DIMENSION_DELIMITER)}` : "";
    return this.metricsHandler({
      name: `${name}${serializedDimensions}`,
      timestamp: /* @__PURE__ */ new Date(),
      metric
    });
  }
};
var operationalMetricReporterFactory = Injectable("operationalMetricsReporter", [metricsHandlerFactory.token, pageVisibilityFactory.token, configurationToken], (metricsHandler, pageVisibility, configuration) => {
  const handler = new HandlerChainBuilder(metricsHandler).map(createMappingHandler((metrics) => {
    const request = { metrics };
    return new Request(
      // eslint-disable-next-line max-len
      `https://${configuration.apiHostname}/com.snap.camerakit.v3.Metrics/metrics/operational_metrics`,
      {
        method: "POST",
        body: JSON.stringify(SetOperationalMetricsRequest.toJSON(request)),
        credentials: "include",
        // When this is true it makes fetch behave like `Navigator.sendBeacon`  that is, the
        // request will still be made even if the page terminates.
        // https://developer.mozilla.org/en-US/docs/Web/API/fetch
        keepalive: pageVisibility.isDuringVisibilityTransition("hidden")
      }
    );
  }, pageVisibility)).map(createBatchingHandler({
    // The batching logic here is very simple  it could be improved by e.g.
    // computing statistics to reduce overall data sent, etc. Right now this is
    // premature optimization, but could become a good idea in the future.
    batchReduce: (previousBundle, metric) => {
      var _a, _b;
      let metrics = [...(_a = previousBundle === null || previousBundle === void 0 ? void 0 : previousBundle.metrics) !== null && _a !== void 0 ? _a : []];
      const existingCountIndex = ((_b = metric.metric) === null || _b === void 0 ? void 0 : _b.$case) === "count" ? metrics.findIndex((m2) => {
        var _a2;
        return metric.name === m2.name && ((_a2 = m2.metric) === null || _a2 === void 0 ? void 0 : _a2.$case) === "count";
      }) : -1;
      if (existingCountIndex >= 0) {
        const existingValue = metrics[existingCountIndex].metric;
        const newValue = metric.metric;
        metrics.splice(existingCountIndex, 1, Object.assign(Object.assign({}, metric), { metric: {
          $case: "count",
          count: existingValue.count + newValue.count
        } }));
      } else {
        metrics.push(metric);
      }
      return { metrics };
    },
    isBatchComplete: (bundle) => bundle.metrics.length >= METRIC_BATCH_MAX_SIZE,
    maxBatchAge: METRIC_BATCH_MAX_AGE_MS,
    pageVisibility
  })).handler;
  return new OperationalMetricsReporter(handler);
});

// node_modules/@snap/camera-kit/lib/remote-configuration/cofHandler.js
var id = (h2) => h2;
var COF_REQUEST_TYPE = "cof";
var cofHandlerFactory = Injectable("cofHandler", [configurationToken, requestStateEventTargetFactory.token, operationalMetricReporterFactory.token], (config2, requestStateEventTarget, reporter) => {
  return new HandlerChainBuilder((request, _a) => __awaiter(void 0, void 0, void 0, function* () {
    var { signal, isSideEffect: _ } = _a, metadata = __rest(_a, ["signal", "isSideEffect"]);
    const rpc = new GrpcWebImpl(`https://${config2.apiHostname}`, {});
    const client = new CircumstancesServiceClientImpl(rpc);
    return new Promise((resolve, reject) => {
      if (signal) {
        signal.addEventListener("abort", () => reject(new Error("COF request aborted by handler chain.")));
      }
      client.targetingQuery(request, new import_browser_headers2.BrowserHeaders(Object.assign({ authorization: `Bearer ${config2.apiToken}`, "x-snap-client-user-agent": getCameraKitUserAgent() }, metadata))).then((response) => {
        delete response.toObject;
        resolve(response);
      }).catch(reject);
    });
  })).map(id((next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    const dimensions = { requestType: COF_REQUEST_TYPE };
    const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
    try {
      const response = yield next(request, metadata);
      const status = 200;
      let sizeByte = 0;
      try {
        sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;
      } finally {
        dispatchRequestCompleted(requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          status,
          sizeByte
        });
        return response;
      }
    } catch (error) {
      dispatchRequestErrored(requestStateEventTarget, {
        requestId: requestId2,
        dimensions,
        error: ensureError(error)
      });
      throw error;
    }
  }))).map(createRetryingHandler({ retryPredicate: (r2) => r2 instanceof Error })).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createResponseCachingHandler(
    // COF responses will be removed from cache after 1 week. Keep in mind that the
    // staleWhileRevalidate strategy will update the cache each time COF is requested
    //   this expiration comes into play only if e.g. a user doesn't load the page
    // for more than a week.
    new ExpiringPersistence(() => 7 * 24 * 60 * 60, new IndexedDBPersistence({ databaseName: "COFCache" })),
    (r2) => JSON.stringify(r2),
    // If we have a matching response already in cache,
    // we'll return it immediately and then update the cache in the background.
    staleWhileRevalidateStrategy({ requestType: "cof", reporter })
  )).handler;
});

// node_modules/@snap/camera-kit/lib/remote-configuration/remoteConfiguration.js
var defaultTargetingRequest = {
  namespaces: [Namespace.LENS_CORE, Namespace.CAMERA_KIT_CORE, Namespace.LENS_CORE_CONFIG]
};
var initializeConfigRelativePath = "/com.snap.camerakit.v3.Metrics/metrics/initialization_config";
var RemoteConfiguration = class {
  constructor(lensPerformance, apiHostname, cofHandler, fetchHandler) {
    const lensCluster = Promise.resolve(lensPerformance).then((lensPerformance2) => {
      return (lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster) === 0 ? void 0 : lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster;
    });
    this.configById = from(lensCluster).pipe(
      // Note: we don't catch errors here, purposefully letting them propagate to subscribers outside this class.
      // Subscribers, having more context about the config use-case, will know better how to handle an error than
      // we do here (e.g. their logging / reporting will have more context, and they can use the error they get
      // from this Observable as a cause).
      mergeMap((lensClusterOrig4) => from(cofHandler(Object.assign(Object.assign({}, defaultTargetingRequest), { lensClusterOrig4 })))),
      map((result) => {
        const configById = /* @__PURE__ */ new Map();
        result.configResults.forEach((config2) => {
          var _a;
          const configsWithId = (_a = configById.get(config2.configId)) !== null && _a !== void 0 ? _a : [];
          configsWithId.push(config2);
          configById.set(config2.configId, configsWithId);
        });
        return configById;
      }),
      shareReplay(1)
    );
    this.initializationConfig = new Observable((observer) => {
      fetchHandler(`https://${apiHostname}${initializeConfigRelativePath}`).then((response) => response.json()).then((data) => {
        observer.next(data);
        observer.complete();
      }).catch((err) => observer.error(err));
    }).pipe(shareReplay(1));
  }
  /**
   * COF configuration.
   */
  get(configId) {
    return this.configById.pipe(map((config2) => {
      var _a;
      return (_a = config2.get(configId)) !== null && _a !== void 0 ? _a : [];
    }));
  }
  /**
   * Configuration that is provided by Camera Kit backend.
   */
  getInitializationConfig() {
    return this.initializationConfig;
  }
  getNamespace(namespace) {
    return this.configById.pipe(map((configs) => {
      const namespaceConfigs = Array.from(configs.values()).filter((values) => values.some((c2) => c2.namespace === namespace)).flatMap((results) => results);
      return namespaceConfigs;
    }));
  }
};
var remoteConfigurationFactory = Injectable("remoteConfiguration", [configurationToken, cofHandlerFactory.token, cameraKitServiceFetchHandlerFactory.token], (config2, cofHandler, fetchHandler) => {
  const remoteConfig = new RemoteConfiguration(config2.lensPerformance, config2.apiHostname, cofHandler, fetchHandler);
  remoteConfig.get("").pipe(take(1)).subscribe();
  return remoteConfig;
});

// node_modules/@snap/camera-kit/lib/lens/assets/deviceDependentAssetLoader.js
var hasStringValue = (value) => {
  return isRecord(value) && isString(value.stringValue);
};
var isAssetConfig = (value) => {
  return isRecord(value) && isString(value.url) && (value.checksum === void 0 || isString(value.checksum));
};
var deviceDependentAssetLoaderFactory = Injectable("deviceDependentAssetLoader", [defaultFetchHandlerFactory.token, remoteConfigurationFactory.token], (fetchHandler, remoteConfiguration) => {
  const assetHandler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function deviceDependentAssetLoader({ assetId }) {
    return __awaiter(this, void 0, void 0, function* () {
      const loadingFailed = (reason, cause) => new Error(`Cannot load device-dependent asset ${assetId}. ${reason}`, { cause });
      return firstValueFrom(remoteConfiguration.get(assetId).pipe(catchError((error) => {
        throw loadingFailed("COF config failed to load.", error);
      }), map((configs) => {
        if (configs.length === 0) {
          throw loadingFailed(`No COF config found corresponding to that assetId.`);
        }
        const [{ value }] = configs;
        if (!hasStringValue(value))
          throw loadingFailed("COF config malformed (missing stringValue)");
        let assetConfig;
        try {
          assetConfig = JSON.parse(value.stringValue);
        } catch (parseError) {
          throw loadingFailed("COF config malformed (JSON parse error)", parseError);
        }
        if (!isAssetConfig(assetConfig))
          throw loadingFailed("COF config malformed (missing URL)");
        return assetConfig;
      }), mergeMap(({ url, checksum }) => __awaiter(this, void 0, void 0, function* () {
        const [data, response] = yield assetHandler(url, { cache: "force-cache" });
        if (!response.ok)
          throw response;
        return { data, checksum };
      }))));
    });
  };
});

// node_modules/@snap/camera-kit/lib/lens/assets/remoteMediaAssetLoaderFactory.js
var remoteMediaAssetLoaderFactory = Injectable("remoteMediaAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function remoteMediaAssetLoader(asset) {
    return __awaiter(this, void 0, void 0, function* () {
      const [buffer2, response] = yield handler(asset.assetId, { cache: "force-cache" });
      if (!response.ok)
        throw response;
      return buffer2;
    });
  };
});

// node_modules/@snap/camera-kit/lib/lens/assets/staticAssetLoader.js
var staticAssetLoaderFactory = Injectable("staticAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return (asset, _lens, assetManifest) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const assetUrl = (_a = assetManifest === null || assetManifest === void 0 ? void 0 : assetManifest.find((manifest) => manifest.id === asset.assetId)) === null || _a === void 0 ? void 0 : _a.assetUrl;
    if (!assetUrl) {
      throw new Error(`Cannot load lens asset ${asset.assetId}. Static asset URL could not be found.`);
    }
    const [buffer2, response] = yield handler(assetUrl, { cache: "force-cache" });
    if (!response.ok)
      throw response;
    return buffer2;
  });
});

// node_modules/@snap/camera-kit/lib/lens/assets/LensAssetRepository.js
var logger6 = getLogger("LensAssetRepository");
function getCacheKey(asset) {
  return `${asset.assetId}_${asset.assetType.value}`;
}
function mapManfiestItemToAssetType(lensCore, type) {
  switch (type) {
    case LensAssetManifestItem_Type.ASSET:
      return lensCore.AssetType.Static;
    case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:
    case LensAssetManifestItem_Type.UNRECOGNIZED:
      return lensCore.AssetType.DeviceDependent;
    default:
      return assertUnreachable(type);
  }
}
var LensAssetRepository = class {
  constructor(lensCore, assetLoaders, metrics, requestStateEventTarget) {
    this.lensCore = lensCore;
    this.assetLoaders = assetLoaders;
    this.metrics = metrics;
    this.requestStateEventTarget = requestStateEventTarget;
    this.cachedAssetKeys = /* @__PURE__ */ new Set();
  }
  /**
   * Caches lens assets defined in asset manifest.
   *
   * @param assetManifest Lens asset manifest.
   * @param lens Lens to cache assets of.
   * @param assetTimings Optionally specifies what assets to cache. By default, on-demand assets are not cached.
   * @returns Promise rejects if any required assets could not be loaded  if this occurs, it's very likely the Lens
   * with this manifest will not function.
   */
  cacheAssets(assetManifest, lens, assetTimings = [LensAssetManifestItem_RequestTiming.REQUIRED]) {
    return __awaiter(this, void 0, void 0, function* () {
      const assetTimingsToPreload = /* @__PURE__ */ new Set([
        // That is a bad naming, but PRELOAD_UNSET actually means
        // that an asset has to be preloaded
        LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
        ...assetTimings
      ]);
      const assetDescriptors = assetManifest.filter((asset) => {
        return assetTimingsToPreload.has(asset.requestTiming);
      }).map(({ id: id2, type }) => ({
        assetId: id2,
        assetType: mapManfiestItemToAssetType(this.lensCore, type)
      }));
      if (assetDescriptors.length) {
        return this.cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest);
      }
    });
  }
  /**
   * Calls the correct asset loader to fetch the asset's data,
   * depending on the requested asset's type and provides that to LensCore.
   */
  loadAsset(assetDescriptor, lens, assetManifest) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const { assetId, assetType } = assetDescriptor;
      const [assetTypeName, assetLoader] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
      const safeAssetTypeName = assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : "unknown";
      const dimensions = {
        requestType: "asset",
        assetId,
        assetType: safeAssetTypeName,
        lensId: (_b = lens === null || lens === void 0 ? void 0 : lens.id) !== null && _b !== void 0 ? _b : "unknown"
      };
      const { requestId: requestId2 } = dispatchRequestStarted(this.requestStateEventTarget, { dimensions });
      try {
        if (!assetLoader) {
          throw new Error(`Cannot get asset ${assetId}. Asset type ${safeAssetTypeName} is not supported.`);
        }
        const assetResponse = yield assetLoader(assetDescriptor, lens, assetManifest);
        const assetBuffer = "data" in assetResponse ? assetResponse.data : assetResponse;
        const assetChecksum = "checksum" in assetResponse ? assetResponse.checksum : void 0;
        if (assetBuffer.byteLength === 0) {
          throw new Error(`Got empty response for asset ${assetId} from ${safeAssetTypeName} loader.`);
        }
        dispatchRequestCompleted(this.requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          status: 200,
          sizeByte: assetBuffer.byteLength
        });
        this.lensCore.provideRemoteAssetsResponse({
          assetId,
          assetBuffer,
          assetType,
          assetChecksum,
          onFailure: (lensCoreError) => {
            if (/validation failed/.test(lensCoreError.message)) {
              this.metrics.dispatchEvent(new TypedCustomEvent("assetValidationFailed", {
                name: "assetValidationFailed",
                assetId
              }));
            }
            logger6.warn(new Error(`Failed to provide lens asset ${assetId}.`, { cause: lensCoreError }));
          }
        });
      } catch (error) {
        const wrappedError = new Error(`Failed to load lens asset ${assetId}.`, { cause: error });
        dispatchRequestErrored(this.requestStateEventTarget, { requestId: requestId2, dimensions, error: wrappedError });
        throw wrappedError;
      }
    });
  }
  /**
   * Downloads and caches assets if applicable. Does nothing for assets that are already in cache.
   * @param assetDescriptors Asset ID and type pairs.
   * @param lens Lens to load assets for.
   * @param assetManifest Lens asset manifest.
   */
  cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(assetDescriptors.filter((assetDescriptors2) => !this.cachedAssetKeys.has(getCacheKey(assetDescriptors2))).map((assetDescriptor) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        try {
          yield this.loadAsset(assetDescriptor, lens, assetManifest);
          this.cachedAssetKeys.add(getCacheKey(assetDescriptor));
        } catch (error) {
          const { assetId, assetType } = assetDescriptor;
          const [assetTypeName] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
          logger6.warn(new Error(`Failed to cache asset ${assetId} of type ${assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : assetType.value}.`, {
            cause: error
          }));
        }
      })));
    });
  }
};
var lensAssetRepositoryFactory = Injectable("lensAssetRepository", [
  lensCoreFactory.token,
  deviceDependentAssetLoaderFactory.token,
  remoteMediaAssetLoaderFactory.token,
  staticAssetLoaderFactory.token,
  metricsEventTargetFactory.token,
  requestStateEventTargetFactory.token
], (lensCore, deviceDependentAssetLoader, remoteMediaAssetLoader, staticAssetLoader, metrics, requestStateEventTarget) => new LensAssetRepository(lensCore, /* @__PURE__ */ new Map([
  [lensCore.AssetType.DeviceDependent, ["DeviceDependent", deviceDependentAssetLoader]],
  [lensCore.AssetType.RemoteMediaByUrl, ["RemoteMediaByUrl", remoteMediaAssetLoader]],
  // URL type is deprecated and was introduced before RemoteMediaByURL
  // however, there are some lenses still using it so we need to support it
  [lensCore.AssetType.URL, ["URL", remoteMediaAssetLoader]],
  [lensCore.AssetType.Static, ["Static", staticAssetLoader]]
]), metrics, requestStateEventTarget));

// node_modules/@snap/camera-kit/lib/lens/LensRepository.js
var logger7 = getLogger("LensRepository");
var log = errorLoggingDecorator(logger7);
var assetTimingMap = {
  required: LensAssetManifestItem_RequestTiming.REQUIRED,
  onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND
};
function isAssetTiming(value) {
  return isString(value) && assetTimingMap.hasOwnProperty(value);
}
function isOptionalAssetTimingArray(value) {
  return isUndefined(value) || isArrayOfType(isAssetTiming, value);
}
var LensRepository = class {
  /** @internal */
  constructor(lensMetadataFetchHandler, lensFetchHandler, lensSources, lensAssetRepository, apiHostname) {
    this.lensMetadataFetchHandler = lensMetadataFetchHandler;
    this.lensFetchHandler = lensFetchHandler;
    this.lensSources = lensSources;
    this.lensAssetRepository = lensAssetRepository;
    this.apiHostname = apiHostname;
    this.metadataCache = /* @__PURE__ */ new Map();
    this.binariesCache = /* @__PURE__ */ new Map();
  }
  /**
   * Retrieve a single Lens.
   *
   * @param lensId Desired Lens's unique ID. Can be found in the CameraKit Portal.
   * @param groupId The ID of a group containing the desired Lens. Can be found in the CameraKit Portal.
   * @returns Resolves with the desired Lens, or rejects if an error occurred (including a missing Lens).
   */
  loadLens(lensId, groupId) {
    return __awaiter(this, void 0, void 0, function* () {
      const envelopes = yield this.lensSources.retrieveLenses({ lensId, groupId });
      let lens;
      if (envelopes) {
        lens = decodeEnvelopes(envelopes)[0];
        if (!lens) {
          throw new Error("Expected non-empty envelope.");
        }
      } else {
        lens = yield retrieveCameraKitLens(this.lensMetadataFetchHandler, lensId, groupId, this.apiHostname);
      }
      const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
      this.metadataCache.set(lens.id, lensWithGroup);
      return toPublicLens(lensWithGroup);
    });
  }
  /**
   * Retrieve the Lenses contained in a list of Lens Groups.
   *
   * This may result in multiple requests to retrieve Lens data (e.g. one per desired group). If any constituent
   * requests fail, those errors will be reported in the response  but the returned Promise will not be rejected. Any
   * Lenses which could be successfully retrieved will be available in the response.
   *
   * @param groupIds A list of Lens Group IDs. Can be found in the CameraKit Portal.
   * @returns Resolves with a flattened list of all lenses in the desired groups. If any errors occurred during the
   * query operation, these will be included in a separate list. If errors are present, the list of Lenses may not
   * contain all the Lenses from the desired groups.
   */
  loadLensGroups(groupIds) {
    return __awaiter(this, void 0, void 0, function* () {
      const responses = yield Promise.all(groupIds.map((groupId) => __awaiter(this, void 0, void 0, function* () {
        try {
          const envelopes = yield this.lensSources.retrieveLenses({ groupId });
          const lenses2 = envelopes ? decodeEnvelopes(envelopes) : yield retrieveCameraKitLensGroup(this.lensMetadataFetchHandler, groupId, this.apiHostname);
          lenses2.forEach((lens) => this.metadataCache.set(lens.id, Object.assign(Object.assign({}, lens), { groupId })));
          return lenses2.map((lens) => toPublicLens(Object.assign(Object.assign({}, lens), { groupId })));
        } catch (error) {
          logger7.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));
          return error;
        }
      })));
      const errors = [];
      const lenses = [];
      responses.forEach((response) => Array.isArray(response) ? lenses.push(...response) : errors.push(response));
      return { errors, lenses };
    });
  }
  /**
   * Loads and caches lens content and dependencies to reduce latency when {@link CameraKitSession.applyLens} is later
   * called to apply the lens. This is an in-memory cache, it will not be persisted across page loads.
   *
   * This may useful if the application A) knows which lenses will be applied and B) has some opportunity to call
   * this method before a lens is applied. For example, if the user must perform some other actions before lenses
   * become active, this might be a good opportunity to cache lenses to improve applyLens latency.
   *
   * @example
   * ```ts
   * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
   * await cameraKit.lensRepository.cacheLensContent([lens])
   *
   * // sometime later -- this call will use the cached lens content, making lens application faster.
   * await cameraKitSession.applyLens(lens)
   * ```
   *
   * @param lenses Array of lenses to cache in memory.
   * @param assetTimingsToCache Lenses specify certain required assets that are necessary for the lens to render, and
   * other assets which may be needed by the lens. By default this method will cache all of those assets, but this
   * behavior can be modified to only load the required assets, only the "onDemand" assets, or neither (by passing
   * an empty array).
   */
  cacheLensContent(lenses, assetTimingsToCache = ["required", "onDemand"]) {
    return __awaiter(this, void 0, void 0, function* () {
      const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);
      yield Promise.all(lenses.map((lens) => __awaiter(this, void 0, void 0, function* () {
        try {
          const { lensBuffer } = yield this.getLensContent(lens);
          const { content } = this.metadataCache.get(lens.id);
          this.binariesCache.set(lens.id, lensBuffer);
          yield this.lensAssetRepository.cacheAssets(content.assetManifest, lens, assetTimingsToLoad);
        } catch (e2) {
          logger7.warn(new Error(`Failed to cache lens ${lens.id}.`, { cause: e2 }));
        }
      })));
    });
  }
  /**
   * Returns loaded Lens metadata if available.
   */
  getLensMetadata(lensId) {
    return this.metadataCache.get(lensId);
  }
  /**
   * Removes Lens content from the in-memory cache.
   */
  removeCachedLenses(lenses) {
    lenses.forEach((lens) => this.binariesCache.delete(lens.id));
  }
  /**
   * Fetches lens content and assets. This may come from the cache, otherwise network requests will be made.
   *
   * @internal
   */
  getLensContent(lens) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const { content } = (_a = this.metadataCache.get(lens.id)) !== null && _a !== void 0 ? _a : {};
      if (!content) {
        throw new Error(`Cannot find metadata for lens ${lens.id}.`);
      }
      const cachedLensBuffer = this.binariesCache.get(lens.id);
      if (cachedLensBuffer) {
        return {
          lensBuffer: cachedLensBuffer,
          lensChecksum: content.lnsSha256
        };
      }
      const [lensBuffer] = yield this.lensFetchHandler([
        // TODO: remove force-cache once https://jira.sc-corp.net/browse/CAMKIT-3671 is addressed
        new Request(content.lnsUrlBolt, { cache: "force-cache" }),
        {
          requestType: "lens_content",
          lensId: lens.id
        }
      ]);
      return { lensBuffer, lensChecksum: content.lnsSha256 };
    });
  }
};
__decorate([
  validate,
  log,
  __param(0, guard(isSafeString)),
  __param(1, guard(isSafeString)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String, String]),
  __metadata("design:returntype", Promise)
], LensRepository.prototype, "loadLens", null);
__decorate([
  validate,
  log,
  __param(0, guard(isSafeStringArray)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Array]),
  __metadata("design:returntype", Promise)
], LensRepository.prototype, "loadLensGroups", null);
__decorate([
  validate,
  log,
  __param(0, guard(isLensArray)),
  __param(1, guard(isOptionalAssetTimingArray)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Array, Array]),
  __metadata("design:returntype", Promise)
], LensRepository.prototype, "cacheLensContent", null);
var lensRepositoryFactory = Injectable("LensRepository", [
  requestStateEventTargetFactory.token,
  cameraKitServiceFetchHandlerFactory.token,
  defaultFetchHandlerFactory.token,
  lensSourcesFactory.token,
  lensAssetRepositoryFactory.token,
  configurationToken
], (requestStateEventTarget, lensMetadataFetchHandler, defaultFetchHandler, lensSources, lensAssetRepository, configuration) => {
  const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler).map(createRequestStateEmittingHandler(requestStateEventTarget)).map(createArrayBufferParsingHandler()).handler;
  return new LensRepository(lensMetadataFetchHandler, lensFetchHandler, lensSources, lensAssetRepository, configuration.apiHostname);
});

// node_modules/@snap/camera-kit/lib/dependency-injection/PartialContainer.js
var PartialContainer = class _PartialContainer {
  constructor(injectables) {
    this.injectables = injectables;
  }
  /**
   * Create a new PartialContainer which provides a Service created by the given InjectableFunction.
   *
   * The InjectableFunction contains metadata specifying the Token by which the created Service will be known, as well
   * as an ordered list of Tokens to be resolved and provided to the InjectableFunction as arguments.
   *
   * This dependencies are allowed to be missing from the PartialContainer, but these dependencies are maintained as a
   * parameter of the returned PartialContainer. This allows `[Container.provides]` to type check the dependencies and
   * ensure they can be provided by the Container.
   *
   * @param fn A InjectableFunction, taking dependencies as arguments, which returns the Service.
   */
  provides(fn) {
    return new _PartialContainer(Object.assign(Object.assign({}, this.injectables), { [fn.token]: fn }));
  }
  /**
   * In order to create a [Container], the InjectableFunctions maintained by the PartialContainer must be memoized
   * into Factories that can resolve their dependencies and return the correct Service.
   *
   * In particular, this requires access to a "parent" Container to avoid infinite looping in cases where Service A
   * depends on Service A  this is allowed (as long as the parent container provides Service A), but requires access
   * to the parent Container to provide the parent implementation of Service A.
   *
   * This also means that Services provided by a PartialContainer to a Container via this function will always be
   * scoped to the Container. In other words, if a PartialContainer containing Service A is provided to both
   * Container X and Container Y, when Service A is resolved by Container X the InjectableFunction used to create
   * Service A will be invoked  and when Service A is resolved by Container Y, the InjectableFunction will be invoked
   * again.
   *
   * @param parent A [Container] which provides all the required Dependencies of this PartialContainer.
   */
  getFactories(parent) {
    return Object.fromEntries(entries(this.injectables).map(([token, fn]) => {
      return [
        token,
        memoize((c2) => {
          return fn(...fn.dependencies.map((t2) => {
            return t2 === token ? parent.get(t2) : c2.get(t2);
          }));
        })
      ];
    }));
  }
  getTokens() {
    return Object.keys(this.injectables);
  }
};

// node_modules/@snap/camera-kit/lib/dependency-injection/Container.js
var CONTAINER = "$container";
var Container = class _Container {
  static provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer)
      return new _Container({}).provides(fnOrContainer);
    if (fnOrContainer instanceof _Container)
      return new _Container({}).provides(fnOrContainer);
    return new _Container({}).provides(fnOrContainer);
  }
  constructor(factories) {
    this.factories = {};
    for (const k2 in factories) {
      const fn = factories[k2];
      if (isMemoized(fn))
        this.factories[k2] = fn;
      else
        this.factories[k2] = memoize(fn);
    }
  }
  /**
   * Create a copy of this Container, optionally providing a list of Services which will be scoped to the copy.
   *
   * This can be useful, for example, if different parts of an application wish to use the same Service interface, but
   * do not want to share a reference to same Service instance.
   *
   * Say we have a Service which manages a list of Users. Our application wishes to display two lists of Users, which
   * may be edited independently. In this case it may be desirable to create a Container for each list component, with
   * the UserList Service scoped to those Containers  that way, each list component gets a unique copy of the
   * UserList Service that can be edited independently of the other.
   *
   * @param scopedServices A list of Tokens identifying Services which will be scoped to the new Container  that is,
   * if those Services had already been created by the source Container, they will be re-created by their Factory
   * functions when provided by the new Container.
   * @returns A new copy of this Container, sharing all of this Container's Services. Services corresponding to any
   * Tokens passed to this method will be re-created by the new Container (i.e. they become "scoped" to the new
   * Container).
   */
  copy(scopedServices) {
    const factories = Object.assign({}, this.factories);
    (scopedServices || []).forEach((token) => {
      factories[token] = this.factories[token].delegate;
    });
    return new _Container(factories);
  }
  get(token) {
    if (token === CONTAINER)
      return this;
    const factory = this.factories[token];
    if (!factory) {
      throw new Error(`[Container::get] Could not find Service for Token "${String(token)}". This should've caused a compile-time error. If the Token is 'undefined', check all your calls to the Injectable function. Make sure you define dependencies using string literals or string constants that are definitely initialized before the call to Injectable.`);
    }
    return factory(this);
  }
  run(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer) {
      const runnableContainer = this.provides(fnOrContainer);
      for (const token of fnOrContainer.getTokens()) {
        runnableContainer.get(token);
      }
    } else {
      this.provides(fnOrContainer).get(fnOrContainer.token);
    }
    return this;
  }
  provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof _Container) {
      const factories = fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;
      return new _Container(Object.assign(Object.assign({}, this.factories), factories));
    }
    return this.providesService(fnOrContainer);
  }
  providesService(fn) {
    const token = fn.token;
    const dependencies = fn.dependencies;
    const factory = memoize((container) => {
      return fn(...dependencies.map((t2) => {
        return t2 === token ? this.get(t2) : container.get(t2);
      }));
    });
    const factories = Object.assign(Object.assign({}, this.factories), { [token]: factory });
    return new _Container(factories);
  }
};

// node_modules/@snap/state-management/dist/types.js
var fromEntries = (entries2) => Object.fromEntries(entries2);

// node_modules/@snap/state-management/dist/actions.js
var defineAction = (name) => () => {
  const actionCreator = (data) => ({
    name,
    data
  });
  Object.defineProperty(actionCreator, "name", { value: name });
  return actionCreator;
};
var defineActions = (...actions) => {
  const entries2 = actions.map((s2) => [s2.name, s2]);
  return fromEntries(entries2);
};
function forActions(...actions) {
  return filter((v2) => actions.some((action) => v2[0].name === action));
}
function isAction(action, name) {
  return action.name === name;
}

// node_modules/@snap/state-management/dist/state-machine.js
var StateMachine = class {
  /**
   * Create a StateMachine with a defined set of Actions and States.
   *
   * The StateMachine begins in a given initial state with transitions to new states defined by a "reducer" function.
   *
   * Reducers are OperatorFunctions which map an Observable of `[Action, State]` pairs into an Observable of a new
   * state. They can be constructed using RxJS's `pipe` function. For example:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, pipe(
   *   inStates('someState'),
   *   forActions('someAction'),
   *   map(([a, s]) => computeNewState(a, s)),
   * ))
   * ```
   *
   * Often it will be useful to break the reducer into separate behaviors to handle different actions:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, state => {
   *   return merge(
   *     state.pipe(inStates('someState'), forAction('someAction'), map(computeNextState)),
   *     state.pipe(inStates('otherState'), forAction('otherAction'), map(computeOtherNextState)),
   *     // ...
   *   )
   * })
   * ```
   *
   * Reducers must return an output Observable<State> which, when the input Observable<[Action, State]> emits, either:
   *
   * - synchronously emits a single new state.
   * - emits nothing.
   *
   * To enforce this, reducer Observables race with a sync Observable containing the current state. If the reducer
   * Observable does not emit a new state synchronously, the current state is used (i.e. the state does not change).
   *
   * @param initialState
   * @param reducer
   * @returns
   */
  constructor(actions, states, initialState, reducer) {
    __publicField(this, "actions");
    __publicField(this, "states");
    /**
     * After an Action is dispatched, passed to the StateMachine's reducer to produce a new state (or stay in the same
     * state), a pair of [Action, State] is emitted on this Observable.
     *
     * This can be used to observe every action dispatched to the StateMachine, along with the state that it produced.
     *
     * The most common use of the `events` Observable is to implement side-effects. It's very common for side-effects
     * to dispatch actions back to the StateMachine.
     *
     * ```ts
     * stateMachine.events.pipe(
     *   inStates('idle'),
     *   forActions('makeRequest'),
     *   switchMap(([{data: request}]) => fromFetch(request)),
     *   tap(response => stateMachine.dispatch('requestComplete', response)),
     * ).subscribe()
     * ```
     */
    __publicField(this, "events");
    __publicField(this, "actionsSubject");
    __publicField(this, "eventsSubject");
    __publicField(this, "state");
    this.actions = actions;
    this.states = states;
    this.actionsSubject = new Subject();
    this.eventsSubject = new Subject();
    this.events = this.eventsSubject.asObservable();
    this.state = new BehaviorSubject(initialState);
    this.actionsSubject.pipe(withLatestFrom(this.state), mergeMap(([a2, s2]) => (
      // `NEVER` + `startWith` is needed for `raceWith` to work properly. If we instead used the more
      // typical `of([a, s])` we would encounter the following problem:
      //
      // `of` emits its value and completes synchronously (i.e. both in the same "frame," if you think in
      // marble diagrams). Assuming `reducer` does nothing to modify the completion behavior of its source
      // Observable, the Observable returned by `reducer` will also complete immediately. If we were to
      // pass that Observable to `raceWith`  whose output mirrors whichever input Observable is first to
      // emit, error, *or complete*  it would always win, even if it never emitted anything (because it
      // would already be complete).
      //
      // So instead we need an Observable that does not complete. We achieve this by using `NEVER` and
      // then starting it with `[a, s]`. Note that it's important to then use `take(1)` after `raceWith`
      // so that we don't leak Observables which never complete.
      NEVER.pipe(startWith([a2, s2]), reducer, raceWith(of(s2)), tap((newState) => {
        if (newState !== s2)
          this.state.next(newState);
      }), map((newState) => [a2, newState]), take(1))
    ))).subscribe(this.eventsSubject);
  }
  dispatch(actionOrName, data) {
    const action = typeof actionOrName === "string" ? { name: actionOrName, data } : actionOrName;
    this.actionsSubject.next(action);
  }
  /**
   * Returns the current state.
   */
  getState() {
    return this.state.getValue();
  }
};
function dispatch(stateMachine) {
  return (source) => new Observable((subscriber) => {
    const subscription = stateMachine.events.subscribe(subscriber);
    subscription.add(source.subscribe({
      next: (action) => stateMachine.dispatch(action),
      error: (error) => subscriber.error(error)
      // We purposely do not forward the `complete` notification. We want the subscriber to remain subscribed to
      // the stateMachine.events observable even if the source Observable<Actions> completes.
    }));
    return subscription;
  });
}

// node_modules/@snap/state-management/dist/states.js
var defineState = (name) => () => defineAction(name)();
var defineStates = (...states) => defineActions(...states);
function inStates(...states) {
  return filter((v2) => states.some((state) => v2[1].name === state));
}
function isState(state, name) {
  return state.name === name;
}

// node_modules/@snap/camera-kit/lib/transforms/Transform2D.js
var Transform2D = class {
  /**
   * @param matrix A 3x3 matrix in column-major order, representing a 2D transform to be applied to the source media
   */
  constructor(matrix) {
    this.matrix = matrix;
  }
};
Transform2D.MirrorX = new Transform2D([-1, 0, 0, 0, 1, 0, 1, 0, 1]);
Transform2D.MirrorY = new Transform2D([1, 0, 0, 0, -1, 0, 0, 1, 1]);
Transform2D.Identity = new Transform2D([1, 0, 0, 0, 1, 0, 0, 0, 1]);

// node_modules/@snap/camera-kit/lib/media-sources/CameraKitSource.js
var defaultDeviceInfo = {
  cameraType: "user",
  fpsLimit: Number.POSITIVE_INFINITY
};
var createNotAttachedError = (message) => new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);
var CameraKitSource = class _CameraKitSource {
  constructor(sourceInfo, subscriber = {}, deviceInfo = {}) {
    this.sourceInfo = sourceInfo;
    this.subscriber = subscriber;
    this.deviceInfo = Object.assign(Object.assign({}, defaultDeviceInfo), copyDefinedProperties(deviceInfo));
  }
  /**
   * Called by {@link CameraKitSession} when this source is set as that session's source.
   *
   * @param lensCore
   * @param reportError Calling this function will report an error back to the session.
   * @returns Rejects if any calls to LensCore or CameraKitSource.subscriber.onAttach fail.
   * @internal
   */
  attach(lensCore, reportError) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.lensCore) {
        throw new Error("Cannot attach. This CameraKitCustomSource has already been attached to a CameraKitSession. To re-attach, create a copy of this CameraKitCustomSource.");
      }
      this.lensCore = lensCore;
      yield lensCore.useMediaElement({
        autoplayNewMedia: false,
        autoplayPreviewCanvas: false,
        media: this.sourceInfo.media,
        pauseExistingMedia: false,
        replayTrackingData: this.sourceInfo.replayTrackingData,
        requestWebcam: false,
        startOnFrontCamera: ["user", "front"].includes(this.deviceInfo.cameraType),
        useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing
      });
      const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;
      yield lensCore.setFPSLimit({ fps });
      if (this.subscriber.onAttach)
        yield this.subscriber.onAttach(this, lensCore, reportError);
    });
  }
  copy(deviceInfo = {}) {
    return new _CameraKitSource(this.sourceInfo, this.subscriber, Object.assign(Object.assign({}, this.deviceInfo), deviceInfo));
  }
  /**
   * Called by {@link CameraKitSession} when it must remove this source.
   *
   * @param reportError Calling this function will report an error back to the session.
   * @returns
   * @internal
   */
  detach(reportError) {
    if (!this.lensCore)
      return Promise.reject(createNotAttachedError("Cannot detach"));
    if (this.subscriber.onDetach)
      return this.subscriber.onDetach(reportError);
  }
  /**
   * Set the resolution used to render this source.
   *
   * Its important to distinguish render size from display size. The size at which the output canvases are displayed
   * on a web page is determined by the CSS of the page. It is distinct from the size at which LensCore renders
   * Lenses. Performance is dominated by render size, while any display scaling can most often be thought of as free.
   *
   * If greater performance is required, a smaller render size may boost frame-rate. It does come at a cost, including
   * loss of accuracy in various tracking and computer-vision algorithms (since they'll be operating on fewer pixels).
   *
   * The size of the Live and Capture {@link RenderTarget} is always the same.
   *
   * @todo Currently it's only valid to call `setRenderSize` after `CameraKitSession.play` has been called. This
   * constraint should be removed, so callers don't have to understand the underlying LensCore state machine.
   *
   * @param width pixels
   * @param height pixels
   * @returns Promise resolves when the render size has been successfully updated.
   */
  setRenderSize(width2, height2) {
    if (!this.lensCore)
      return Promise.reject(createNotAttachedError("Cannot setRenderSize"));
    const target = { width: width2, height: height2 };
    return this.lensCore.setRenderSize({ mode: "explicit", target });
  }
  /**
   * Apply a 2D transformation to the source (e.g. translation, rotation, scale).
   *
   * @param transform Specifies the 3x3 matrix describing the transformation.
   */
  setTransform(transform) {
    if (!this.lensCore)
      return Promise.reject(createNotAttachedError("Cannot setTransform"));
    const matrix = new Float32Array(transform.matrix);
    return this.lensCore.setInputTransform({ matrix });
  }
};
__decorate([
  validate,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Number, Number]),
  __metadata("design:returntype", Promise)
], CameraKitSource.prototype, "setRenderSize", null);
__decorate([
  validate,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Transform2D]),
  __metadata("design:returntype", Promise)
], CameraKitSource.prototype, "setTransform", null);

// node_modules/@snap/camera-kit/lib/media-sources/MediaStreamSource.js
var defaultOptions3 = {
  transform: Transform2D.Identity,
  disableSourceAudio: false
};
function closeWorklet(worklet) {
  if (!worklet)
    return;
  worklet.port.close();
  worklet.port.onmessage = null;
  worklet.disconnect();
}
function closeAudioContext(audioContext) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!audioContext || audioContext.state === "closed")
      return;
    return audioContext.close();
  });
}
function createUserMediaSource(constraints = { video: true }, options = {}) {
  return __awaiter(this, void 0, void 0, function* () {
    const stream = yield navigator.mediaDevices.getUserMedia(constraints);
    return createMediaStreamSource(stream, Object.assign({ transform: Transform2D.MirrorX, cameraType: "front" }, options));
  });
}
function createMediaStreamSource(stream, options = {}) {
  var _a;
  const { width: width2, height: height2, facingMode } = stream.getVideoTracks().length > 0 ? stream.getVideoTracks()[0].getSettings() : { width: 0, height: 0, facingMode: void 0 };
  const detectedCameraType = facingMode === "user" || facingMode === "environment" ? facingMode : void 0;
  const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaultOptions3), options), { cameraType: (_a = options.cameraType) !== null && _a !== void 0 ? _a : detectedCameraType });
  const enableSourceAudio = stream.getAudioTracks().length > 0 && !optionsWithDefaults.disableSourceAudio;
  const simulateStereoAudio = true;
  const sampleRate = 44100;
  let audioContext = void 0;
  let audioSource = void 0;
  let worklet = void 0;
  let microphoneRecorderUrl;
  if (enableSourceAudio) {
    const microphoneRecorderWorklet = `
        class MicrophoneWorkletProcessor extends AudioWorkletProcessor {
            process(inputs, outputs, parameters) {
                this.port.postMessage({
                    eventType: 'data',
                    buffer: inputs
                });
                return true;
            }
        }
        registerProcessor('microphone-worklet', MicrophoneWorkletProcessor);`;
    const microphoneRecorderBlob = new Blob([microphoneRecorderWorklet], {
      type: "application/javascript"
    });
    microphoneRecorderUrl = URL.createObjectURL(microphoneRecorderBlob);
  }
  return new CameraKitSource({ media: stream }, {
    onAttach: (source, lensCore, reportError) => __awaiter(this, void 0, void 0, function* () {
      if (width2 !== void 0 && height2 !== void 0)
        yield source.setRenderSize(width2, height2);
      yield source.setTransform(optionsWithDefaults.transform);
      if (enableSourceAudio) {
        yield lensCore.setAudioParameters({
          parameters: {
            numChannels: simulateStereoAudio ? 2 : 1,
            sampleRate
          }
        });
        try {
          closeWorklet(worklet);
          audioSource === null || audioSource === void 0 ? void 0 : audioSource.disconnect();
          yield closeAudioContext(audioContext);
        } catch (error) {
          reportError(ensureError(error));
        }
        audioContext = new AudioContext();
        audioSource = audioContext.createMediaStreamSource(stream);
        const scopedAudioSource = audioSource;
        audioContext.audioWorklet.addModule(microphoneRecorderUrl).then(() => {
          if (audioContext) {
            worklet = new AudioWorkletNode(audioContext, "microphone-worklet");
            scopedAudioSource.connect(worklet);
            worklet.connect(audioContext.destination);
            worklet.port.onmessage = (e2) => {
              if (e2.data.eventType === "data") {
                const leftSamples = e2.data.buffer[0][0];
                if (!leftSamples)
                  return;
                let inputBuffers = [leftSamples];
                if (simulateStereoAudio) {
                  const rightSamples = e2.data.buffer[0].length > 1 ? e2.data.buffer[0][1] : leftSamples.slice();
                  inputBuffers.push(rightSamples);
                }
                lensCore.processAudioSampleBuffer({ input: inputBuffers }).catch(reportError);
              }
            };
          }
        }).catch((error) => {
          reportError(error);
        });
      }
    }),
    onDetach: (reportError) => __awaiter(this, void 0, void 0, function* () {
      if (worklet) {
        closeWorklet(worklet);
        worklet = void 0;
      }
      if (audioSource) {
        audioSource.disconnect();
        audioSource = void 0;
      }
      if (audioContext) {
        yield closeAudioContext(audioContext).catch(reportError);
        audioContext = void 0;
      }
    })
  }, optionsWithDefaults);
}

// node_modules/@snap/camera-kit/lib/media-sources/VideoSource.js
var defaultOptions4 = {
  trackingData: new ArrayBuffer(0)
};
function createVideoSource(video, options = {}) {
  const { trackingData } = Object.assign(Object.assign({}, defaultOptions4), options);
  const replayTrackingData = trackingData.byteLength > 0 ? { buffer: trackingData } : void 0;
  return new CameraKitSource({
    media: video,
    replayTrackingData
  }, {
    onAttach: (source) => {
      const [width2, height2] = video.width === 0 || video.height === 0 ? [video.videoWidth, video.videoHeight] : [video.width, video.height];
      return source.setRenderSize(width2, height2);
    }
  }, options);
}

// node_modules/@snap/camera-kit/lib/logger/logEntries.js
var logEntriesFactory = Injectable("logEntries", () => resetLogger().asObservable());

// node_modules/@snap/camera-kit/lib/session/LensPerformanceMeasurement.js
var getDefaultFrameMetricsState = () => ({
  avgFps: 0,
  averageProcessingTime: 0,
  n: 0,
  processingTimeBuckets: new Uint32Array(frameProcessingTimeMedianMax + 1),
  procFrameCount: 0,
  procFrameMean: 0,
  procFrameD2: 0
});
var frameDurationThreshold = 1;
var frameProcessingTimeMedianMax = 200;
var LensPerformanceMeasurement = class {
  constructor(instances) {
    this.instances = instances;
    this.state = Object.assign({}, getDefaultFrameMetricsState());
    this.instances.add(this);
  }
  /** @internal */
  update(processingTimeMs) {
    this.computeRunningStats(processingTimeMs);
  }
  /**
   * Return a {@link ComputedFrameMetrics} object, containing lens performance metrics.
   *
   * This method may be called multiple times, each time reporting values computed since the time when this instance
   * was created.
   */
  measure() {
    let median = 0;
    let count2 = 0;
    for (; median < this.state.processingTimeBuckets.length; median++) {
      count2 += this.state.processingTimeBuckets[median];
      if (count2 >= (this.state.n + 1) / 2)
        break;
    }
    return {
      avgFps: this.state.avgFps,
      lensFrameProcessingTimeMsAvg: this.state.procFrameMean,
      lensFrameProcessingTimeMsStd: Math.sqrt(this.state.procFrameD2 / this.state.procFrameCount),
      lensFrameProcessingTimeMsMedian: this.state.n > 0 ? median : 0,
      lensFrameProcessingN: this.state.n
    };
  }
  /**
   * Reset the measured perforamance statistics (averages, std deviations). This is equivalent to using
   * {@link LensPerformanceMetrics.beginMeasurement} to create a new LensPerformanceMeasurement instance, but may be
   * more convenient.
   */
  reset() {
    this.state = Object.assign({}, getDefaultFrameMetricsState());
  }
  /**
   * Stop measuring performance statistics.
   *
   * This instance will not be garbage collected until this method is called. Therefore it is important to call this
   * method at the appropriate time to avoid leaking memory -- particularly if your application creates many
   * LensPerformanceMeasurement instances.
   */
  end() {
    this.instances.delete(this);
  }
  /**
   * In order to calculate the mean, variance, and standard deviation for the processing times
   *  we are using Welford's online algorithm.
   * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm
   *
   * @param processingTimeMs Processing time that is returned from registered callback
   */
  computeRunningStats(processingTimeMs) {
    const delta = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameCount += 1;
    this.state.procFrameMean += delta / this.state.procFrameCount;
    const delta2 = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameD2 += delta * delta2;
    if (this.priorFrameCompletedTime === void 0) {
      this.priorFrameCompletedTime = performance.now();
    } else {
      const frameDurationSec = (performance.now() - this.priorFrameCompletedTime) / 1e3;
      if (frameDurationSec < frameDurationThreshold) {
        this.state.avgFps = (this.state.avgFps + 1 / frameDurationSec) / 2;
      }
      this.priorFrameCompletedTime = performance.now();
    }
    this.state.n++;
    this.state.processingTimeBuckets[Math.min(Math.round(processingTimeMs), frameProcessingTimeMedianMax)]++;
  }
};

// node_modules/@snap/camera-kit/lib/session/LensPerformanceMetrics.js
var logger8 = getLogger("RenderingMetrics");
var log2 = errorLoggingDecorator(logger8);
var LensPerformanceMetrics = class {
  /** @internal */
  constructor(lensCore) {
    this.lensCore = lensCore;
    this.measurementInstances = /* @__PURE__ */ new Set();
    this.lensCore.setOnFrameProcessedCallback({
      onFrameProcessed: ({ processingTimeMs }) => {
        try {
          for (const measurement of this.measurementInstances.values()) {
            measurement.update(processingTimeMs);
          }
        } catch (error) {
          logger8.error(error);
        }
      }
    }).catch((error) => logger8.error(`Failed registering setOnFrameProcessedCallback with error: ${error.message}`));
  }
  /**
   * Begin a measurement window, during which time rendering metrics will be gathered.
   *
   * @returns A {@link LensPerformanceMeasurement} representing an ongoing measurement of aggregated rendering
   * metrics, from which specific metrics can be obtained.
   */
  beginMeasurement() {
    return new LensPerformanceMeasurement(this.measurementInstances);
  }
};
__decorate([
  log2,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", LensPerformanceMeasurement)
], LensPerformanceMetrics.prototype, "beginMeasurement", null);

// node_modules/@snap/camera-kit/lib/lens/LensPersistenceStore.js
var logger9 = getLogger("LensPersistenceStore");
var lensPersistenceStoreFactory = Injectable("lensPersistenceStore", [lensCoreFactory.token], (lensCore) => {
  const db = new IndexedDBPersistence({ databaseName: "lensPersistenceStore" });
  lensCore.registerSavePersistentStoreCallback((id2, data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield db.store(id2, data);
    } catch (error) {
      logger9.error(persistentStoreError(`Error occurred while storing data for lens ${id2}.`, error));
    }
  }));
  return db;
});

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/launchdata.js
var import_long29 = __toESM(require_long());
var import_minimal29 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/snappable.js
var import_long22 = __toESM(require_long());
var import_minimal22 = __toESM(require_minimal2());
var EncryptionData_EncryptionScheme;
(function(EncryptionData_EncryptionScheme2) {
  EncryptionData_EncryptionScheme2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  EncryptionData_EncryptionScheme2["SPOOKEY"] = "SPOOKEY";
  EncryptionData_EncryptionScheme2["REGISTRY"] = "REGISTRY";
  EncryptionData_EncryptionScheme2["FIDELIUS"] = "FIDELIUS";
  EncryptionData_EncryptionScheme2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(EncryptionData_EncryptionScheme || (EncryptionData_EncryptionScheme = {}));
function encryptionData_EncryptionSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "NOT_APPLICABLE":
      return EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    case 1:
    case "SPOOKEY":
      return EncryptionData_EncryptionScheme.SPOOKEY;
    case 2:
    case "REGISTRY":
      return EncryptionData_EncryptionScheme.REGISTRY;
    case 3:
    case "FIDELIUS":
      return EncryptionData_EncryptionScheme.FIDELIUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EncryptionData_EncryptionScheme.UNRECOGNIZED;
  }
}
function encryptionData_EncryptionSchemeToNumber(object) {
  switch (object) {
    case EncryptionData_EncryptionScheme.NOT_APPLICABLE:
      return 0;
    case EncryptionData_EncryptionScheme.SPOOKEY:
      return 1;
    case EncryptionData_EncryptionScheme.REGISTRY:
      return 2;
    case EncryptionData_EncryptionScheme.FIDELIUS:
      return 3;
    default:
      return 0;
  }
}
var SnappableMessage_ReplyType;
(function(SnappableMessage_ReplyType2) {
  SnappableMessage_ReplyType2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  SnappableMessage_ReplyType2["CONTEXT"] = "CONTEXT";
  SnappableMessage_ReplyType2["INTERSTITIAL"] = "INTERSTITIAL";
  SnappableMessage_ReplyType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(SnappableMessage_ReplyType || (SnappableMessage_ReplyType = {}));
function createBaseEncryptionData() {
  return {
    key: new Uint8Array(),
    ivStore: {},
    isKeyServerEncrypted: false,
    isKeyE2eEncrypted: false,
    encryptionScheme: EncryptionData_EncryptionScheme.NOT_APPLICABLE
  };
}
var EncryptionData = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    Object.entries(message.ivStore).forEach(([key, value]) => {
      EncryptionData_IvStoreEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.isKeyServerEncrypted === true) {
      writer.uint32(24).bool(message.isKeyServerEncrypted);
    }
    if (message.isKeyE2eEncrypted === true) {
      writer.uint32(32).bool(message.isKeyE2eEncrypted);
    }
    if (message.encryptionScheme !== EncryptionData_EncryptionScheme.NOT_APPLICABLE) {
      writer.uint32(40).int32(encryptionData_EncryptionSchemeToNumber(message.encryptionScheme));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;
        case 2:
          const entry2 = EncryptionData_IvStoreEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.ivStore[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.isKeyServerEncrypted = reader.bool();
          break;
        case 4:
          message.isKeyE2eEncrypted = reader.bool();
          break;
        case 5:
          message.encryptionScheme = encryptionData_EncryptionSchemeFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseEncryptionData();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
    message.ivStore = Object.entries((_b = object.ivStore) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.isKeyServerEncrypted = (_c = object.isKeyServerEncrypted) !== null && _c !== void 0 ? _c : false;
    message.isKeyE2eEncrypted = (_d = object.isKeyE2eEncrypted) !== null && _d !== void 0 ? _d : false;
    message.encryptionScheme = (_e = object.encryptionScheme) !== null && _e !== void 0 ? _e : EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    return message;
  }
};
function createBaseEncryptionData_IvStoreEntry() {
  return { key: "", value: new Uint8Array() };
}
var EncryptionData_IvStoreEntry = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData_IvStoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseEncryptionData_IvStoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
function createBasePlayerData() {
  return { store: {}, serializedStore: new Uint8Array() };
}
var PlayerData = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    Object.entries(message.store).forEach(([key, value]) => {
      PlayerData_StoreEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.serializedStore.length !== 0) {
      writer.uint32(18).bytes(message.serializedStore);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = PlayerData_StoreEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.store[entry1.key] = entry1.value;
          }
          break;
        case 2:
          message.serializedStore = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData();
    message.store = Object.entries((_a = object.store) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.serializedStore = (_b = object.serializedStore) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  }
};
function createBasePlayerData_StoreEntry() {
  return { key: "", value: "" };
}
var PlayerData_StoreEntry = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData_StoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData_StoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseSessionData() {
  return { playerData: {} };
}
var SessionData = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    Object.entries(message.playerData).forEach(([key, value]) => {
      SessionData_PlayerDataEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = SessionData_PlayerDataEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.playerData[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData();
    message.playerData = Object.entries((_a = object.playerData) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = PlayerData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseSessionData_PlayerDataEntry() {
  return { key: "", value: void 0 };
}
var SessionData_PlayerDataEntry = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      PlayerData.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData_PlayerDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = PlayerData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData_PlayerDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? PlayerData.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseSnappable() {
  return {
    id: "",
    sessionId: "",
    playerId: "",
    sessionData: void 0,
    createdTime: 0,
    expireTime: 0,
    version: 0,
    encryptionData: void 0,
    sessionDepth: 0
  };
}
var Snappable = {
  encode(message, writer = import_minimal22.default.Writer.create()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.sessionData !== void 0) {
      SessionData.encode(message.sessionData, writer.uint32(34).fork()).ldelim();
    }
    if (message.createdTime !== 0) {
      writer.uint32(40).int64(message.createdTime);
    }
    if (message.expireTime !== 0) {
      writer.uint32(48).int64(message.expireTime);
    }
    if (message.version !== 0) {
      writer.uint32(56).int32(message.version);
    }
    if (message.encryptionData !== void 0) {
      EncryptionData.encode(message.encryptionData, writer.uint32(66).fork()).ldelim();
    }
    if (message.sessionDepth !== 0) {
      writer.uint32(72).int32(message.sessionDepth);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal22.default.Reader ? input : new import_minimal22.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnappable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.sessionId = reader.string();
          break;
        case 3:
          message.playerId = reader.string();
          break;
        case 4:
          message.sessionData = SessionData.decode(reader, reader.uint32());
          break;
        case 5:
          message.createdTime = longToNumber7(reader.int64());
          break;
        case 6:
          message.expireTime = longToNumber7(reader.int64());
          break;
        case 7:
          message.version = reader.int32();
          break;
        case 8:
          message.encryptionData = EncryptionData.decode(reader, reader.uint32());
          break;
        case 9:
          message.sessionDepth = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseSnappable();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.sessionId = (_b = object.sessionId) !== null && _b !== void 0 ? _b : "";
    message.playerId = (_c = object.playerId) !== null && _c !== void 0 ? _c : "";
    message.sessionData = object.sessionData !== void 0 && object.sessionData !== null ? SessionData.fromPartial(object.sessionData) : void 0;
    message.createdTime = (_d = object.createdTime) !== null && _d !== void 0 ? _d : 0;
    message.expireTime = (_e = object.expireTime) !== null && _e !== void 0 ? _e : 0;
    message.version = (_f = object.version) !== null && _f !== void 0 ? _f : 0;
    message.encryptionData = object.encryptionData !== void 0 && object.encryptionData !== null ? EncryptionData.fromPartial(object.encryptionData) : void 0;
    message.sessionDepth = (_g = object.sessionDepth) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};
var globalThis12 = (() => {
  if (typeof globalThis12 !== "undefined")
    return globalThis12;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function longToNumber7(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis12.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal22.default.util.Long !== import_long22.default) {
  import_minimal22.default.util.Long = import_long22.default;
  import_minimal22.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/lures.js
var import_long25 = __toESM(require_long());
var import_minimal25 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/geocircle.js
var import_long24 = __toESM(require_long());
var import_minimal24 = __toESM(require_minimal2());

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/geopoint.js
var import_long23 = __toESM(require_long());
var import_minimal23 = __toESM(require_minimal2());
function createBaseGeopoint() {
  return { latitude: 0, longitude: 0 };
}
var Geopoint = {
  encode(message, writer = import_minimal23.default.Writer.create()) {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal23.default.Reader ? input : new import_minimal23.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeopoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.latitude = reader.double();
          break;
        case 2:
          message.longitude = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGeopoint();
    message.latitude = (_a = object.latitude) !== null && _a !== void 0 ? _a : 0;
    message.longitude = (_b = object.longitude) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
if (import_minimal23.default.util.Long !== import_long23.default) {
  import_minimal23.default.util.Long = import_long23.default;
  import_minimal23.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/geocircle.js
function createBaseGeocircle() {
  return { radius: 0, center: void 0 };
}
var Geocircle = {
  encode(message, writer = import_minimal24.default.Writer.create()) {
    if (message.radius !== 0) {
      writer.uint32(9).double(message.radius);
    }
    if (message.center !== void 0) {
      Geopoint.encode(message.center, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal24.default.Reader ? input : new import_minimal24.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeocircle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.radius = reader.double();
          break;
        case 2:
          message.center = Geopoint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGeocircle();
    message.radius = (_a = object.radius) !== null && _a !== void 0 ? _a : 0;
    message.center = object.center !== void 0 && object.center !== null ? Geopoint.fromPartial(object.center) : void 0;
    return message;
  }
};
if (import_minimal24.default.util.Long !== import_long24.default) {
  import_minimal24.default.util.Long = import_long24.default;
  import_minimal24.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/lures.js
function createBaseLures() {
  return { locations: [], activeLure: void 0, closestLure: void 0 };
}
var Lures = {
  encode(message, writer = import_minimal25.default.Writer.create()) {
    for (const v2 of message.locations) {
      Geocircle.encode(v2, writer.uint32(10).fork()).ldelim();
    }
    if (message.activeLure !== void 0) {
      Geocircle.encode(message.activeLure, writer.uint32(18).fork()).ldelim();
    }
    if (message.closestLure !== void 0) {
      Geocircle.encode(message.closestLure, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal25.default.Reader ? input : new import_minimal25.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.locations.push(Geocircle.decode(reader, reader.uint32()));
          break;
        case 2:
          message.activeLure = Geocircle.decode(reader, reader.uint32());
          break;
        case 3:
          message.closestLure = Geocircle.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLures();
    message.locations = ((_a = object.locations) === null || _a === void 0 ? void 0 : _a.map((e2) => Geocircle.fromPartial(e2))) || [];
    message.activeLure = object.activeLure !== void 0 && object.activeLure !== null ? Geocircle.fromPartial(object.activeLure) : void 0;
    message.closestLure = object.closestLure !== void 0 && object.closestLure !== null ? Geocircle.fromPartial(object.closestLure) : void 0;
    return message;
  }
};
if (import_minimal25.default.util.Long !== import_long25.default) {
  import_minimal25.default.util.Long = import_long25.default;
  import_minimal25.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/user_data.js
var import_long26 = __toESM(require_long());
var import_minimal26 = __toESM(require_minimal2());
var UserData_Zodiac;
(function(UserData_Zodiac2) {
  UserData_Zodiac2["Invalid"] = "Invalid";
  UserData_Zodiac2["Aquarius"] = "Aquarius";
  UserData_Zodiac2["Aries"] = "Aries";
  UserData_Zodiac2["Cancer"] = "Cancer";
  UserData_Zodiac2["Capricorn"] = "Capricorn";
  UserData_Zodiac2["Gemini"] = "Gemini";
  UserData_Zodiac2["Leo"] = "Leo";
  UserData_Zodiac2["Libra"] = "Libra";
  UserData_Zodiac2["Pisces"] = "Pisces";
  UserData_Zodiac2["Sagittarius"] = "Sagittarius";
  UserData_Zodiac2["Scorpio"] = "Scorpio";
  UserData_Zodiac2["Taurus"] = "Taurus";
  UserData_Zodiac2["Virgo"] = "Virgo";
  UserData_Zodiac2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(UserData_Zodiac || (UserData_Zodiac = {}));
function userData_ZodiacFromJSON(object) {
  switch (object) {
    case 0:
    case "Invalid":
      return UserData_Zodiac.Invalid;
    case 1:
    case "Aquarius":
      return UserData_Zodiac.Aquarius;
    case 2:
    case "Aries":
      return UserData_Zodiac.Aries;
    case 3:
    case "Cancer":
      return UserData_Zodiac.Cancer;
    case 4:
    case "Capricorn":
      return UserData_Zodiac.Capricorn;
    case 5:
    case "Gemini":
      return UserData_Zodiac.Gemini;
    case 6:
    case "Leo":
      return UserData_Zodiac.Leo;
    case 7:
    case "Libra":
      return UserData_Zodiac.Libra;
    case 8:
    case "Pisces":
      return UserData_Zodiac.Pisces;
    case 9:
    case "Sagittarius":
      return UserData_Zodiac.Sagittarius;
    case 10:
    case "Scorpio":
      return UserData_Zodiac.Scorpio;
    case 11:
    case "Taurus":
      return UserData_Zodiac.Taurus;
    case 12:
    case "Virgo":
      return UserData_Zodiac.Virgo;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserData_Zodiac.UNRECOGNIZED;
  }
}
function userData_ZodiacToNumber(object) {
  switch (object) {
    case UserData_Zodiac.Invalid:
      return 0;
    case UserData_Zodiac.Aquarius:
      return 1;
    case UserData_Zodiac.Aries:
      return 2;
    case UserData_Zodiac.Cancer:
      return 3;
    case UserData_Zodiac.Capricorn:
      return 4;
    case UserData_Zodiac.Gemini:
      return 5;
    case UserData_Zodiac.Leo:
      return 6;
    case UserData_Zodiac.Libra:
      return 7;
    case UserData_Zodiac.Pisces:
      return 8;
    case UserData_Zodiac.Sagittarius:
      return 9;
    case UserData_Zodiac.Scorpio:
      return 10;
    case UserData_Zodiac.Taurus:
      return 11;
    case UserData_Zodiac.Virgo:
      return 12;
    default:
      return 0;
  }
}
function createBaseBitmojiUserInfo() {
  return { avatarId: "", selfieId: "" };
}
var BitmojiUserInfo = {
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.avatarId !== "") {
      writer.uint32(10).string(message.avatarId);
    }
    if (message.selfieId !== "") {
      writer.uint32(18).string(message.selfieId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBitmojiUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarId = reader.string();
          break;
        case 2:
          message.selfieId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBitmojiUserInfo();
    message.avatarId = (_a = object.avatarId) !== null && _a !== void 0 ? _a : "";
    message.selfieId = (_b = object.selfieId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseFriendUserInfo() {
  return { friendshipStart: void 0, lastInteraction: void 0, streak: 0 };
}
var FriendUserInfo = {
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.friendshipStart !== void 0) {
      Timestamp.encode(toTimestamp3(message.friendshipStart), writer.uint32(10).fork()).ldelim();
    }
    if (message.lastInteraction !== void 0) {
      Timestamp.encode(toTimestamp3(message.lastInteraction), writer.uint32(18).fork()).ldelim();
    }
    if (message.streak !== 0) {
      writer.uint32(24).uint32(message.streak);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFriendUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friendshipStart = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          break;
        case 2:
          message.lastInteraction = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.streak = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFriendUserInfo();
    message.friendshipStart = (_a = object.friendshipStart) !== null && _a !== void 0 ? _a : void 0;
    message.lastInteraction = (_b = object.lastInteraction) !== null && _b !== void 0 ? _b : void 0;
    message.streak = (_c = object.streak) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseUserData() {
  return {
    userId: "",
    username: "",
    birthdate: "",
    displayName: "",
    countrycode: "",
    score: 0,
    bitmojiInfo: void 0,
    friendInfo: void 0,
    zodiac: UserData_Zodiac.Invalid
  };
}
var UserData = {
  encode(message, writer = import_minimal26.default.Writer.create()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.birthdate !== "") {
      writer.uint32(26).string(message.birthdate);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.countrycode !== "") {
      writer.uint32(42).string(message.countrycode);
    }
    if (message.score !== 0) {
      writer.uint32(56).uint64(message.score);
    }
    if (message.bitmojiInfo !== void 0) {
      BitmojiUserInfo.encode(message.bitmojiInfo, writer.uint32(66).fork()).ldelim();
    }
    if (message.friendInfo !== void 0) {
      FriendUserInfo.encode(message.friendInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.zodiac !== UserData_Zodiac.Invalid) {
      writer.uint32(80).int32(userData_ZodiacToNumber(message.zodiac));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal26.default.Reader ? input : new import_minimal26.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.userId = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.birthdate = reader.string();
          break;
        case 4:
          message.displayName = reader.string();
          break;
        case 5:
          message.countrycode = reader.string();
          break;
        case 7:
          message.score = longToNumber8(reader.uint64());
          break;
        case 8:
          message.bitmojiInfo = BitmojiUserInfo.decode(reader, reader.uint32());
          break;
        case 9:
          message.friendInfo = FriendUserInfo.decode(reader, reader.uint32());
          break;
        case 10:
          message.zodiac = userData_ZodiacFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseUserData();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : "";
    message.birthdate = (_c = object.birthdate) !== null && _c !== void 0 ? _c : "";
    message.displayName = (_d = object.displayName) !== null && _d !== void 0 ? _d : "";
    message.countrycode = (_e = object.countrycode) !== null && _e !== void 0 ? _e : "";
    message.score = (_f = object.score) !== null && _f !== void 0 ? _f : 0;
    message.bitmojiInfo = object.bitmojiInfo !== void 0 && object.bitmojiInfo !== null ? BitmojiUserInfo.fromPartial(object.bitmojiInfo) : void 0;
    message.friendInfo = object.friendInfo !== void 0 && object.friendInfo !== null ? FriendUserInfo.fromPartial(object.friendInfo) : void 0;
    message.zodiac = (_g = object.zodiac) !== null && _g !== void 0 ? _g : UserData_Zodiac.Invalid;
    return message;
  }
};
var globalThis13 = (() => {
  if (typeof globalThis13 !== "undefined")
    return globalThis13;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
function toTimestamp3(date) {
  const seconds = date.getTime() / 1e3;
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp4(t2) {
  let millis = t2.seconds * 1e3;
  millis += t2.nanos / 1e6;
  return new Date(millis);
}
function longToNumber8(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis13.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal26.default.util.Long !== import_long26.default) {
  import_minimal26.default.util.Long = import_long26.default;
  import_minimal26.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/persistent_store.js
var import_long27 = __toESM(require_long());
var import_minimal27 = __toESM(require_minimal2());
function createBasePersistentStore() {
  return { store: new Uint8Array() };
}
var PersistentStore = {
  encode(message, writer = import_minimal27.default.Writer.create()) {
    if (message.store.length !== 0) {
      writer.uint32(10).bytes(message.store);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal27.default.Reader ? input : new import_minimal27.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePersistentStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.store = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBasePersistentStore();
    message.store = (_a = object.store) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
if (import_minimal27.default.util.Long !== import_long27.default) {
  import_minimal27.default.util.Long = import_long27.default;
  import_minimal27.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/launch_params.js
var import_long28 = __toESM(require_long());
var import_minimal28 = __toESM(require_minimal2());
function createBaseLaunchParams() {
  return { data: new Uint8Array() };
}
var LaunchParams = {
  encode(message, writer = import_minimal28.default.Writer.create()) {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal28.default.Reader ? input : new import_minimal28.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLaunchParams();
    message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
    return message;
  }
};
if (import_minimal28.default.util.Long !== import_long28.default) {
  import_minimal28.default.util.Long = import_long28.default;
  import_minimal28.default.configure();
}

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/launchdata.js
var LaunchData_EntryPoint;
(function(LaunchData_EntryPoint2) {
  LaunchData_EntryPoint2["LIVE_CAMERA"] = "LIVE_CAMERA";
  LaunchData_EntryPoint2["STORY_REPLY"] = "STORY_REPLY";
  LaunchData_EntryPoint2["CHAT_REPLY"] = "CHAT_REPLY";
  LaunchData_EntryPoint2["RESTART"] = "RESTART";
  LaunchData_EntryPoint2["PREVIEW_CANCEL"] = "PREVIEW_CANCEL";
  LaunchData_EntryPoint2["MAP"] = "MAP";
  LaunchData_EntryPoint2["BITMOJI_STICKERS"] = "BITMOJI_STICKERS";
  LaunchData_EntryPoint2["POST_CAPTURE_PREVIEW"] = "POST_CAPTURE_PREVIEW";
  LaunchData_EntryPoint2["POST_CAPTURE_TRANSCODING"] = "POST_CAPTURE_TRANSCODING";
  LaunchData_EntryPoint2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_EntryPoint || (LaunchData_EntryPoint = {}));
function launchData_EntryPointFromJSON(object) {
  switch (object) {
    case 0:
    case "LIVE_CAMERA":
      return LaunchData_EntryPoint.LIVE_CAMERA;
    case 1:
    case "STORY_REPLY":
      return LaunchData_EntryPoint.STORY_REPLY;
    case 2:
    case "CHAT_REPLY":
      return LaunchData_EntryPoint.CHAT_REPLY;
    case 3:
    case "RESTART":
      return LaunchData_EntryPoint.RESTART;
    case 4:
    case "PREVIEW_CANCEL":
      return LaunchData_EntryPoint.PREVIEW_CANCEL;
    case 5:
    case "MAP":
      return LaunchData_EntryPoint.MAP;
    case 6:
    case "BITMOJI_STICKERS":
      return LaunchData_EntryPoint.BITMOJI_STICKERS;
    case 7:
    case "POST_CAPTURE_PREVIEW":
      return LaunchData_EntryPoint.POST_CAPTURE_PREVIEW;
    case 8:
    case "POST_CAPTURE_TRANSCODING":
      return LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_EntryPoint.UNRECOGNIZED;
  }
}
function launchData_EntryPointToNumber(object) {
  switch (object) {
    case LaunchData_EntryPoint.LIVE_CAMERA:
      return 0;
    case LaunchData_EntryPoint.STORY_REPLY:
      return 1;
    case LaunchData_EntryPoint.CHAT_REPLY:
      return 2;
    case LaunchData_EntryPoint.RESTART:
      return 3;
    case LaunchData_EntryPoint.PREVIEW_CANCEL:
      return 4;
    case LaunchData_EntryPoint.MAP:
      return 5;
    case LaunchData_EntryPoint.BITMOJI_STICKERS:
      return 6;
    case LaunchData_EntryPoint.POST_CAPTURE_PREVIEW:
      return 7;
    case LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING:
      return 8;
    default:
      return 0;
  }
}
var LaunchData_ApiDescriptor;
(function(LaunchData_ApiDescriptor2) {
  LaunchData_ApiDescriptor2["NONE"] = "NONE";
  LaunchData_ApiDescriptor2["EXPERIMENTAL"] = "EXPERIMENTAL";
  LaunchData_ApiDescriptor2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ApiDescriptor || (LaunchData_ApiDescriptor = {}));
function launchData_ApiDescriptorFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return LaunchData_ApiDescriptor.NONE;
    case 1:
    case "EXPERIMENTAL":
      return LaunchData_ApiDescriptor.EXPERIMENTAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ApiDescriptor.UNRECOGNIZED;
  }
}
function launchData_ApiDescriptorToNumber(object) {
  switch (object) {
    case LaunchData_ApiDescriptor.NONE:
      return 0;
    case LaunchData_ApiDescriptor.EXPERIMENTAL:
      return 1;
    default:
      return 0;
  }
}
var LaunchData_RenderConfig;
(function(LaunchData_RenderConfig2) {
  LaunchData_RenderConfig2["DEFAULT"] = "DEFAULT";
  LaunchData_RenderConfig2["REPLAY_STREAM"] = "REPLAY_STREAM";
  LaunchData_RenderConfig2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_RenderConfig || (LaunchData_RenderConfig = {}));
function launchData_RenderConfigFromJSON(object) {
  switch (object) {
    case 0:
    case "DEFAULT":
      return LaunchData_RenderConfig.DEFAULT;
    case 1:
    case "REPLAY_STREAM":
      return LaunchData_RenderConfig.REPLAY_STREAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_RenderConfig.UNRECOGNIZED;
  }
}
function launchData_RenderConfigToNumber(object) {
  switch (object) {
    case LaunchData_RenderConfig.DEFAULT:
      return 0;
    case LaunchData_RenderConfig.REPLAY_STREAM:
      return 1;
    default:
      return 0;
  }
}
var LaunchData_ActivationSource;
(function(LaunchData_ActivationSource2) {
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_UNSET"] = "ACTIVATION_SOURCE_UNSET";
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_DEFAULT"] = "ACTIVATION_SOURCE_DEFAULT";
  LaunchData_ActivationSource2["CREATIVE"] = "CREATIVE";
  LaunchData_ActivationSource2["SCAN"] = "SCAN";
  LaunchData_ActivationSource2["SCAN_HISTORY"] = "SCAN_HISTORY";
  LaunchData_ActivationSource2["CHAT_FEED_PSA"] = "CHAT_FEED_PSA";
  LaunchData_ActivationSource2["GROWTH_NOTIFICATION"] = "GROWTH_NOTIFICATION";
  LaunchData_ActivationSource2["MASS_SNAP"] = "MASS_SNAP";
  LaunchData_ActivationSource2["SMART_CTA"] = "SMART_CTA";
  LaunchData_ActivationSource2["MASS_CHAT"] = "MASS_CHAT";
  LaunchData_ActivationSource2["BILLBOARD_FHP"] = "BILLBOARD_FHP";
  LaunchData_ActivationSource2["LENS_ACTIVITY_CENTER"] = "LENS_ACTIVITY_CENTER";
  LaunchData_ActivationSource2["AR_BAR"] = "AR_BAR";
  LaunchData_ActivationSource2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ActivationSource || (LaunchData_ActivationSource = {}));
function launchData_ActivationSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTIVATION_SOURCE_UNSET":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    case 1:
    case "ACTIVATION_SOURCE_DEFAULT":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT;
    case 2:
    case "CREATIVE":
      return LaunchData_ActivationSource.CREATIVE;
    case 3:
    case "SCAN":
      return LaunchData_ActivationSource.SCAN;
    case 4:
    case "SCAN_HISTORY":
      return LaunchData_ActivationSource.SCAN_HISTORY;
    case 5:
    case "CHAT_FEED_PSA":
      return LaunchData_ActivationSource.CHAT_FEED_PSA;
    case 6:
    case "GROWTH_NOTIFICATION":
      return LaunchData_ActivationSource.GROWTH_NOTIFICATION;
    case 7:
    case "MASS_SNAP":
      return LaunchData_ActivationSource.MASS_SNAP;
    case 8:
    case "SMART_CTA":
      return LaunchData_ActivationSource.SMART_CTA;
    case 9:
    case "MASS_CHAT":
      return LaunchData_ActivationSource.MASS_CHAT;
    case 10:
    case "BILLBOARD_FHP":
      return LaunchData_ActivationSource.BILLBOARD_FHP;
    case 11:
    case "LENS_ACTIVITY_CENTER":
      return LaunchData_ActivationSource.LENS_ACTIVITY_CENTER;
    case 12:
    case "AR_BAR":
      return LaunchData_ActivationSource.AR_BAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ActivationSource.UNRECOGNIZED;
  }
}
function launchData_ActivationSourceToNumber(object) {
  switch (object) {
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET:
      return 0;
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT:
      return 1;
    case LaunchData_ActivationSource.CREATIVE:
      return 2;
    case LaunchData_ActivationSource.SCAN:
      return 3;
    case LaunchData_ActivationSource.SCAN_HISTORY:
      return 4;
    case LaunchData_ActivationSource.CHAT_FEED_PSA:
      return 5;
    case LaunchData_ActivationSource.GROWTH_NOTIFICATION:
      return 6;
    case LaunchData_ActivationSource.MASS_SNAP:
      return 7;
    case LaunchData_ActivationSource.SMART_CTA:
      return 8;
    case LaunchData_ActivationSource.MASS_CHAT:
      return 9;
    case LaunchData_ActivationSource.BILLBOARD_FHP:
      return 10;
    case LaunchData_ActivationSource.LENS_ACTIVITY_CENTER:
      return 11;
    case LaunchData_ActivationSource.AR_BAR:
      return 12;
    default:
      return 0;
  }
}
function createBaseLaunchData() {
  return {
    snappable: void 0,
    lures: void 0,
    userId: "",
    entryPoint: LaunchData_EntryPoint.LIVE_CAMERA,
    userData: void 0,
    persistentStore: void 0,
    launchParams: void 0,
    apiDescriptors: [],
    renderConfig: LaunchData_RenderConfig.DEFAULT,
    activationSource: LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET
  };
}
var LaunchData = {
  encode(message, writer = import_minimal29.default.Writer.create()) {
    if (message.snappable !== void 0) {
      Snappable.encode(message.snappable, writer.uint32(10).fork()).ldelim();
    }
    if (message.lures !== void 0) {
      Lures.encode(message.lures, writer.uint32(18).fork()).ldelim();
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.entryPoint !== LaunchData_EntryPoint.LIVE_CAMERA) {
      writer.uint32(32).int32(launchData_EntryPointToNumber(message.entryPoint));
    }
    if (message.userData !== void 0) {
      UserData.encode(message.userData, writer.uint32(42).fork()).ldelim();
    }
    if (message.persistentStore !== void 0) {
      PersistentStore.encode(message.persistentStore, writer.uint32(50).fork()).ldelim();
    }
    if (message.launchParams !== void 0) {
      LaunchParams.encode(message.launchParams, writer.uint32(58).fork()).ldelim();
    }
    writer.uint32(66).fork();
    for (const v2 of message.apiDescriptors) {
      writer.int32(launchData_ApiDescriptorToNumber(v2));
    }
    writer.ldelim();
    if (message.renderConfig !== LaunchData_RenderConfig.DEFAULT) {
      writer.uint32(72).int32(launchData_RenderConfigToNumber(message.renderConfig));
    }
    if (message.activationSource !== LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET) {
      writer.uint32(80).int32(launchData_ActivationSourceToNumber(message.activationSource));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal29.default.Reader ? input : new import_minimal29.default.Reader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snappable = Snappable.decode(reader, reader.uint32());
          break;
        case 2:
          message.lures = Lures.decode(reader, reader.uint32());
          break;
        case 3:
          message.userId = reader.string();
          break;
        case 4:
          message.entryPoint = launchData_EntryPointFromJSON(reader.int32());
          break;
        case 5:
          message.userData = UserData.decode(reader, reader.uint32());
          break;
        case 6:
          message.persistentStore = PersistentStore.decode(reader, reader.uint32());
          break;
        case 7:
          message.launchParams = LaunchParams.decode(reader, reader.uint32());
          break;
        case 8:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
            }
          } else {
            message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
          }
          break;
        case 9:
          message.renderConfig = launchData_RenderConfigFromJSON(reader.int32());
          break;
        case 10:
          message.activationSource = launchData_ActivationSourceFromJSON(reader.int32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLaunchData();
    message.snappable = object.snappable !== void 0 && object.snappable !== null ? Snappable.fromPartial(object.snappable) : void 0;
    message.lures = object.lures !== void 0 && object.lures !== null ? Lures.fromPartial(object.lures) : void 0;
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.entryPoint = (_b = object.entryPoint) !== null && _b !== void 0 ? _b : LaunchData_EntryPoint.LIVE_CAMERA;
    message.userData = object.userData !== void 0 && object.userData !== null ? UserData.fromPartial(object.userData) : void 0;
    message.persistentStore = object.persistentStore !== void 0 && object.persistentStore !== null ? PersistentStore.fromPartial(object.persistentStore) : void 0;
    message.launchParams = object.launchParams !== void 0 && object.launchParams !== null ? LaunchParams.fromPartial(object.launchParams) : void 0;
    message.apiDescriptors = ((_c = object.apiDescriptors) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.renderConfig = (_d = object.renderConfig) !== null && _d !== void 0 ? _d : LaunchData_RenderConfig.DEFAULT;
    message.activationSource = (_e = object.activationSource) !== null && _e !== void 0 ? _e : LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    return message;
  }
};
if (import_minimal29.default.util.Long !== import_long29.default) {
  import_minimal29.default.util.Long = import_long29.default;
  import_minimal29.default.configure();
}

// node_modules/@snap/camera-kit/lib/lens/LensLaunchParams.js
var isNotValid = (value) => !(isString(value) || isValidNumber(value));
var isValidNumber = (value) => isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);
function isLaunchParamsValid(launchParams) {
  if (!isRecord(launchParams) || launchParams instanceof Date) {
    throw new Error("Expected an object.");
  }
  for (const [key, value] of Object.entries(launchParams)) {
    if (Array.isArray(value)) {
      if (!value.every(isString) && !value.every(isValidNumber)) {
        throw new Error(`Field ${key} expects a value of type string, number, string array, or number array. Received: ${JSON.stringify(value)}.`);
      }
    } else if (isNotValid(value)) {
      throw new Error(`Field ${key} expects a value of type string, number, string array, or number array. Received: ${JSON.stringify(value)}.`);
    }
  }
  return true;
}
var createLaunchData = ({ launchParams, persistentStore }) => (
  // finish() protobufjs method returns UInt8Array with shared ArrayBuffer
  // to avoid of detached buffer error when passing data to Lens Core
  // data should be copied using slice() method
  LaunchData.encode(LaunchData.fromPartial(Object.assign(Object.assign({}, launchParams && isLaunchParamsValid(launchParams) && {
    launchParams: { data: new TextEncoder().encode(JSON.stringify(launchParams)) }
  }), persistentStore && { persistentStore: { store: new Uint8Array(persistentStore) } }))).finish().slice()
);

// node_modules/@snap/camera-kit/lib/common/localization.js
function makeTemplate(keys) {
  return (template) => (values) => {
    const tag = (readonlyStrings) => {
      const strings = readonlyStrings.slice();
      return [strings.shift()].concat(keys.map((key) => {
        var _a;
        return `${(_a = values[key]) !== null && _a !== void 0 ? _a : ""}${strings.shift()}`;
      })).concat(strings).join("");
    };
    return template(tag);
  };
}
var legalPromptMessage = makeTemplate(["privacyPolicyUrl", "termsOfServiceUrl", "learnMoreUrl"]);
var allStrings = {
  "en-US": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snaps <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snaps <a href="${0}" target="_blank">Terms of Service</a>. Some lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I Agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes, and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the child's guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  ar: {
    legalPromptMessage: legalPromptMessage((tag) => tag`     <a href="${0}" target="_blank"> </a>   <a href="${0}" target="_blank"> </a>  .          . <a href="${0}" target="_blank">    </a>      .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     ()  ()    .              .         (     )            .           (     )        .<br/><br/>      .`,
    legalPromptVariantGAdultOrChild: `     `,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ` `,
    legalPromptVariantGChild: ``
  },
  "bn-BD": {
    legalPromptMessage: legalPromptMessage((tag) => tag`     Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>-             ,      <a href="${0}" target="_blank"> </a>             `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,                             (  ,    )                              (    )          <br/><br/>            `,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `       `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "bn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap\' \"<a href="${0}" target="_blank">\" </a>   Snap\' <a href="${0}" target="_blank"> </a>-             ,       <a href="${0}" target="_blank"> </a>           `),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `           (),   ()       ,                         (  ,    )                    <br/><br/>       ,   `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "da-DK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Nr du anvender Linser, bekrfter du, at du har lst Snaps <a href="${0}" target="_blank">privatlivspolitik</a> og accepterer Snaps <a href="${0}" target="_blank">servicevilkr</a>. Nogle Linser bruger information om dit ansigt, dine hnder og din stemme for at fungere. <a href="${0}" target="_blank">F mere at vide</a>, og tryk nedenfor, hvis du vil acceptere og fortstte.`),
    legalPromptAccept: `Jeg er enig`,
    legalPromptReject: `Afvis`,
    legalPromptTermsOfService: `Servicevilkr`,
    legalPromptVariantGMessage: `Denne funktion bruger oplysninger om ansigt(er), hnder og stemme(r), der registreres af kameraet og mikrofonen, for at kunne fungere. Med denne funktion kan du anvende sjove og nyttige augmented reality-effekter p selfies og billeder. Vores kamera bruger teknologi til at finde bestemte trk (f.eks. hvor dine hnder, jne og nse er) og bruger disse oplysninger til njagtigt at placere trkket i billedet, der opfanges af kameraet. Alle oplysninger, der indsamles, slettes s hurtigst som muligt (typisk kort efter, at appen lukkes) og altid inden for hjst tre r.<br/><br/>Tryk herunder, hvis du accepterer og vil fortstte.`,
    legalPromptVariantGAdultOrChild: `Er du voksen eller barn?`,
    legalPromptVariantGFindYourParent: `Find din forlder eller vrge.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets vrge`,
    legalPromptVariantGCancel: `Annuller`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "de-DE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Wenn du Linsen verwendet, versicherst du, dass du die <a href="${0}" target="_blank">Datenschutzbestimmungen</a> von Snap gelesen hast und den <a href="${0}" target="_blank">Servicebestimmungen</a> von Snap zustimmst. Manche Linsen verarbeiten Informationen zu deinem Gesicht, deinen Hnden und deiner Stimme, um zu funktionieren. <a href="${0}" target="_blank">Hier erfhrst du mehr.</a> Tippe unten, wenn du zustimmen und fortfahren mchtest.`),
    legalPromptAccept: `Zustimmen`,
    legalPromptReject: `Ablehnen`,
    legalPromptTermsOfService: `Servicebestimmungen`,
    legalPromptVariantGMessage: `Diese Funktion verwendet Informationen ber Gesichter, Hnde und Stimmen, die von der Kamera und dem Mikrofon erkannt werden. Mit dieser Funktion kannst du lustige und ntzliche Augmented Reality-Effekte auf Selfies und Bilder anwenden. Unsere Kamera nutzt Technologien, um bestimmte Merkmale zu lokalisieren (z. B. wo sich deine Hnde, Augen und Nase befinden), und verwendet diese Informationen, um dieses Merkmal dann exakt ber das von der Kamera erfasste Bild zu positionieren. Alle gesammelten Informationen werden so schnell wie mglich gelscht (in der Regel kurz nach dem Schlieen der App), sptestens aber innerhalb von dreiJahren.<br/><br/>Tippe unten, um zuzustimmen und fortzufahren.`,
    legalPromptVariantGAdultOrChild: `Bist du erwachsen oder minderjhrig?`,
    legalPromptVariantGFindYourParent: `Bitte hole ein Elternteil oder Erziehungsberechtigten.`,
    legalPromptVariantGIAmGuardian: `Ich bin der Erziehungsberechtigte des Kindes.`,
    legalPromptVariantGCancel: `Abbrechen`,
    legalPromptVariantGAdult: `Erwachsen`,
    legalPromptVariantGChild: `Minderjhrig`
  },
  "el-GR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      <a href="${0}" target="_blank"> </a>  Snap      <a href="${0}" target="_blank"> </a>  Snap.        ,         . <a href="${0}" target="_blank"> </a>        ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        ,             ,   .                 .            (    ,      )                   .          (      )          .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ;`,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "en-GB": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snap\s <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snap\s <a href="${0}" target="_blank">Terms of Service</a>. Some Lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the childs guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  es: {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y aceptas las <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes funcionan usando informacin acerca de tu cara, tus manos y tu voz. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptar y continuar, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza informacin sobre caras, manos y voces detectadas por la cmara y el micrfono para funcionar. Con esta funcin, puedes aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza dicha informacin para posicionar correctamente el rasgo sobre la imagen detectada por la cmara. Toda la informacin recopilada se eliminar tan pronto como sea posible (por lo general, poco despus de que se cierre la app), siempre en un plazo menor a tres aos.<br/><br/>Para aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-AR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar los Lentes, confirms que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y que acepts sus <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes usan informacin sobre tu cara, tus manos y tu voz para funcionar. <a href="${0}" target="_blank">Obten ms informacin</a>, y si quers aceptar y continuar, toc el botn que aparece ms abajo.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Omitir`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza la informacin sobre caras, manos y voces detectadas por la cmara y el micrfono. Con esta funcin, pods aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza esa informacin para posicionar con precisin el rasgo con la imagen detectada por la cmara. Toda la informacin recopilada se eliminar lo antes posible (normalmente poco despus de cerrar la aplicacin) y siempre en un plazo mximo de tresaos.<br/><br/>Si deseas aceptar y continuar, toc a continuacin.`,
    legalPromptVariantGAdultOrChild: `Sos mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busc a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-ES": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar las Lentes, reconoces haber ledo la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos del servicio</a> de Snap. Algunas Lentes funcionan utilizando informacin de tu cara, tus manos o tu voz. Puedes obtener <a href="${0}" target="_blank">ms informacin</a>, y si quieres aceptar y continuar, toca el botn a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Descartar`,
    legalPromptTermsOfService: `Trminos del servicio`,
    legalPromptVariantGMessage: `Para su funcionamiento, esta funcin hace uso de los datos sobre la cara, las manos y las voces detectados por la cmara y el micrfono. Con ella, puedes aplicar efectos de realidad aumentada, tanto tiles como divertidos, en selfies e imgenes. Nuestra cmara utiliza la tecnologa para localizar determinados elementos (como la posicin de las manos, los ojos o la nariz) y utiliza esta informacin para colocar el elemento sobre la imagen de forma fiel, segn lo detectado por la cmara. Cualquier informacin que se recopile se eliminar lo antes posible (normalmente, al cerrar la aplicacin) y nunca se almacenar durante ms de tres aos.<br/><br/>Si quieres aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres una persona adulta o eres menor?`,
    legalPromptVariantGFindYourParent: `Habla con tu padre, madre o tutor/a legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor o tutora legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Menor`
  },
  "es-MX": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos y condiciones de servicio</a> de Snap. Algunos lentes usan informacin sobre tu cara, manos o voz para funcionar. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptarlo, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Trminos y condiciones de servicio`,
    legalPromptVariantGMessage: `Esta caracterstica utiliza informacin sobre la(s) cara(s), manos y voz o voces detectadas por la cmara y el micrfono para funcionar. Con ella, puedes aplicar efectos de realidad aumentada tiles y divertidos a selfies e imgenes. Nuestra cmara usa tecnologa para localizar ciertos rasgos (como dnde estn tus manos, ojos y nariz) y utiliza esa informacin para posicionar con precisin esta caracterstica con la imagen que la cmara percibi. Toda la informacin que se recopile se eliminar lo ms pronto posible (por lo general, poco despus de cerrar la app) y nunca exceder los tres das.<br/><br/>Si quieres aceptar y proseguir, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu madre, padre o quien tenga tu custodia legal.`,
    legalPromptVariantGIAmGuardian: `Tengo la custodia de la persona menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Persona adulta`,
    legalPromptVariantGChild: `Persona menor`
  },
  "fi-FI": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Kyttmll tehosteita ilmaiset lukeneesi Snapin <a href="${0}" target="_blank">tietosuojaselosteen</a> ja hyvksyvsi Snapin <a href="${0}" target="_blank">palveluehdot</a>. Jotkin tehosteet kyttvt toimintaan tietoja kasvoistasi, ksistsi ja nestsi. <a href="${0}" target="_blank">Listietoja saat tlt</a>. Hyvksy ja jatka napauttamalla alla olevaa painiketta.`),
    legalPromptAccept: `Hyvksyn`,
    legalPromptReject: `Hylk`,
    legalPromptTermsOfService: `Palveluehdot`,
    legalPromptVariantGMessage: `Tm ominaisuus kytt toimiakseen tietoja kameran ja mikrofonin havaitsemista kasvoista, ksist ja nist. Ominaisuudella voit list hauskoja ja hydyllisi listyn todellisuuden efektej selfieiden ja kuvien plle. Kameramme kytt teknologiaa tiettyjen piirteiden paikallistamiseen (kuten ksiesi, silmiesi ja nensi sijaintiin) ja kytt nit tietoja ominaisuuden asettamiseen oikeaan kohtaan kameran havaitsemassa kuvassa. Kaikki kertyt tiedot poistetaan mahdollisimman pian (yleens pian sovelluksen sulkemisen jlkeen) ja aina viimeistn kolmen vuoden kuluttua.<br/><br/>Jos haluat hyvksy ja jatkaa, napauta painiketta alla. `,
    legalPromptVariantGAdultOrChild: `Oletko aikuinen vai lapsi?`,
    legalPromptVariantGFindYourParent: `Etsi vanhempasi tai huoltajasi.`,
    legalPromptVariantGIAmGuardian: `Olen lapsen huoltaja`,
    legalPromptVariantGCancel: `Peruuta`,
    legalPromptVariantGAdult: `Aikuinen`,
    legalPromptVariantGChild: `Lapsi`
  },
  "fil-PH": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Sa pamamagitan ng paggamit sa Lenses, kinikilala mong binasa mo ang <a href="${0}" target="_blank">Privacy Policy</a> ng Snap at sumasang-ayon ka sa <a href="${0}" target="_blank">Terms of Service</a> ng Snap. Ang ilang lens ay gumagamit ng impormasyon tungkol sa iyong mukha , mga kamay at boses para gumana. <a href="${0}" target="_blank">Alamin Pa</a>, at kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`),
    legalPromptAccept: `Sang-ayon Ako`,
    legalPromptReject: `I-dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `Ang feature na ito ay gumagamit ng impormasyon tungkol sa (mga) mukha, mga kamay at (mga) boses na nade-detect ng camera at microphone para gumana ito. Gamit ang feature na ito, pwede kang mag-apply ng nakakatuwa at kapaki-pakinabang na augmented reality effects sa ibabaw ng mga selfie at image. Gumagamit ang camera namin ng technology para matukoy ang mga partikular na anyo (tulad ng kung nasaan ang iyong mga kamay, mga mata, at ilong) at ginagamit nito ang impormasyong iyon para eksaktong mapwesto ang anyong iyon sa image na nase-sense ng camera. Ang anumang impormasyong kinokolekta ay ide-delete sa lalong madaling panahon (karaniwan ay maikling panahon lang matapos isara ang app) at palaging hindi lalampas nang tatlong taon.<br/><br/>Kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`,
    legalPromptVariantGAdultOrChild: `Isa ka bang adult o bata?`,
    legalPromptVariantGFindYourParent: `Pakihanap ang iyong magulang o legal guardian.`,
    legalPromptVariantGIAmGuardian: `Ako ang guardian ng bata`,
    legalPromptVariantGCancel: `I-cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Bata`
  },
  "fr-FR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`En utilisant les Lenses, vous reconnaissez avoir lu la <a href="${0}" target="_blank">Politique de confidentialit</a> de Snap et vous acceptez les <a href="${0}" target="_blank">Conditions d\'utilisation du service</a> de Snap. Le fonctionnement de certaines Lenses requiert l\'utilisation d\'informations sur votre visage, vos mains et votre voix. <a href="${0}" target="_blank">En savoir plus</a>. Si vous acceptez ces conditions et souhaitez continuer, appuyez ci-dessous.`),
    legalPromptAccept: `J'accepte`,
    legalPromptReject: `Ignorer`,
    legalPromptTermsOfService: `Conditions d'utilisation du service`,
    legalPromptVariantGMessage: `Pour fonctionner, cette fonctionnalit utilise des informations sur le ou les visages, les mains et la ou les voix dtects par l'appareil photo et le micro. Elle vous permet d'appliquer des effets en ralit augmente amusants et utiles sur vos selfies et vos images. Notre appareil photo utilise une technologie qui localise certaines caractristiques (comme l'emplacement de vos mains, de vos yeux et de votre nez) afin de positionner avec prcision la fonctionnalit sur l'image dtecte par l'appareil photo. Toutes les informations collectes sont supprimes ds que possible (gnralement peu aprs la fermeture de l'application) et toujours dans un dlai maximum de trois ans.<br/><br/>Si vous souhaitez accepter et continuer, appuyez ci-dessous.`,
    legalPromptVariantGAdultOrChild: `tes-vous adulte ou mineur?`,
    legalPromptVariantGFindYourParent: `Veuillez appeler votre parent ou votre tuteurrice.`,
    legalPromptVariantGIAmGuardian: `Je suis le ou la tuteurrice de l'enfant.`,
    legalPromptVariantGCancel: `Annuler`,
    legalPromptVariantGAdult: `Adulte`,
    legalPromptVariantGChild: `Mineur`
  },
  "gu-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      Snap <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a>   .          ,      . <a href="${0}" target="_blank"> </a>,       ,    .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `            (),   ()     .                  .     (   ,      )                       .          (       )        .<br/><br/>        ,    .`,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `   -    .`,
    legalPromptVariantGIAmGuardian: `   .`,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "hi-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,       Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>           ,        <a href="${0}" target="_blank"> </a>,           ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,   ()                                   ( ,  ,     )                                         (     )            <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `  -      `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "id-ID": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, kamu menyatakan bahwa kamu sudah membaca <a href="${0}" target="_blank">Kebijakan Privasi</a> Snap dan menyetujui <a href="${0}" target="_blank">Ketentuan Layanan</a> Snap. Beberapa lensa menggunakan informasi tentang wajah, tangan, dan suaramu agar bisa berfungsi dengan baik. <a href="${0}" target="_blank">Pelajari Selengkapnya</a>, dan silakan ketuk tombol di bawah jika kamu ingin menyetujuinya dan melanjutkan.`),
    legalPromptAccept: `Saya setuju`,
    legalPromptReject: `Tutup`,
    legalPromptTermsOfService: `Ketentuan Layanan`,
    legalPromptVariantGMessage: `Agar bisa berfungsi, fitur ini menggunakan informasi terkait wajah, tangan, dan suara yang dideteksi oleh kamera serta mikrofon. Dengan fitur ini, efek augmented reality yang menyenangkan dan berguna dapat diterapkan ke selfie dan gambar. Kamera kami menggunakan teknologi untuk menemukan lokasi fitur tertentu (misalnya menemukan bagian tangan, mata, dan hidung), lalu menggunakan informasi tersebut untuk menempatkan fitur secara akurat di gambar yang dideteksi oleh kamera. Informasi apa pun yang dikumpulkan akan segera dihapus (biasanya setelah aplikasi ditutup) dan selalu disimpan tidak lebih dari tiga tahun.<br/><br/>Jika ingin menyetujui dan melanjutkan, ketuk tombol di bawah ini.`,
    legalPromptVariantGAdultOrChild: `Apakah kamu orang dewasa atau anak-anak?`,
    legalPromptVariantGFindYourParent: `Panggil orang tua atau wali resmi.`,
    legalPromptVariantGIAmGuardian: `Saya wali si anak`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Orang Dewasa`,
    legalPromptVariantGChild: `Anak-Anak`
  },
  "it-IT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Usando le Lenti, confermi di aver letto l\'<a href="${0}" target="_blank">Informativa sulla Privacy</a> di Snap Inc. e di accettare i <a href="${0}" target="_blank">Termini di Servizio</a> di Snap Inc. Alcune Lenti utilizzano informazioni sul tuo viso, le tue mani e la tua voce per funzionare. <a href="${0}" target="_blank">Scopri di pi</a> e, se sei d\'accordo e vuoi continuare, tocca qui sotto.`),
    legalPromptAccept: `Accetto`,
    legalPromptReject: `Ignora`,
    legalPromptTermsOfService: `Termini di Servizio`,
    legalPromptVariantGMessage: `Questa funzionalit utilizza le informazioni su viso, mani e voce rilevate dalla fotocamera e dal microfono per funzionare. Ti consente di applicare effetti in realt aumentata divertenti e utili ai selfie e alle immagini. La nostra Fotocamera sfrutta una tecnologia specifica per individuare certe parti del corpo (ad esempio mani, occhi e naso) e usa questi dati per posizionarle in modo accurato sull'immagine rilevata. Qualsiasi informazione raccolta viene eliminata appena possibile (di solito poco dopo la chiusura dell'app) e, in ogni caso, entro 3 anni.<br/><br/>Se sei d'accordo e vuoi continuare, tocca qui sotto.`,
    legalPromptVariantGAdultOrChild: `Sei un adulto o un minore?`,
    legalPromptVariantGFindYourParent: `C' bisogno di un genitore o tutore legale.`,
    legalPromptVariantGIAmGuardian: `Sono il tutore del minore`,
    legalPromptVariantGCancel: `Annulla`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Minore`
  },
  "ja-JP": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Snap<a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `Snap3<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "kn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  , Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>  .     ,     . <a href="${0}" target="_blank"> </a>,       ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `       (),   ()   .  ,            .     ( ,     )             .       (    )      . <br/><br/>     ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ko-KR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  Snap <a href="${0}" target="_blank"> </a>  Snap <a href="${0}" target="_blank"> </a>   .    ,     . <a href="${0}" target="_blank"> </a>,     .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     , ,     .              . Snapchat   (: ,    )   ,          .      (   ) ,  3  .<br/><br/>   .`,
    legalPromptVariantGAdultOrChild: `, ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: ` `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ml-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>  .     , ,    . <a href="${0}" target="_blank"></a>,     .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `   ,    (),  ()    .       ,     .       (  , ,   )  ,             .      (   )   () .<br/><br/>    .`,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "mr-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,      Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a>  .      ,      . <a href="${0}" target="_blank">  </a>          .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        (),     .  ,             .     (   ,     )              .        (    )       .<br/><br/>       ,   .`,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ms-MY": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, anda mengakui membaca <a href="${0}" target="_blank">Dasar Privasi</a> Snap dan bersetuju dengan <a href="${0}" target="_blank">Syarat Perkhidmatan</a> Snap. Sesetengan lensa menggunakan maklumat tentang muka anda, tangan dan suara untuk berfungsi. <a href="${0}" target="_blank">Ketahui Lebih Lanjut</a>, dan jika anda mahu bersetuju dan teruskan, ketik di bawah.`),
    legalPromptAccept: `Saya Setuju`,
    legalPromptReject: `Abaikan`,
    legalPromptTermsOfService: `Syarat Perkhidmatan`,
    legalPromptVariantGMessage: `Ciri ini menggunakan maklumat muka, tangan dan suara yang dikesan oleh kamera dan mikrofon untuk berfungsi. Dengan ciri ini, anda boleh menggunakan kesan realiti tambahan yang menyeronokkan dan berguna selain swafoto dan gambar. Kamera kami menggunakan teknologi untuk mengesan ciri tertentu (seperti di mana tangan, mata dan hidung anda) dan menggunakan maklumat tersebut untuk meletakkan ciri dengan tepat dengan imej yang dikesan oleh kamera. Sebarang maklumat yang dikumpul akan dipadamkan dengan segera (kebiasaannya sejurus aplikasi ditutup) dan sentiasa dalam tempoh tidak lebih daripada tiga tahun.<br/><br/>Jika anda bersetuju dan ingin teruskan, ketik dibawah.`,
    legalPromptVariantGAdultOrChild: `Adakah anda seorang dewasa atau kanak-kanak?`,
    legalPromptVariantGFindYourParent: `Sila cari ibu bapa atau penjaga anda yang sah.`,
    legalPromptVariantGIAmGuardian: `Saya penjaga kanak-kanak ini`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Dewasa`,
    legalPromptVariantGChild: `Kanak-kanak`
  },
  "nb-NO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ved  ta i bruk Linser bekrefter du at du har lest <a href="${0}" target="_blank">personvernbetingelsene</a> og at du godtar <a href="${0}" target="_blank">tjenestevilkrene</a> til Snap. Noen Linser bruker informasjon om ansiktet ditt, hendene dine og stemmen din for  fungere. <a href="${0}" target="_blank">Finn ut mer</a>. Hvis du godtar dette og vil g videre, klikker du nedenfor.`),
    legalPromptAccept: `Jeg godtar`,
    legalPromptReject: `Avvis`,
    legalPromptTermsOfService: `Tjenestevilkr`,
    legalPromptVariantGMessage: `Denne funksjonen bruker informasjon om ansikter, hender og stemmer som oppdages av kameraet og mikrofonen, for  fungere. Med denne funksjonen kan du legge til artige og nyttige effekter i utvidet virkelighet p selfier og bilder. Kameraet vrt bruker teknologi for  oppdage visse trekk (som hvor hendene, ynene og nesen er), og bruker denne informasjonen til  plassere funksjonen opp bildet som kameraet har fanget opp. All informasjon som samles inn, blir slettet s snart som mulig (vanligvis rett etter at appen lukkes) og alltid innen maks trer.<br/><br/>Hvis du nsker  godta og fortsette, trykker du nedenfor.`,
    legalPromptVariantGAdultOrChild: `Er du en voksen eller et barn?`,
    legalPromptVariantGFindYourParent: `Finn en forelder eller foresatt.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets foresatt`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "nl-NL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Door Lenzen te gebruiken, geef je aan dat je het <a href="${0}" target="_blank">Privacybeleid</a> van Snap hebt gelezen en dat je akkoord gaat met de <a href="${0}" target="_blank">Servicevoorwaarden</a> van Snap. Sommige Lenzen gebruiken informatie over je gezicht, handen en stem om te functioneren. Lees <a href="${0}" target="_blank">meer informatie</a> en tik hieronder als je akkoord gaat en wilt doorgaan.`),
    legalPromptAccept: `Ik ga akkoord`,
    legalPromptReject: `Annuleren`,
    legalPromptTermsOfService: `Servicevoorwaarden`,
    legalPromptVariantGMessage: `Voor de werking van deze functie wordt informatie over gezicht(en), handen en stem(men) gebruikt die door camera en microfoon worden gedetecteerd. Je kunt met deze functie leuke en nuttige augmented reality-effecten op selfies en afbeeldingen plaatsen. Onze camera gebruikt technologie om de locatie te bepalen van bepaalde kenmerken (bijvoorbeeld waar je handen, ogen en neus zich bevinden) en gebruikt die informatie om het kenmerk nauwkeurig te positioneren in de afbeelding die is gedetecteerd met de camera. De verzamelde informatie wordt zo snel mogelijk verwijderd (gewoonlijk kort nadat de app is gesloten) en altijd binnen een periode van maximaal drie jaar.<br/><br/>Tik hieronder als je hiermee akkoord gaat en wilt doorgaan.`,
    legalPromptVariantGAdultOrChild: `Ben je een volwassene of een kind?`,
    legalPromptVariantGFindYourParent: `Vraag toestemming aan een ouder of wettelijke voogd.`,
    legalPromptVariantGIAmGuardian: `Ik ben de voogd van het kind`,
    legalPromptVariantGCancel: `Annuleren`,
    legalPromptVariantGAdult: `Volwassene`,
    legalPromptVariantGChild: `Kind`
  },
  pa: {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,          Snap  <a href="${0}" target="_blank">  </a>       Snap  <a href="${0}" target="_blank">  </a>          ,           <a href="${0}" target="_blank"> </a>          ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `         (),   ()           ,                      (   ,     )                                          (  '      )      <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "pl-PL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Korzystajc z nakadek, potwierdzasz zapoznanie si z <a href="${0}" target="_blank">Polityk prywatnoci</a> i akceptujesz <a href="${0}" target="_blank">Regulamin usugi</a>. Niektre nakadki wykorzystuj informacje o Twojej twarzy, doniach i gosie, aby dziaa poprawnie. <a href="${0}" target="_blank">Dowiedz si wicej</a>, a jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`),
    legalPromptAccept: `Zgadzam si`,
    legalPromptReject: `Odrzu`,
    legalPromptTermsOfService: `Regulamin`,
    legalPromptVariantGMessage: `Ta funkcja wykorzystuje do dziaania informacje o twarzy (twarzach), rkach i gosie (gosach) wykrytych przez kamer i mikrofon. Dziki niej moesz nakada na selfie i zdjcia zabawne i przydatne efekty rozszerzonej rzeczywistoci. Nasza kamera wykorzystuje technologi do lokalizowania okrelonych cech (takich jak miejsce, w ktrym znajduj si Twoje rce, oczy i nos) i wykorzystuje te informacje do dokadnego umiejscowienia danej cechy na obrazie wykrywanym przez kamer. Wszelkie zebrane informacje zostan usunite moliwie jak najszybciej (zazwyczaj wkrtce po zamkniciu aplikacji) i zawsze nie pniej ni w cigu trzech lat.<br/><br/>Jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`,
    legalPromptVariantGAdultOrChild: `Jeste osob doros czy dzieckiem?`,
    legalPromptVariantGFindYourParent: `Zwr si do swojego rodzica lub opiekuna prawnego.`,
    legalPromptVariantGIAmGuardian: `Jestem opiekunem prawnym dziecka`,
    legalPromptVariantGCancel: `Anuluj`,
    legalPromptVariantGAdult: `Osoba dorosa`,
    legalPromptVariantGChild: `Dziecko`
  },
  "pt-BR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao usar as Lentes, voc reconhece ter lido a <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e concorda com os <a href="${0}" target="_blank">Termos de Servio</a> da Snap. Algumas Lentes usam informaes sobre seu rosto, mos e voz para funcionar. <a href="${0}" target="_blank">Saiba mais</a> e, se quiser concordar e continuar, toque abaixo.`),
    legalPromptAccept: `Eu concordo`,
    legalPromptReject: `Recusar`,
    legalPromptTermsOfService: `Termos de Servio`,
    legalPromptVariantGMessage: `Este recurso usa informaes sobre rosto(s), mos e voz(es) detectados pela cmera e pelo microfone para funcionar. Com este recurso, voc pode aplicar efeitos divertidos e teis de realidade aumentada em selfies e imagens. Nossa cmera usa tecnologia para localizar certos recursos (como onde esto suas mos, olhos e nariz) e usa esta informao para posicionar corretamente o recurso na imagem detectada pela cmera. Qualquer informao coletada ser apagada o mais rpido possvel (geralmente logo depois que o aplicativo  fechado) e sempre antes de trs dias.<br/><br/>Se voc quiser concordar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `Voc  adulto ou criana?`,
    legalPromptVariantGFindYourParent: `Localize seu pai/me ou representante legal.`,
    legalPromptVariantGIAmGuardian: `Sou representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "pt-PT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao utilizares as Lentes, confirmas a leitura da <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e aceitas as <a href="${0}" target="_blank">Condies de Servio</a> da Snap. Algumas Lentes utilizam informaes sobre a tua cara, mos e voz para funcionarem. <a href="${0}" target="_blank">Obtm mais informaes</a> e, se quiseres aceitar e continuar, toca abaixo.`),
    legalPromptAccept: `Aceito`,
    legalPromptReject: `Fechar`,
    legalPromptTermsOfService: `Condies de Servio`,
    legalPromptVariantGMessage: `Esta funcionalidade utiliza informaes relacionadas com caras, mos e vozes detetadas pela cmara e o microfone para poder funcionar. Com esta funcionalidade, pode aplicar efeitos de realidade aumentada de forma divertida e til a selfies e imagens. A nossa cmara recorre a tecnologia para localizar determinadas caratersticas (como a localizao das tuas mos, dos olhos e do nariz) e utiliza essas informaes para posicionar de forma precisa a caraterstica na imagem captada pela cmara. Quaisquer informaes recolhidas sero eliminadas logo que possvel (normalmente pouco depois de a app ser fechada) e nunca aps um mximo de trs anos. <br/><br/>Se quiser aceitar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `s um adulto ou uma criana?`,
    legalPromptVariantGFindYourParent: `Recorre ao teus pais ou ao() teu(tua) representante legal`,
    legalPromptVariantGIAmGuardian: `Sou o(a) representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "ro-RO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dac foloseti lentile, confirmi c ai citit <a href="${0}" target="_blank">Politica de confidenialitate</a> Snap i c eti de acord cu <a href="${0}" target="_blank">Condiiile de utilizare</a> Snap. Unele lentile folosesc informaii despre faa ta, despre minile tale i despre vocea ta pentru a funciona. <a href="${0}" target="_blank">Afl mai multe</a>, iar dac doreti s accepi i s continui, atinge dedesubt.`),
    legalPromptAccept: `Accept`,
    legalPromptReject: `Respinge`,
    legalPromptTermsOfService: `Termeni de utilizare`,
    legalPromptVariantGMessage: `Pentru a rula, funcia utilizeaz informaii despre chipul tu, minile tale i vocea ta detectate de camer i microfon. Cu ajutorul acestei funcii, poi s aplici efecte de realitate augumentat amuzante i utile peste selfie-uri i imagini. Camera noastr folosete tehnologia pentru a gsi anumite caracteristici (de exemplu, unde se afl minile, ochii i nasul tu) i utilizeaz aceste informaii pentru a poziiona corect funcia n imaginea detectat de camer. Toate informaiile colectate sunt terse ct mai curnd posibil (de obicei, la scurt timp dup ce se nchide aplicaia), limita maxim fiind de trei ani.<br/><br/>Dac eti de acord i doreti s continui, atinge mai jos.`,
    legalPromptVariantGAdultOrChild: `Eti adult sau copil?`,
    legalPromptVariantGFindYourParent: `Este necesar prezena printelui sau a tutorelui.`,
    legalPromptVariantGIAmGuardian: `Sunt tutorele copilului`,
    legalPromptVariantGCancel: `Anuleaz`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Copil`
  },
  "ru-RU": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,  ,   <a href="${0}" target="_blank"> </a> Snap   <a href="${0}" target="_blank">  </a>.         ,   . <a href="${0}" target="_blank"></a>.    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `           ,   .               .    ,      (,  ,   ),          ,   .        ( ,    ),   ,    .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "sv-SE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Genom att anvnda linser intygar du att du har lst Snaps <a href="${0}" target="_blank">sekretessvillkor</a> och godknner Snaps <a href="${0}" target="_blank">anvndarvillkor</a>. Vissa linser anvnder information om ditt ansikte, dina hnder och din rst fr att fungera. <a href="${0}" target="_blank">Ls mer</a> och om du vill godknna och fortstta s trycker du nedan.`),
    legalPromptAccept: `Jag godknner`,
    legalPromptReject: `Avvisa`,
    legalPromptTermsOfService: `Anvndarvillkor`,
    legalPromptVariantGMessage: `Fr att fungera anvnder funktionen information om ansikte(n), hnder och rst(er) som upptckts av kameran och mikrofonen. Funktionen gr att du kan tillmpa roliga och anvndbara AR-effekter ver selfies och bilder. Med hjlp av teknik kan vr kamera lokalisera vissa srdrag (som dina hnder, gon och din nsa). Informationen anvnds sedan fr att korrekt positionera funktionen ver bilden som kameran fngat upp. All information som samlats in raderas s snart som mjligt (vanligtvis inom kort efter att appen stngts) och alltid inom tre r.<br/><br/>Tryck nedan om du vill godknna och fortstta.`,
    legalPromptVariantGAdultOrChild: `r du vuxen eller ett barn?`,
    legalPromptVariantGFindYourParent: `Leta upp din frlder eller vrdnadshavare`,
    legalPromptVariantGIAmGuardian: `Jag r barnets vrdnadshavare`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Vuxen`,
    legalPromptVariantGChild: `Barn`
  },
  "ta-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .             .      (,  , ,      )  ,         .       (,  ). ,      .<br/><br/>   ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "te-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,   ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .  ,  ,         .     ( ,     )              .      (   )      .<br/><br/>  ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "th-TH": {
    legalPromptMessage: legalPromptMessage((tag) => tag` <a href="${0}" target="_blank"></a>  Snap  <a href="${0}" target="_blank"></a>  Snap    <a href="${0}" target="_blank"></a>  `),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `     (AR)   (   )     () <br/><br/> `,
    legalPromptVariantGAdultOrChild: `?`,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "tr-TR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Lensleri kullanarak, Snap\'in <a href="${0}" target="_blank">Gizlilik Politikas</a> ieriini okuduunu dorulam ve Snap\'in <a href="${0}" target="_blank">Kullanm artlar</a> ieriini kabul etmi olursun. Baz lenslerin almas iin yzn, ellerin ve sesinle ilgili bilgiler kullanlr. <a href="${0}" target="_blank">Daha Fazlasn ren</a> ve kabul edip devam etmek istiyorsan aaya dokun.`),
    legalPromptAccept: `Kabul Ediyorum`,
    legalPromptReject: `Yoksay`,
    legalPromptTermsOfService: `Kullanm artlar`,
    legalPromptVariantGMessage: `Bu zelliin almas iin kamera ve mikrofon tarafndan alglanan yzler, eller ve sesler hakkndaki bilgiler kullanlr. Bu zellik sayesinde selfie'lerin ve grntlerin zerine elenceli ve kullanl artrlm gereklik efektleri uygulayabilirsin. Kameramz, belirli zellikleri (ellerinin, gzlerinin ve burnunun nerede olduu gibi) bulmak iin teknolojiden yararlanr ve bu bilgileri, kamera tarafndan alglanan grntyle zellii doru ekilde konumlandrmak iin kullanr. Toplanan tm bilgiler mmkn olan en ksa srede (genellikle uygulama kapatldktan ksa sre sonra) ve mutlaka en fazla  yl iinde silinir.<br/><br/>Kabul edip devam etmek istiyorsan aaya dokun.`,
    legalPromptVariantGAdultOrChild: `Yetikin mi yoksa ocuk musun?`,
    legalPromptVariantGFindYourParent: `Ltfen ebeveynini veya yasal vasini bul.`,
    legalPromptVariantGIAmGuardian: `Ben ocuun vasisiyim`,
    legalPromptVariantGCancel: `ptal Et`,
    legalPromptVariantGAdult: `Yetikin`,
    legalPromptVariantGChild: `ocuk`
  },
  "ur-PK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`        Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank">  </a>                      <a href="${0}" target="_blank"> </a>               `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `      ()                                                     (         )                                           (      )            <br/><br/>             `,
    legalPromptVariantGAdultOrChild: `      `,
    legalPromptVariantGFindYourParent: `   /      `,
    legalPromptVariantGIAmGuardian: `  /  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "vi-VN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Bng cch s dng ng Knh, bn xc nhn  c <a href="${0}" target="_blank">Chnh Sch Bo Mt</a> ca Snap v ng  vi <a href="${0}" target="_blank">iu Khon Dch V</a>ca Snap. Mt s ng knh s dng thng tin v khun mt, bn tay v ging ni ca bn  hot ng. Bn c th <a href="${0}" target="_blank">Tm Hiu Thm</a>, cn nu bn mun ng  v tip tc, hy chm vo bn di.`),
    legalPromptAccept: `Ti ng `,
    legalPromptReject: `B Qua`,
    legalPromptTermsOfService: `iu Khon Dch V`,
    legalPromptVariantGMessage: `Tnh nng ny hot ng da trn vic s dng thng tin v khun mt, bn tay v ging ni m camera v micr pht hin c. Bn c th s dng tnh nng ny  p dng cc hiu ng thc t tng cng th v v hu ch ln nh t sng v hnh nh. Camera ca chng ti p dng cng ngh  tm nhng c im nht nh (chng hn nh v tr bn tay, mt v mi ca bn), ri s dng thng tin   xc nh chnh xc v tr ca c im trong hnh nh m camera chp c. Chng ti s xa mi thng tin c thu thp sm nht c th (thng ngay sau khi bn ng ng dng) v lun xa trong khong thi gian khng qu ba nm.<br/><br/>Nu bn mun ng  v tip tc, hy chm vo bn di.`,
    legalPromptVariantGAdultOrChild: `Bn l ngi ln hay tr em?`,
    legalPromptVariantGFindYourParent: `Vui lng tm ph huynh hoc ngi gim h hp php.`,
    legalPromptVariantGIAmGuardian: `Ti l ngi gim h ca tr`,
    legalPromptVariantGCancel: `Hy B`,
    legalPromptVariantGAdult: `Ngi ln`,
    legalPromptVariantGChild: `Tr em`
  },
  "zh-Hans": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "zh-Hant": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: ` () ()<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  }
};
var languageDefaultLocale = {
  bn: "bn-BD",
  da: "da-DK",
  de: "de-DE",
  el: "el-GR",
  en: "en-US",
  es: "es-ES",
  fi: "fi-FI",
  fil: "fil-PH",
  fr: "fr-FR",
  gu: "gu-IN",
  hi: "hi-IN",
  id: "id-ID",
  it: "it-IT",
  ja: "ja-JP",
  kn: "kn-IN",
  ko: "ko-KR",
  ml: "ml-IN",
  mr: "mr-IN",
  ms: "ms-MY",
  nb: "nb-NO",
  nl: "nl-NL",
  pl: "pl-PL",
  pt: "pt-BR",
  ro: "ro-RO",
  ru: "ru-RU",
  sv: "sv-SE",
  ta: "ta-IN",
  te: "te-IN",
  th: "th-TH",
  tr: "tr-TR",
  ur: "ur-PK",
  vi: "vi-VN",
  zh: "zh-Hans"
};
var synonyms = {
  "zh-TW": "zh-Hant",
  "zh-CN": "zh-Hans"
};
var isLocaleString = (value) => value in allStrings;
var defaultLocale = "en-US";
function getSupportedLocale() {
  const locale = getPlatformInfo().locale;
  if (isLocaleString(locale))
    return locale;
  const synonym = synonyms[locale];
  if (synonym && synonym in allStrings)
    return synonym;
  const langCode = locale.split("-")[0];
  if (langCode && langCode in allStrings)
    return langCode;
  if (langCode && langCode in languageDefaultLocale)
    return languageDefaultLocale[langCode];
  return defaultLocale;
}
var supportedLocale = getSupportedLocale();
function localizedString(stringId) {
  return allStrings[supportedLocale][stringId];
}

// node_modules/@snap/camera-kit/lib/common/dialog.js
var stylesCss = `
dialog {
    display: flex;
    flex-direction: column;

    background-color: #fff;
    border: #efefef 1px solid;
    border-radius: 20px;
    box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.3);

    max-width: 80vw;
    max-height: 80vh;
    padding: 44px 0 24px 0;

    font-size: 16px;
    font-family: sans-serif;
    font-style: normal;
    font-weight: 600;
    line-height: 24px;
}

dialog::backdrop {
    background-color: rgba(0, 0, 0, 0.4);
}

.title {
    color: #16191C;
    padding: 0 32px;
    text-align: center;
}

.body {
    color: #656D78;
    font-size: 14px;
    font-weight: 500;
    margin-top: 16px;
    max-width: 350px;
    padding: 0 32px;
    overflow: auto;
}

a {
    color: rgb(78, 171, 248);
}

button {
    cursor: pointer;
}

button.dismiss {
    position: absolute;
    top: 7px;
    right: 7px;
    padding: 0;
    height: 36px;
    width: 36px;
    margin: 0;
    background-color: transparent;
    border: 0;
}

button.dismiss svg {
    fill: black;
}

.buttons {
    margin-top: 8px;
    padding: 0 32px;
}

.buttons button {
    background: #0FADFF;
    border: 0;
    border-radius: 25px;

    width: 100%;
    padding: 1rem;
    margin-top: 8px;

    color: #fff;
    font-weight: inherit;
    font-family: inherit;
    font-size: inherit;
    font-style: inherit;
}

.buttons button.secondary {
    background-color: transparent;
    color: #656D78;
}

// Proper filling of X button in High Contrast themes
@media (forced-colors: active) {
    button.dismiss svg {
        fill: ButtonText;
    }
}
`;
function getDismissButtonHtml(button) {
  return `
        <button class="dismiss" autofocus data-key=${button.key}>
            <svg xmlns="http://www.w3.org/2000/svg" role="img" width="36" height="36" viewBox="0 0 36 36">
                <title>${button.text}</title>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M12.6763 11.2621C12.2858 10.8716 11.6527 10.8716 11.2621 11.2621C10.8716 11.6527 10.8716 12.2858 11.2621 12.6763L16.5858 18L11.2621 23.3237C10.8716 23.7142 10.8716 24.3474 11.2621 24.7379C11.6527 25.1284 12.2858 25.1284 12.6764 24.7379L18 19.4142L23.3237 24.7379C23.7142 25.1284 24.3474 25.1284 24.7379 24.7379C25.1284 24.3474 25.1284 23.7142 24.7379 23.3237L19.4142 18L24.7379 12.6763C25.1284 12.2858 25.1284 11.6527 24.7379 11.2621C24.3474 10.8716 23.7142 10.8716 23.3237 11.2621L18 16.5858L12.6763 11.2621Z" fill-opacity="0.4"/>
            </svg>
        </button>`;
}
function getTitleHtml(title) {
  return title ? `<div class="title" role="heading">${title}</div>` : "";
}
function getBodyHtml(body) {
  return body ? `<div class="body">${body}</div>` : "";
}
function getButtonHtml(button) {
  return `<button data-key="${button.key}"${button.isSecondary ? ` class="secondary"` : ""}>${button.text}</button>`;
}
function getButtonsHtml(buttons) {
  if (buttons.length === 0)
    return "";
  return `
        <div class="buttons">
        ${buttons.map((b2) => getButtonHtml(b2)).join("\n")}
        </div>`;
}
function setAttribute(element, attr, value) {
  if (value)
    element.setAttribute(attr, value);
}
function showDialog(options) {
  return new Promise((res) => {
    var _a, _b, _c;
    const element = document.createElement("div");
    setAttribute(element, "data-testid", options.dataTestId);
    const shadow = element.attachShadow({ mode: "open" });
    const style = document.createElement("style");
    shadow.appendChild(style);
    style.innerHTML = stylesCss;
    const prompt = document.createElement("dialog");
    setAttribute(prompt, "aria-label", (_a = options.titleText) !== null && _a !== void 0 ? _a : options.title);
    setAttribute(prompt, "lang", options.lang);
    setAttribute(prompt, "dir", "auto");
    shadow.appendChild(prompt);
    prompt.innerHTML = `
            ${getDismissButtonHtml({ key: "dismiss", text: (_b = options.dismissButtonText) !== null && _b !== void 0 ? _b : "Dismiss" })}
            ${getTitleHtml(options.title)}
            ${getBodyHtml(options.body)}
            ${getButtonsHtml((_c = options.buttons) !== null && _c !== void 0 ? _c : [])}
        `;
    const buttonsElements = Array.from(prompt.querySelectorAll("button"));
    merge(...buttonsElements.map((b2) => fromEvent(b2, "click").pipe(map(() => b2.dataset.key))), fromEvent(prompt, "cancel").pipe(map(() => "dismiss"))).pipe(take(1)).subscribe({ next: res, complete: () => element.remove() });
    options.container.appendChild(element);
    prompt.showModal();
  });
}

// node_modules/@snap/camera-kit/lib/common/hash.js
var computeHash = (str) => {
  let h1 = 3735928559;
  let h2 = 1103547991;
  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(16);
};

// node_modules/@snap/camera-kit/lib/legal/legalPrompt.js
var snapIcon = `
<svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 32 32" height="48px">
    <g>
        <path
            d="M 30.898 23.477 C 30.77 23.045 30.148 22.743 30.148 22.743 C 30.092 22.71 30.039 22.684 29.994 22.663 C 28.962 22.161 28.048 21.561 27.277 20.876 C 26.659 20.325 26.128 19.719 25.701 19.074 C 25.182 18.288 24.937 17.632 24.831 17.275 C 24.773 17.043 24.782 16.951 24.831 16.832 C 24.873 16.731 24.99 16.632 25.049 16.588 C 25.397 16.341 25.96 15.976 26.303 15.75 C 26.602 15.556 26.859 15.389 27.009 15.283 C 27.494 14.944 27.824 14.596 28.02 14.223 C 28.275 13.74 28.303 13.208 28.107 12.684 C 27.84 11.978 27.184 11.556 26.35 11.556 C 26.163 11.556 25.974 11.577 25.785 11.62 C 25.308 11.723 24.852 11.894 24.474 12.042 C 24.446 12.054 24.416 12.032 24.418 12.002 C 24.457 11.059 24.502 9.79 24.399 8.584 C 24.306 7.493 24.082 6.576 23.717 5.776 C 23.351 4.972 22.874 4.376 22.5 3.947 C 22.143 3.536 21.519 2.936 20.577 2.394 C 19.251 1.631 17.742 1.244 16.09 1.244 C 14.443 1.244 12.934 1.631 11.605 2.394 C 10.607 2.966 9.97 3.614 9.678 3.947 C 9.304 4.376 8.827 4.972 8.46 5.776 C 8.096 6.576 7.872 7.496 7.778 8.584 C 7.673 9.792 7.715 10.96 7.76 11.999 C 7.762 12.03 7.732 12.051 7.704 12.039 C 7.325 11.892 6.87 11.72 6.393 11.617 C 6.204 11.575 6.012 11.554 5.828 11.554 C 4.994 11.554 4.337 11.976 4.071 12.682 C 3.875 13.205 3.903 13.738 4.157 14.221 C 4.354 14.594 4.685 14.941 5.169 15.281 C 5.318 15.387 5.575 15.553 5.874 15.748 C 6.211 15.968 6.758 16.323 7.108 16.569 C 7.152 16.599 7.299 16.712 7.346 16.827 C 7.397 16.951 7.404 17.045 7.341 17.289 C 7.234 17.648 6.989 18.298 6.479 19.069 C 6.052 19.715 5.522 20.32 4.902 20.871 C 4.132 21.556 3.218 22.157 2.186 22.658 C 2.137 22.682 2.078 22.712 2.015 22.748 C 2.015 22.748 1.399 23.064 1.282 23.472 C 1.109 24.075 1.567 24.64 2.036 24.943 C 2.8 25.438 3.732 25.703 4.272 25.849 C 4.421 25.889 4.559 25.926 4.683 25.964 C 4.76 25.989 4.956 26.062 5.038 26.17 C 5.143 26.306 5.155 26.473 5.192 26.66 C 5.253 26.977 5.384 27.373 5.774 27.643 C 6.204 27.941 6.75 27.962 7.444 27.99 C 8.168 28.018 9.07 28.054 10.1 28.394 C 10.579 28.553 11.011 28.818 11.514 29.128 C 12.56 29.773 13.864 30.578 16.09 30.578 C 18.318 30.578 19.629 29.768 20.685 29.119 C 21.183 28.811 21.612 28.546 22.08 28.391 C 23.11 28.049 24.011 28.014 24.735 27.988 C 25.427 27.962 25.974 27.941 26.404 27.641 C 26.822 27.35 26.943 26.918 26.997 26.59 C 27.027 26.428 27.046 26.285 27.14 26.165 C 27.219 26.064 27.399 25.992 27.483 25.964 C 27.609 25.924 27.751 25.886 27.906 25.844 C 28.445 25.698 29.123 25.527 29.945 25.061 C 30.933 24.511 31.001 23.82 30.898 23.477"
            fill="#ffffff"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
    <g>
        <path
            d="M 29.56 24.299 C 28.21 25.045 27.312 24.965 26.613 25.414 C 26.021 25.795 26.37 26.618 25.939 26.915 C 25.411 27.279 23.843 26.889 21.822 27.555 C 20.155 28.107 19.09 29.689 16.089 29.689 C 13.081 29.689 12.047 28.114 10.357 27.555 C 8.335 26.889 6.768 27.279 6.24 26.915 C 5.809 26.618 6.16 25.795 5.566 25.414 C 4.869 24.965 3.969 25.045 2.619 24.299 C 1.758 23.825 2.247 23.53 2.532 23.393 C 7.426 21.027 8.204 17.372 8.24 17.096 C 8.282 16.769 8.328 16.509 7.966 16.175 C 7.615 15.853 6.066 14.895 5.636 14.593 C 4.925 14.098 4.612 13.6 4.841 12.99 C 5 12.569 5.395 12.41 5.812 12.41 C 5.94 12.41 6.071 12.426 6.2 12.452 C 6.981 12.623 7.741 13.013 8.179 13.118 C 8.24 13.132 8.293 13.139 8.34 13.139 C 8.574 13.139 8.656 13.022 8.639 12.754 C 8.59 11.9 8.469 10.234 8.602 8.677 C 8.787 6.536 9.477 5.476 10.298 4.538 C 10.693 4.087 12.543 2.133 16.082 2.133 C 19.633 2.133 21.474 4.087 21.867 4.538 C 22.688 5.478 23.378 6.536 23.563 8.677 C 23.698 10.234 23.581 11.898 23.525 12.754 C 23.506 13.034 23.591 13.139 23.825 13.139 C 23.872 13.139 23.925 13.132 23.986 13.118 C 24.426 13.013 25.184 12.62 25.965 12.452 C 26.091 12.424 26.222 12.41 26.353 12.41 C 26.77 12.41 27.165 12.569 27.324 12.99 C 27.555 13.6 27.242 14.095 26.529 14.593 C 26.098 14.892 24.547 15.85 24.199 16.175 C 23.836 16.509 23.883 16.767 23.925 17.096 C 23.96 17.372 24.739 21.025 29.633 23.393 C 29.932 23.53 30.421 23.825 29.56 24.299 M 31.709 23.12 C 31.489 22.523 31.07 22.203 30.594 21.939 C 30.505 21.887 30.423 21.845 30.355 21.812 C 30.212 21.74 30.067 21.667 29.922 21.592 C 28.435 20.806 27.275 19.812 26.469 18.635 C 26.198 18.238 26.008 17.88 25.877 17.587 C 25.809 17.391 25.811 17.281 25.86 17.178 C 25.898 17.101 25.996 17.019 26.05 16.979 C 26.305 16.811 26.57 16.64 26.748 16.525 C 27.067 16.319 27.317 16.156 27.481 16.043 C 28.093 15.617 28.519 15.164 28.786 14.658 C 29.163 13.945 29.21 13.131 28.919 12.363 C 28.517 11.301 27.509 10.642 26.291 10.642 C 26.038 10.642 25.783 10.67 25.527 10.726 C 25.46 10.74 25.394 10.756 25.328 10.773 C 25.34 10.05 25.324 9.278 25.258 8.524 C 25.029 5.872 24.099 4.48 23.129 3.371 C 22.724 2.908 22.021 2.232 20.964 1.628 C 19.491 0.781 17.821 0.356 16 0.356 C 14.185 0.356 12.518 0.781 11.044 1.623 C 9.983 2.229 9.278 2.905 8.875 3.366 C 7.905 4.475 6.975 5.867 6.746 8.52 C 6.68 9.273 6.663 10.045 6.675 10.768 C 6.61 10.752 6.544 10.735 6.476 10.721 C 6.221 10.665 5.965 10.637 5.713 10.637 C 4.494 10.637 3.487 11.297 3.084 12.359 C 2.794 13.126 2.841 13.94 3.218 14.654 C 3.485 15.159 3.911 15.613 4.522 16.039 C 4.686 16.153 4.937 16.314 5.256 16.52 C 5.427 16.633 5.68 16.794 5.926 16.958 C 5.963 16.984 6.097 17.082 6.141 17.173 C 6.193 17.279 6.195 17.393 6.118 17.604 C 5.987 17.891 5.801 18.242 5.535 18.631 C 4.747 19.782 3.62 20.757 2.18 21.536 C 1.419 21.941 0.54 22.355 0.29 23.118 C 0.039 23.88 0.203 24.582 0.842 25.239 C 1.053 25.466 1.318 25.665 1.653 25.85 C 2.438 26.283 3.105 26.496 3.63 26.641 C 3.721 26.669 3.937 26.736 4.031 26.819 C 4.265 27.022 4.23 27.331 4.543 27.78 C 4.731 28.061 4.949 28.25 5.129 28.374 C 5.783 28.826 6.516 28.854 7.294 28.881 C 7.997 28.908 8.793 28.94 9.702 29.24 C 10.079 29.364 10.47 29.605 10.922 29.883 C 12.011 30.552 13.501 31.467 15.998 31.467 C 18.493 31.467 19.995 30.547 21.091 29.876 C 21.541 29.6 21.93 29.361 22.297 29.242 C 23.206 28.942 24.003 28.912 24.706 28.884 C 25.483 28.854 26.216 28.826 26.87 28.377 C 27.076 28.234 27.331 28.004 27.535 27.651 C 27.76 27.272 27.753 27.003 27.964 26.821 C 28.05 26.746 28.238 26.68 28.338 26.65 C 28.868 26.505 29.545 26.292 30.344 25.852 C 30.697 25.658 30.976 25.443 31.192 25.2 C 31.194 25.197 31.196 25.192 31.199 25.19 C 31.805 24.544 31.955 23.787 31.709 23.12"
            fill="#000000"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
</svg>`;
function showTosDialog(title, titleText, body) {
  return __awaiter(this, void 0, void 0, function* () {
    const result = yield showDialog({
      container: document.body,
      dataTestId: "tos-dialog",
      lang: supportedLocale,
      title,
      titleText,
      body,
      dismissButtonText: localizedString("legalPromptReject"),
      buttons: [
        {
          text: localizedString("legalPromptAccept"),
          key: "accept"
        }
      ]
    });
    return result === "accept";
  });
}
function showAdultOrChildDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "adult-or-child-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGAdultOrChild"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGAdult"),
        key: "adult"
      },
      {
        text: localizedString("legalPromptVariantGChild"),
        key: "child"
      }
    ]
  });
}
function showFindGuardianDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "find-guardian-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGFindYourParent"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGIAmGuardian"),
        key: "guardian"
      },
      {
        text: localizedString("legalPromptVariantGCancel"),
        key: "cancel",
        isSecondary: true
      }
    ]
  });
}
var legalPromptFactory = Injectable("legalPrompt", () => {
  return function legalPrompt(privacyPolicy, termsOfService, learnMore, childrenProtectionActRestricted) {
    const legalMessage = childrenProtectionActRestricted ? localizedString("legalPromptVariantGMessage") : localizedString("legalPromptMessage")({
      privacyPolicyUrl: privacyPolicy.webUrl,
      termsOfServiceUrl: termsOfService.webUrl,
      learnMoreUrl: learnMore.webUrl
    });
    const legalTitleText = localizedString("legalPromptTermsOfService");
    const legalTitle = childrenProtectionActRestricted ? legalTitleText : snapIcon;
    return {
      contentHash: computeHash(legalMessage),
      show() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!childrenProtectionActRestricted) {
            return showTosDialog(legalTitle, legalTitleText, legalMessage);
          }
          while (true) {
            const adultOrChild = yield showAdultOrChildDialog();
            switch (adultOrChild) {
              case "child": {
                const findGuardian = yield showFindGuardianDialog();
                switch (findGuardian) {
                  case "cancel":
                    continue;
                  case "guardian":
                    return showTosDialog(legalTitle, legalTitleText, legalMessage);
                  case "dismiss":
                    return false;
                  default:
                    assertUnreachable(findGuardian);
                }
              }
              case "adult":
                return showTosDialog(legalTitle, legalTitleText, legalMessage);
              case "dismiss":
                return false;
              default:
                assertUnreachable(adultOrChild);
            }
          }
        });
      }
    };
  };
});

// node_modules/@snap/camera-kit/lib/legal/legalState.js
var logger10 = getLogger("LegalState");
var tosContentHashExpiry = 12 * 60 * 60;
var tosContentHashKey = "lastAcceptedTosContentHash";
var createLegalState = () => {
  const states = defineStates(defineState("unknown")(), defineState("accepted")(), defineState("rejected")());
  const actions = defineActions(defineAction("requestLegalPrompt")(), defineAction("accept")(), defineAction("reject")());
  return new StateMachine(actions, states, states.unknown(), (actions2) => {
    return merge(
      actions2.pipe(inStates("unknown"), forActions("accept"), map(() => states.accepted())),
      actions2.pipe(inStates("unknown"), forActions("reject"), map(() => states.rejected())),
      // We don't treat "rejected" as a terminal state -- if we get another request to display the legal prompt,
      // even though we're in the rejected state, we'll transition back to unknown and the prompt will be shown.
      //
      // Conversely, we do treat "accepted" as a terminal state -- we will not transition back to unknown or
      // show the legal prompt if we're already in accepted state, even if we get a request to display the prompt.
      actions2.pipe(inStates("rejected"), forActions("requestLegalPrompt"), map(() => states.unknown()))
    );
  });
};
var defaultLegalDocumentDate = /* @__PURE__ */ new Date("2021-09-30T00:00:00+00:00");
var defaultLegalPrompt = LegalPrompt.fromPartial({
  documents: [
    LegalDocument.fromPartial({
      type: LegalDocument_Type.PRIVACY_POLICY,
      webUrl: "https://values.snap.com/privacy/privacy-policy",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.TERMS_OF_SERVICE,
      webUrl: "https://snap.com/terms",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.LEARN_MORE,
      webUrl: "https://support.snapchat.com/article/camera-information-use",
      version: "1",
      timestamp: defaultLegalDocumentDate
    })
  ],
  // By default, we adopt a fail-open approach, which means that if COF fails,
  // we do not display ToS for the following reasons:
  // 1. It provides better experince for big partners with ToS disabled
  // 2. It has minimal risk
  disabled: true
});
var defaultInitConfig = GetInitializationConfigResponse.fromPartial({});
var hasAnyValue = (c2) => {
  var _a, _b;
  return ((_b = (_a = c2.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
var getDocumentOrDefault = (documents) => (type) => {
  var _a;
  return (_a = documents.find((d2) => d2.type === type)) !== null && _a !== void 0 ? _a : defaultLegalPrompt.documents.find((d2) => d2.type === type);
};
var legalStateFactory = Injectable("legalState", [remoteConfigurationFactory.token, legalPromptFactory.token], (remoteConfig, legalPrompt) => {
  const persistance = new ExpiringPersistence(() => tosContentHashExpiry, new IndexedDBPersistence({ databaseName: "Legal" }));
  const getLastAcceptedTosContentHash = () => from(persistance.retrieve(tosContentHashKey).catch((error) => logger10.warn(error)));
  const setLastAcceptedTosContentHash = (hash) => persistance.store(tosContentHashKey, hash).catch((error) => logger10.warn(error));
  const legalState = createLegalState();
  legalState.events.pipe(inStates("unknown"), forActions("requestLegalPrompt"), switchMap(() => forkJoin({
    cofConfig: remoteConfig.get("CAMERA_KIT_LEGAL_PROMPT").pipe(map((configResults) => {
      const config2 = configResults.find(hasAnyValue);
      if (!config2)
        return defaultLegalPrompt;
      return LegalPrompt.decode(config2.value.anyValue.value);
    }), catchError((error) => {
      logger10.error(error);
      return of(defaultLegalPrompt);
    })),
    initConfig: remoteConfig.getInitializationConfig().pipe(catchError((error) => {
      logger10.error(error);
      return of(defaultInitConfig);
    }))
  })), switchMap(({ cofConfig, initConfig }) => {
    var _a;
    if ((_a = initConfig.legalPrompt) === null || _a === void 0 ? void 0 : _a.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    if (cofConfig.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    const documentOfType = getDocumentOrDefault(cofConfig.documents);
    const prompt = legalPrompt(documentOfType(LegalDocument_Type.PRIVACY_POLICY), documentOfType(LegalDocument_Type.TERMS_OF_SERVICE), documentOfType(LegalDocument_Type.LEARN_MORE), initConfig.childrenProtectionActRestricted);
    return getLastAcceptedTosContentHash().pipe(switchMap((lastAcceptedTosContentHash) => {
      if (prompt.contentHash === lastAcceptedTosContentHash)
        return of(true);
      return prompt.show();
    }), map((didAccept) => {
      if (!didAccept)
        return legalState.actions.reject(prompt.contentHash);
      setLastAcceptedTosContentHash(prompt.contentHash);
      return legalState.actions.accept(prompt.contentHash);
    }));
  }), dispatch(legalState)).subscribe({
    error: logger10.error
  });
  return legalState;
});

// node_modules/@snap/camera-kit/lib/metrics/operational/Metric.js
var nameDelimiter = "_";
var dimensionDelimiter = ".";
var delimiterRegex = new RegExp(`^${nameDelimiter}+|${nameDelimiter}+$`, "g");
var Metric = class {
  constructor(name, dimensions = {}) {
    this.name = name;
    this.dimensions = dimensions;
  }
  child(constructor, name, dimensions = {}) {
    return new constructor(`${this.name}${nameDelimiter}${name}`, dimensions);
  }
};
function joinMetricNames(names) {
  return names.join(nameDelimiter).replace(delimiterRegex, "");
}
function serializeMetricDimensions(dimensions) {
  if (Object.keys(dimensions).length === 0)
    return "";
  return `${dimensionDelimiter}${Array.from(Object.entries(dimensions)).map((d2) => d2.join(dimensionDelimiter)).join(dimensionDelimiter)}`;
}

// node_modules/@snap/camera-kit/lib/metrics/operational/Timer.js
var Timer = class _Timer extends Metric {
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.startTime = getTimeMs();
    this.stopped = false;
    this.marks = /* @__PURE__ */ new Set();
    this.measures = /* @__PURE__ */ new Set();
  }
  /**
   * Return all measures created by this Timer and any child timers.
   */
  getMeasures() {
    return Array.from(this.measures.values()).concat(...Array.from(this.marks.values()).map((mark) => mark.getMeasures()));
  }
  /**
   * Create a child Timer, using this Timer's name as a prefix when naming the new Timer. Any measures made with the
   * child Timer will be included when calling `getMeasures()` on this Timer, or when calling `toOperationalMetric`
   * on this Timer.
   *
   * @example
   * ```ts
   * const parent = new Timer('parent')
   * const child = parent.mark('child') // child metric name is parent_child.
   *
   * child.measure()
   * const measures = parent.getMeasures() // has one element.
   * ```
   *
   * @param name
   * @param dimensions If omitted, the child timer will NOT inherit dimensions from the parent -- if the child timer
   * should re-use the parent's dimensions, this must be done explicitly by passing the parent's dimensions as an
   * argument here.
   * @returns A child Timer.
   */
  mark(name, dimensions = {}) {
    const mark = new _Timer(joinMetricNames([this.name, name]), dimensions);
    if (this.stopped)
      mark.stop();
    this.marks.add(mark);
    return mark;
  }
  /**
   * Measure the time (in milliseconds) since this Timer was created.
   *
   * If a name is provided, the measure's name will be prefixed with the name of this Timer. Otherwise the name of
   * the measure will be the name of this Timer.
   *
   * @example
   * ```ts
   * const timer = new Timer('a')
   * timer.measure('b')
   * const measures = timer.getMeasures()
   * // measure[0].name === 'a_b'
   * ```
   *
   * @param name
   * @returns
   */
  measure(name = "") {
    if (this.stopped)
      return;
    const fullName = joinMetricNames([this.name, name]);
    const measure = {
      name: fullName,
      duration: getTimeMs() - this.startTime,
      dimensions: this.dimensions
    };
    this.measures.add(measure);
  }
  /**
   * Remove all measures from this Timer and any child timers previously created by calls to `mark()`.
   */
  clear() {
    this.measures.clear();
    this.marks.forEach((mark) => mark.clear());
  }
  /**
   * Prevent any future measures from being created by this Timer or any child timers.
   */
  stop() {
    this.stopped = true;
    this.marks.forEach((mark) => mark.stop());
  }
  /**
   * Report this metric using {@link OperationalMetricsReporter}.
   *
   * After reporting, the Timer can longer be used. Its internal state is cleared and cannot be updated. Calling this
   * method a second time will no-op.
   *
   * @param reporter All measurements will be reported using the given reporter.
   */
  stopAndReport(reporter) {
    return __awaiter(this, void 0, void 0, function* () {
      reporter.report(this);
      this.stop();
      this.clear();
    });
  }
  /**
   * Convert all measures from this Timer and from any child timers into an array of {@link OperationalMeric} objects,
   * which can be sent to the backend.
   *
   * @returns
   */
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    return this.getMeasures().map((measure) => ({
      name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,
      timestamp: timestamp2,
      metric: {
        $case: "latencyMillis",
        latencyMillis: measure.duration
      }
    }));
  }
};

// node_modules/@snap/camera-kit/lib/observable-operators/unsubscribed.js
function unsubscribed(callback) {
  return (source) => defer(() => {
    let completedOrErrored = false;
    return source.pipe(tap({
      complete: () => completedOrErrored = true,
      error: () => completedOrErrored = true
    }), finalize(() => {
      if (completedOrErrored)
        return;
      callback();
    }));
  });
}

// node_modules/@snap/camera-kit/lib/session/lensState.js
var logger11 = getLogger("LensState");
var createLensState = () => {
  const actions = defineActions(defineAction("applyLens")(), defineAction("downloadComplete")(), defineAction("turnedOn")(), defineAction("resourcesLoaded")(), defineAction("firstFrameProcessed")(), defineAction("applyLensComplete")(), defineAction("applyLensFailed")(), defineAction("applyLensAborted")(), defineAction("removeLens")(), defineAction("turnedOff")(), defineAction("removeLensComplete")(), defineAction("removeLensFailed")());
  const states = defineStates(defineState("noLensApplied")(), defineState("applyingLens")(), defineState("lensApplied")());
  return new StateMachine(actions, states, states.noLensApplied(), (events) => merge(events.pipe(
    // We allow a new lens to be applied at any time, no matter the state.
    inStates("noLensApplied", "applyingLens", "lensApplied"),
    forActions("applyLens"),
    map(([a2]) => states.applyingLens(a2.data.lens))
  ), events.pipe(inStates("applyingLens"), forActions("applyLensComplete"), map(([a2]) => states.lensApplied(a2.data))), events.pipe(inStates("applyingLens"), forActions("applyLensFailed"), map(() => states.noLensApplied())), events.pipe(inStates("lensApplied"), forActions("removeLensComplete"), map(() => states.noLensApplied()))));
};
var lensStateFactory = Injectable("lensState", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensPersistenceStoreFactory.token,
  legalStateFactory.token,
  operationalMetricReporterFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensPersistence, legalState, operationalMetricsReporter) => {
  const lensState = createLensState();
  let firstLensApply = true;
  lensState.events.pipe(
    forActions("applyLens"),
    // Determine the legal state (e.g. terms have been accepted). Using exhaustMap means while we are
    // ascertaining legal status (which may include prompting the end user to accept terms), we will ignore
    // any new applyLens actions.
    exhaustMap(([a2]) => of(legalState.actions.requestLegalPrompt()).pipe(dispatch(legalState), inStates("accepted", "rejected"), take(1), map(([, { name }]) => {
      if (name === "accepted")
        return a2;
      return lensState.actions.applyLensFailed({
        error: legalError(`Failed to apply lens ${a2.data.lens.id}. Required legal terms were not accepted.`),
        lens: a2.data.lens
      });
    }))),
    // The use of switchMap is important so that if we get a new applyLens action while we're still
    // downloading lens content for a previously-requested lens, we can cancel those requests and ensure
    // that lenses are applied in the order they're requested.
    switchMap((a2) => {
      if (a2.name === "applyLensFailed")
        return of(a2);
      const { lens } = a2.data;
      const dispatch2 = (action) => {
        lensState.dispatch(action, lens);
      };
      const applyTimer = new Timer("lens").mark("apply", { first: `${firstLensApply}` });
      firstLensApply = false;
      return of(a2.data).pipe(
        mergeMap(({ lens: lens2, launchParams }) => (
          // If retrieval throws an error, we still want to proceed with the lens
          // because persisted data is not a necessity.
          from(lensPersistence.retrieve(lens2.id).catch(() => void 0)).pipe(map((persistentStore) => ({ lens: lens2, launchParams, persistentStore })))
        )),
        map(({ lens: lens2, launchParams, persistentStore }) => {
          const launchData = createLaunchData({
            launchParams,
            persistentStore
          });
          const lensDetails = lensRepository.getLensMetadata(lens2.id);
          if (!lensDetails) {
            throw new Error(`Cannot apply lens ${lens2.id}. It has not been loaded by the Lens repository. Use CameraKit.lensRepository.loadLens (or loadLensGroups) to load lens metadata before calling CameraKitSession.applyLens.`);
          }
          const { content } = lensDetails;
          if (!content) {
            throw new Error(`Cannot apply lens ${lens2.id}. Metadata retrieved for this lens does not include the lens content URL.`);
          }
          return { lens: lens2, launchData, content };
        }),
        // Load lens assets and the lens itself in parallel. Both count toward lens download time.
        // TODO: use RxJS fetch utilities so that these requests can be cancelled on unsubscribe.
        mergeMap(({ lens: lens2, launchData, content }) => {
          const networkTimer = applyTimer.mark("network");
          return from(Promise.all([
            lensRepository.getLensContent(lens2).finally(() => networkTimer.measure("lens")),
            content.assetManifest.length > 0 ? lensAssetRepository.cacheAssets(content.assetManifest, lens2).finally(() => networkTimer.measure("assets")) : Promise.resolve()
          ])).pipe(tap(() => {
            networkTimer.measure();
            lensState.dispatch("downloadComplete", lens2);
          }), map(([{ lensBuffer, lensChecksum }]) => {
            const lensDataBuffer = lensBuffer.slice(0);
            return launchData === void 0 ? { lensId: lens2.id, lensDataBuffer, lensChecksum } : { lensId: lens2.id, lensDataBuffer, lensChecksum, launchData };
          }));
        }),
        // If removeLens is dispatched while downloading, cancel download, don't apply the lens.
        takeUntil(lensState.events.pipe(forActions("removeLens"))),
        // Once the lens has downloaded, we can call replaceLenses. We're not concerned about
        // waiting for prior in-progress calls to replaceLenses to complete, because LensCore
        // guarantees that calls to replaceLenses will always be processed sequentially in the order
        // they are received.
        mergeMap((lensInput) => new Observable((subscriber) => {
          const coreTimer = applyTimer.mark("core");
          lensCore.replaceLenses({
            lenses: [
              Object.assign(Object.assign({}, lensInput), {
                onTurnOn: () => dispatch2("turnedOn"),
                onResourcesLoaded: () => dispatch2("resourcesLoaded"),
                // onFirstFrameProcessed marks the end of the lens application for
                // the end-user -- this is when they see the newly applied lens
                // begin to render. As such, this is where we stop our overall
                // latency measurement and report latency metrics.
                onFirstFrameProcessed: () => {
                  coreTimer.measure("first-frame");
                  applyTimer.measure("success");
                  applyTimer.stopAndReport(operationalMetricsReporter);
                  dispatch2("firstFrameProcessed");
                },
                onTurnOff: () => dispatch2("turnedOff")
              })
            ]
          }).then(() => {
            coreTimer.measure("success");
            subscriber.next(lensState.actions.applyLensComplete(lens));
            subscriber.complete();
          }).catch((lensCoreError) => {
            coreTimer.measure("failure");
            applyTimer.measure("failure");
            applyTimer.stopAndReport(operationalMetricsReporter);
            const message = `Failed to apply lens ${lensInput.lensId}.`;
            const error = /validation failed/.test(lensCoreError.message) ? lensContentValidationError(message, lensCoreError) : lensError(message, lensCoreError);
            subscriber.next(lensState.actions.applyLensFailed({ error, lens }));
            subscriber.complete();
          });
        })),
        catchError((error) => {
          applyTimer.measure("failure");
          applyTimer.stopAndReport(operationalMetricsReporter);
          return of(lensState.actions.applyLensFailed({ error, lens }));
        }),
        // If a new applyLens is received, `switchMap` will unsubscribe from this inner observable,
        // which stops the current lens application. When this happens we can record a separate metric
        // to measure aborted lens applications.
        unsubscribed(() => {
          applyTimer.measure("abort");
          applyTimer.stopAndReport(operationalMetricsReporter);
        })
      );
    }),
    dispatch(lensState)
  ).subscribe({
    error: logger11.error
  });
  lensState.events.pipe(inStates("lensApplied", "noLensApplied"), forActions("removeLens"), mergeMap(() => new Observable((subscriber) => {
    lensCore.clearAllLenses().then(() => {
      subscriber.next(lensState.actions.removeLensComplete());
      subscriber.complete();
    }).catch((lensCoreError) => {
      const error = new Error("Failed to remove lenses.", { cause: lensCoreError });
      subscriber.next(lensState.actions.removeLensFailed(error));
      subscriber.complete();
    });
  })), dispatch(lensState)).subscribe({
    error: logger11.error
  });
  lensState.events.pipe(inStates("applyingLens"), forActions("removeLens"), switchMap(([a2]) => lensState.events.pipe(
    // Wait to remove the lens until it has been applied.
    inStates("lensApplied"),
    // But cancel the removal if a new applyLens supercedes the current lens. The goal here is to
    // make sure the latest apply/remove pre-empts any previous request to apply/remove.
    takeUntil(lensState.events.pipe(forActions("applyLens"))),
    map(() => a2)
  )), dispatch(lensState)).subscribe({
    error: logger11.error
  });
  lensState.events.subscribe(([a2, s2]) => logger11.debug(`Action: "${a2.name}", state: "${s2.name}"`));
  return lensState;
});

// node_modules/@snap/camera-kit/lib/session/sessionState.js
var createSessionState = () => {
  const actions = defineActions(defineAction("suspend")(), defineAction("resume")(), defineAction("destroy")());
  const states = defineStates(defineState("inactive")(), defineState("active")(), defineState("destroyed")());
  return new StateMachine(actions, states, defineState("inactive")()(), (events) => {
    return merge(events.pipe(forActions("resume"), map(([a2]) => states.active(a2.data))), events.pipe(forActions("suspend"), map(() => states.inactive())), events.pipe(forActions("destroy"), map(() => states.destroyed())));
  });
};
var sessionStateFactory = Injectable("sessionState", () => createSessionState());

// node_modules/@snap/camera-kit/lib/session/LensKeyboard.js
var LensKeyboard = class {
  constructor(lensState) {
    this.lensState = lensState;
    this.active = false;
    this.element = document.createElement("textarea");
    this.element.addEventListener("keypress", (event) => {
      if (event.code === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.handleReply(this.element.value);
      }
    });
    this.events = new TypedEventTarget();
    this.handleReply = () => {
    };
    this.uriHandler = {
      uri: "app://textInput/requestKeyboard",
      handleRequest: (_request, reply) => {
        this.element.autofocus = true;
        this.handleReply = (text) => {
          const opt = {
            text,
            start: text.length,
            end: text.length,
            done: true,
            shouldNotify: true
          };
          const output = new TextEncoder().encode(JSON.stringify(opt));
          reply({
            code: 200,
            description: "",
            contentType: "application/json",
            data: output
          });
        };
        this.active = true;
        this.updateStatus();
        this.element.focus();
      }
    };
    lensState.events.pipe(forActions("turnedOff")).subscribe(() => {
      this.dismiss();
    });
  }
  dismiss() {
    if (this.active) {
      this.active = false;
      this.element.value = "";
      this.updateStatus();
    }
  }
  getElement() {
    return this.element;
  }
  sendInputToLens(text) {
    this.element.value = text;
    this.handleReply(text);
  }
  addEventListener(type, callback, options) {
    this.events.addEventListener(type, callback, options);
  }
  removeEventListener(type, callback) {
    this.events.removeEventListener(type, callback);
  }
  toPublicInterface() {
    return {
      addEventListener: this.addEventListener.bind(this),
      removeEventListener: this.removeEventListener.bind(this),
      getElement: this.getElement.bind(this),
      sendInputToLens: this.sendInputToLens.bind(this),
      dismiss: this.dismiss.bind(this)
    };
  }
  updateStatus() {
    const state = this.lensState.getState();
    if (isState(state, "noLensApplied"))
      return;
    this.events.dispatchEvent(new TypedCustomEvent("active", {
      element: this.element,
      active: this.active,
      // If the keyboard is up, it has been triggered by an active lens.
      lens: state.data
    }));
  }
};
var lensKeyboardFactory = Injectable("lensKeyboard", [lensStateFactory.token], (lensState) => new LensKeyboard(lensState));

// node_modules/@snap/camera-kit/lib/session/CameraKitSessionEvents.js
var isReachable = (_) => false;
function isSessionError(value) {
  if (!(value instanceof Error))
    return false;
  const maybeSessionErrorName = value.name;
  switch (maybeSessionErrorName) {
    case "LensAbortError":
    case "CameraKitSourceError":
    case "LensExecutionError":
    case "LensImagePickerError":
      return true;
    default:
      return isReachable(maybeSessionErrorName);
  }
}
function isPublicLensError(value) {
  if (!(value instanceof Error))
    return false;
  const maybeSessionErrorName = value.name;
  switch (maybeSessionErrorName) {
    case "LensAbortError":
    case "LensExecutionError":
    case "LensImagePickerError":
      return true;
    default:
      return isReachable(maybeSessionErrorName);
  }
}

// node_modules/@snap/camera-kit/lib/session/CameraKitSession.js
var logger12 = getLogger("CameraKitSession");
var log3 = errorLoggingDecorator(logger12);
function isOptionalRenderTarget(value) {
  return value === "live" || value === "capture" || value === void 0;
}
var CameraKitSession = class {
  /**
   * @internal
   */
  constructor(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility) {
    this.keyboard = keyboard;
    this.lensCore = lensCore;
    this.sessionState = sessionState;
    this.lensState = lensState;
    this.events = new TypedEventTarget();
    const outputs = this.lensCore.getOutputCanvases();
    this.output = {
      live: outputs[this.lensCore.CanvasType.Preview.value],
      capture: outputs[this.lensCore.CanvasType.Capture.value]
    };
    this.playing = false;
    this.metrics = new LensPerformanceMetrics(this.lensCore);
    const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch("suspend", this));
    const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch("resume", this));
    this.removePageVisibilityHandlers = () => {
      removeOnHidden();
      removeOnVisible();
    };
    const sessionErrors = logEntries.pipe(filter((entry) => entry.level === "error"), map((entry) => entry.messages.find((e2) => e2 instanceof Error)), filter(isSessionError));
    this.subscriptions = [
      // In case of an abort error, the only option is to destroy the current session,
      // as it becomes inoperable.
      sessionErrors.pipe(filter((error) => error.name === "LensAbortError")).subscribe(() => this.destroy()),
      // In case of LensCore lens execution error, we must remove the lens from rendering
      // NOTE: LensCore doesn't differentiate recoverable vs non-recoverable errors and
      // it is recommened to always remove the lens.
      sessionErrors.pipe(filter((error) => error.name === "LensExecutionError")).subscribe(() => this.removeLens()),
      // Report public session errors to apps
      sessionErrors.pipe(filter(isPublicLensError)).subscribe((error) => {
        const state = lensState.getState();
        if (!isState(state, "noLensApplied")) {
          this.events.dispatchEvent(new TypedCustomEvent("error", { error, lens: state.data }));
        } else {
          logger12.warn(new Error("Lens error occurred even though there is no active lens.", {
            cause: error
          }));
        }
      })
    ];
  }
  /**
   * Apply a Lens to this session.
   *
   * This method will download (and cache) the Lens executable, and then use that Lens for rendering. If the session
   * is currently playing, this will immediately update the rendered output. Otherwise, the new Lens will be used
   * when session playback in resumed.
   *
   * Calling `applyLens` replaces any prior Lens  only one Lens is allowed at a time (per session).
   *
   * **NOTE**: Errors may occur after the Lens is applied. If the Lens encounters errors while rendering,
   * Camera Kit will automatically remove the Lens from the session and emit a {@link LensExecutionError} event.
   * Applications may want to listen for this error and, for example,
   * prevent the Lens from being selected again by the user.
   *
   * ```ts
   * session.events.addEventListener("error", ({ detail }) => {
   *   if (detail.error.name === "LensExecutionError") {
   *     preventFutureLensSelection(detail.lens);
   *     showMessage("We're sorry, but the Lens you selected encountered an error. Please choose a different Lens.");
   *   }
   * });
   * ```
   *
   * @param lens The Lens to apply to this session.
   * @param launchParams: This can optionally be provided to pass some initial data to the lens  only certain lenses
   * expect launch data.
   * @returns A promise which can have the following results:
   * 1. Resolved with `true`: the lens has been applied.
   * 2. Resolved with `false`: the lens has not been applied, but no error occurred  this can happen if a
   * subsequent call to `applyLens` interrupted the lens application.
   * 3. Rejected: the lens has not been applied because an error occurred. This can happen if:
   *   - The lens ID cannot be found in the LensRepository (use LensRepository to load the lens before calling this
   *     method)
   *   - Lens content download fails, or the download of any required lens assets fails.
   *   - An internal failure occurs in the Lens rendering engine when attempting to apply the lens.
   */
  applyLens(lens, launchParams) {
    return __awaiter(this, void 0, void 0, function* () {
      const action = this.lensState.actions.applyLens({ lens, launchParams });
      return firstValueFrom(
        of(action).pipe(
          dispatch(this.lensState),
          // If another applyLens occurs while we're waiting, resolve this applyLens promise early  we're no
          // longer waiting for the requested lens to be applied.
          takeUntil(this.lensState.events.pipe(forActions("applyLens"), filter(([a2]) => a2 !== action))),
          // If lens application failed, convert this into a rejected promise by throwing the error.
          tap(([a2]) => {
            if (isAction(a2, "applyLensFailed") && a2.data.lens.id === lens.id)
              throw a2.data.error;
          }),
          inStates("lensApplied"),
          map(() => true)
        ),
        // The default value is used if `takeUntil` completes the Observable early  i.e. the lens was not
        // applied (application was interrupted by a new call to `applyLens`), so we'll resolve with `false`.
        { defaultValue: false }
      );
    });
  }
  /**
   * Remove a Lens from this session.
   *
   * When a Lens is removed, rendering continues if the session is playing. It will just render the session input
   * directly to the outputs without any image processing.
   *
   * @returns A promise which can have the following results:
   * 1. Resolved with `true`: the session's rendered output has no lens applied.
   * 2. Resolved with `false`: the current lens has been removed, but a subsequent call to `applyLens` means that the
   * session's rendered output will still have a (new) lens applied.
   * 3. Rejected: the lens has failed to be removed. This can happen if an internal failure occurs in the Lens
   * rendering engine when attempting to remove the lens.
   */
  removeLens() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isState(this.lensState.getState(), "noLensApplied"))
        return true;
      return firstValueFrom(
        of(this.lensState.actions.removeLens()).pipe(
          dispatch(this.lensState),
          // If lens removal failed, convert this into a rejected promise by throwing the error.
          tap(([a2]) => {
            if (isAction(a2, "removeLensFailed"))
              throw a2.data;
          }),
          inStates("noLensApplied"),
          // If applyLens is called while we're waiting for removal, complete immediately  applying the next lens
          // will replace the current one.
          takeUntil(this.lensState.events.pipe(forActions("applyLens"))),
          map(() => true)
        ),
        // The default value is used if `takeUntil` completes the Observable early (otherwise firstValueFrom will
        // return a rejected Promise).
        { defaultValue: false }
      );
    });
  }
  /**
   * Start/resume session playback  LensCore will begin rendering frames to the output.
   *
   * If no source has been set for the session, calling `play()` will update the playing state, but no actual image
   * processing will occur until `setSource()` is called.
   *
   * @example
   * ```ts
   * const cameraKitSession = await cameraKit.createSession()
   * await cameraKitSession.setSource(mySource)
   * await cameraKitSession.play()
   *
   * // If you call `play` before `setSource`, the call to `play` will resolve but playback will only begin once a
   * // media source has been set.
   * ```
   *
   * @param target Specify the {@link RenderTarget} to render. Defaults to the `live` RenderTarget.
   * @returns Promise resolves when playback state has been updated. If no source has been set, this means `play` will
   * resolve before any frames are processed -- but once a source is set, frames will immediately begin processing.
   */
  play(target = "live") {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.playing)
        return;
      this.playing = target;
      const type = this.renderTargetToCanvasType(target);
      return this.lensCore.playCanvas({ type }).catch((error) => {
        this.playing = false;
        throw error;
      });
    });
  }
  /**
   * Pause session playback  LensCore will stop rendering frames to the output.
   *
   * @param target Specify the RenderTarget to pause playback. May be either `'live'` or `'capture'`.
   * Default is `'live'`.
   * @returns Promise resolves when playback has stopped.
   */
  pause(target = "live") {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.playing)
        return;
      const priorPlayingState = this.playing;
      this.playing = false;
      const type = this.renderTargetToCanvasType(target);
      return this.lensCore.pauseCanvas({ type }).catch((error) => {
        this.playing = priorPlayingState;
        throw error;
      });
    });
  }
  /**
   * Mute all sounds (default SDK state is unmuted).
   *
   * @param fade Do we want audio to fade out?
   */
  mute(fade = false) {
    this.lensCore.setAllSoundsMuted({
      muted: true,
      fade
    });
  }
  /**
   * Unmute all sounds.
   *
   * @param fade Do we want audio to fade in?
   */
  unmute(fade = false) {
    this.lensCore.setAllSoundsMuted({
      muted: false,
      fade
    });
  }
  setSource(source, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.safelyDetachSource();
      const cameraKitSource = source instanceof MediaStream ? createMediaStreamSource(source, options) : source instanceof HTMLVideoElement ? createVideoSource(source, options) : source;
      const priorPlayingState = this.playing;
      this.playing = false;
      yield cameraKitSource.attach(this.lensCore, (error) => {
        logger12.error(cameraKitSourceError("Error occurred during source attachment.", error));
      });
      this.source = cameraKitSource;
      if (priorPlayingState) {
        yield this.play(priorPlayingState);
      }
      return cameraKitSource;
    });
  }
  /**
   * Set an FPS limit.
   *
   * This may be useful to reduce CPU/GPU resource usage by CameraKit if, for example, the input
   * media source has a low FPS  CameraKit would then not try to render more frequently than the source produces
   * new frames.
   *
   * This may also be useful to gracefully degrade performance in situations where lowering FPS is preferable over
   * alternatives.
   *
   * @param fpsLimit A maximum FPS, rendering will not exceed this limit
   * @returns Promise is resolved when the limit is successfully set.
   */
  setFPSLimit(fpsLimit) {
    return __awaiter(this, void 0, void 0, function* () {
      const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;
      return this.lensCore.setFPSLimit({ fps });
    });
  }
  /**
   * Destroy the session.
   *
   * The session will become inoperable. Frame processing stops, and any session-scoped graphical resources are freed.
   */
  destroy() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.lensCore.clearAllLenses();
        yield this.lensCore.teardown();
      } catch (error) {
        logger12.warn("An error occurred in LensCore during the session termination process.", error);
      }
      this.subscriptions.forEach((sub) => sub.unsubscribe());
      yield this.safelyDetachSource();
      this.removePageVisibilityHandlers();
      this.sessionState.dispatch("destroy", void 0);
    });
  }
  renderTargetToCanvasType(target) {
    return target === "capture" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;
  }
  safelyDetachSource() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.source) {
        try {
          yield this.source.detach((error) => {
            logger12.error(cameraKitSourceError("Error occurred during source detachment.", error));
          });
        } catch (error) {
          logger12.error(cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error));
        }
      }
    });
  }
};
__decorate([
  validate,
  log3,
  __param(0, guard(isLens)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Object]),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "applyLens", null);
__decorate([
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "removeLens", null);
__decorate([
  validate,
  log3,
  __param(0, guard(isOptionalRenderTarget)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "play", null);
__decorate([
  validate,
  log3,
  __param(0, guard(isOptionalRenderTarget)),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "pause", null);
__decorate([
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", void 0)
], CameraKitSession.prototype, "mute", null);
__decorate([
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Boolean]),
  __metadata("design:returntype", void 0)
], CameraKitSession.prototype, "unmute", null);
__decorate([
  validate,
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Object]),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "setSource", null);
__decorate([
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Number]),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "setFPSLimit", null);
__decorate([
  log3,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", Promise)
], CameraKitSession.prototype, "destroy", null);
var cameraKitSessionFactory = Injectable("CameraKitSession", [
  lensCoreFactory.token,
  logEntriesFactory.token,
  lensKeyboardFactory.token,
  sessionStateFactory.token,
  lensStateFactory.token,
  pageVisibilityFactory.token
], (lensCore, logEntries, keyboard, sessionState, lensState, pageVisibility) => new CameraKitSession(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility));

// node_modules/@snap/camera-kit/lib/lens/assets/LensAssetsProvider.js
var logger13 = getLogger("LensAssetProvider");
var maxConsecutiveErrors = 3;
var registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensStateFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensState) => {
  const consecutiveErrorsPerAsset = /* @__PURE__ */ new Map();
  lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    const { assetId, assetType, effectId } = assetDescriptor;
    try {
      if (((_a = consecutiveErrorsPerAsset.get(assetId)) !== null && _a !== void 0 ? _a : 0) > maxConsecutiveErrors) {
        throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
      const lensId = effectId !== null && effectId !== void 0 ? effectId : (_b = lensState.getState().data) === null || _b === void 0 ? void 0 : _b.id;
      const lens = lensId ? lensRepository.getLensMetadata(lensId) : void 0;
      yield lensAssetRepository.loadAsset(assetDescriptor, lens && toPublicLens(lens), (_c = lens === null || lens === void 0 ? void 0 : lens.content) === null || _c === void 0 ? void 0 : _c.assetManifest);
      consecutiveErrorsPerAsset.set(assetId, 0);
    } catch (error) {
      lensCore.provideRemoteAssetsResponse({
        assetId,
        assetType
      });
      const consecutiveErrors = ((_d = consecutiveErrorsPerAsset.get(assetId)) !== null && _d !== void 0 ? _d : 0) + 1;
      consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);
      if (consecutiveErrors <= maxConsecutiveErrors) {
        logger13.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));
      } else {
        logger13.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
    }
  }));
});

// node_modules/@snap/camera-kit/lib/generated-proto/pb_schema/lenses/remote_api/remote_api_service.js
var import_long30 = __toESM(require_long());
var import_minimal30 = __toESM(require_minimal2());
var HttpRequestMethod;
(function(HttpRequestMethod2) {
  HttpRequestMethod2["HTTP_METHOD_UNSET"] = "HTTP_METHOD_UNSET";
  HttpRequestMethod2["HTTP_METHOD_GET"] = "HTTP_METHOD_GET";
  HttpRequestMethod2["HTTP_METHOD_POST"] = "HTTP_METHOD_POST";
  HttpRequestMethod2["HTTP_METHOD_PUT"] = "HTTP_METHOD_PUT";
  HttpRequestMethod2["HTTP_METHOD_DELETE"] = "HTTP_METHOD_DELETE";
  HttpRequestMethod2["HTTP_METHOD_PATCH"] = "HTTP_METHOD_PATCH";
  HttpRequestMethod2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(HttpRequestMethod || (HttpRequestMethod = {}));
var ResponseCode;
(function(ResponseCode2) {
  ResponseCode2["RESPONSE_CODE_UNSET"] = "RESPONSE_CODE_UNSET";
  ResponseCode2["SUCCESS"] = "SUCCESS";
  ResponseCode2["REDIRECTED"] = "REDIRECTED";
  ResponseCode2["BAD_REQUEST"] = "BAD_REQUEST";
  ResponseCode2["ACCESS_DENIED"] = "ACCESS_DENIED";
  ResponseCode2["NOT_FOUND"] = "NOT_FOUND";
  ResponseCode2["TIMEOUT"] = "TIMEOUT";
  ResponseCode2["REQUEST_TOO_LARGE"] = "REQUEST_TOO_LARGE";
  ResponseCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ResponseCode2["CANCELLED"] = "CANCELLED";
  ResponseCode2["PROXY_ERROR"] = "PROXY_ERROR";
  ResponseCode2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ResponseCode || (ResponseCode = {}));
function responseCodeToNumber(object) {
  switch (object) {
    case ResponseCode.RESPONSE_CODE_UNSET:
      return 0;
    case ResponseCode.SUCCESS:
      return 1;
    case ResponseCode.REDIRECTED:
      return 2;
    case ResponseCode.BAD_REQUEST:
      return 3;
    case ResponseCode.ACCESS_DENIED:
      return 4;
    case ResponseCode.NOT_FOUND:
      return 5;
    case ResponseCode.TIMEOUT:
      return 6;
    case ResponseCode.REQUEST_TOO_LARGE:
      return 7;
    case ResponseCode.SERVER_ERROR:
      return 8;
    case ResponseCode.CANCELLED:
      return 9;
    case ResponseCode.PROXY_ERROR:
      return 10;
    default:
      return 0;
  }
}
var GetOAuth2InfoResponse_GrantType;
(function(GetOAuth2InfoResponse_GrantType2) {
  GetOAuth2InfoResponse_GrantType2["GRANT_TYPE_UNSET"] = "GRANT_TYPE_UNSET";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE"] = "AUTHORIZATION_CODE";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE_WITH_PKCE"] = "AUTHORIZATION_CODE_WITH_PKCE";
  GetOAuth2InfoResponse_GrantType2["IMPLICIT"] = "IMPLICIT";
  GetOAuth2InfoResponse_GrantType2["CLIENT_CREDENTIALS"] = "CLIENT_CREDENTIALS";
  GetOAuth2InfoResponse_GrantType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(GetOAuth2InfoResponse_GrantType || (GetOAuth2InfoResponse_GrantType = {}));
var TokenExchangeError_TokenExchangeErrorType;
(function(TokenExchangeError_TokenExchangeErrorType2) {
  TokenExchangeError_TokenExchangeErrorType2["ERROR_TYPE_UNSET"] = "ERROR_TYPE_UNSET";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_REQUEST"] = "INVALID_REQUEST";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_CLIENT"] = "INVALID_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_GRANT"] = "INVALID_GRANT";
  TokenExchangeError_TokenExchangeErrorType2["UNAUTHORIZED_CLIENT"] = "UNAUTHORIZED_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["UNSUPPORTED_GRANT_TYPE"] = "UNSUPPORTED_GRANT_TYPE";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_SCOPE"] = "INVALID_SCOPE";
  TokenExchangeError_TokenExchangeErrorType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(TokenExchangeError_TokenExchangeErrorType || (TokenExchangeError_TokenExchangeErrorType = {}));
var globalThis14 = (() => {
  if (typeof globalThis14 !== "undefined")
    return globalThis14;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
if (import_minimal30.default.util.Long !== import_long30.default) {
  import_minimal30.default.util.Long = import_long30.default;
  import_minimal30.default.configure();
}

// node_modules/@snap/camera-kit/lib/extensions/UriHandlers.js
var SEPARATOR = "://";
function extractSchemeAndRoute(uri) {
  const separatorIndex = uri.indexOf(SEPARATOR);
  const scheme = uri.slice(0, separatorIndex);
  const route = uri.slice(separatorIndex + SEPARATOR.length);
  return { scheme, route };
}
function isUri(value) {
  return isString(value) && value.includes(SEPARATOR);
}
function isUriHandler(value) {
  return isRecord(value) && (isUri(value.uri) || isArrayOfType(isUri, value.uri)) && isFunction2(value.handleRequest) && (isUndefined(value.cancelRequest) || isFunction2(value.cancelRequest));
}
function isUriHandlers(value) {
  return isArrayOfType(isUriHandler, value);
}
function isUriResponse(value) {
  return isRecord(value) && isNumber(value.code) && isString(value.description) && isString(value.contentType) && (isArrayBuffer(value.data) || isTypedArray(value.data)) && (isUndefined(value.metadata) || predicateRecordValues(isString)(value.metadata));
}
var uriHandlersFactory = Injectable("UriHandlers", () => {
  const uriHandlers = [];
  return uriHandlers;
});

// node_modules/@snap/camera-kit/lib/extensions/RemoteApiServices.js
var logger14 = getLogger("RemoteApiServices");
var uriResponseOkCode = 200;
var apiResponseStatusHeader = ":sc_lens_api_status";
var apiBinaryContentType = "application/octet-stream";
var statusToResponseCodeMap = {
  success: ResponseCode.SUCCESS,
  redirected: ResponseCode.REDIRECTED,
  badRequest: ResponseCode.BAD_REQUEST,
  accessDenied: ResponseCode.ACCESS_DENIED,
  notFound: ResponseCode.NOT_FOUND,
  timeout: ResponseCode.TIMEOUT,
  requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,
  serverError: ResponseCode.SERVER_ERROR,
  cancelled: ResponseCode.CANCELLED,
  proxyError: ResponseCode.PROXY_ERROR
};
function callCancellationHandler(cancellationHandlers, ...keys) {
  var _a;
  for (const key of keys) {
    (_a = cancellationHandlers.get(key)) === null || _a === void 0 ? void 0 : _a();
    cancellationHandlers.delete(key);
  }
}
function handleLensApplicationEnd(lensRequestState, ...lensIds) {
  for (const lensId of lensIds) {
    const state = lensRequestState.get(lensId);
    if (state) {
      callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());
      lensRequestState.delete(lensId);
    }
  }
}
var remoteApiServicesFactory = Injectable("remoteApiServices", () => {
  const remoteApiServices = [];
  return remoteApiServices;
});
function getRemoteApiUriHandler(registeredServices, sessionState, lensState, lensRepository, reporter) {
  const registeredServiceMap = /* @__PURE__ */ new Map();
  for (const service of registeredServices) {
    const existingServices = registeredServiceMap.get(service.apiSpecId) || [];
    registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);
  }
  const uriRequests = new Subject();
  const uriCancelRequests = new Subject();
  const lensRequestState = /* @__PURE__ */ new Map();
  const lensTurnOffEvents = lensState.events.pipe(forActions("turnedOff"), tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id)));
  const uriRequestEvents = uriRequests.pipe(
    map((uriRequest) => {
      var _a, _b;
      const lensId = uriRequest.lens.id;
      if (!lensRequestState.has(lensId)) {
        lensRequestState.set(lensId, {
          // Prepares a collection to store cancellation handlers.
          // A specific handler will be invoked when a cancellation request is issued by the lens.
          // All handlers will be invoked when the lens is replaced with another one or the session
          // is destroyed.
          cancellationHandlers: /* @__PURE__ */ new Map(),
          // Parse lens metadata to obtain supported Remote API specs.
          supportedSpecIds: new Set(((_b = (_a = lensRepository.getLensMetadata(lensId)) === null || _a === void 0 ? void 0 : _a.featureMetadata) !== null && _b !== void 0 ? _b : []).filter((feature) => feature.typeUrl === knownAnyTypes.remoteApiInfo).flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds))
        });
      }
      const requestState = lensRequestState.get(lensId);
      const { route } = extractSchemeAndRoute(uriRequest.request.uri);
      const [specId, endpointIdWithQuery] = route.split("/").slice(2);
      const [endpointId] = endpointIdWithQuery.split("?");
      return { uriRequest, specId, endpointId, requestState };
    }),
    // only handle requests for API spec ID that current lens supports
    filter(({ specId, requestState }) => requestState.supportedSpecIds.has(specId)),
    // only handle requests if we have a registered service for it
    filter(({ specId }) => registeredServiceMap.has(specId)),
    map(({ uriRequest, specId, endpointId, requestState }) => {
      var _a;
      const dimensions = /* @__PURE__ */ new Map([["specId", specId]]);
      reporter.count("lens_remote-api_requests", 1, dimensions);
      const remoteApiRequest = {
        apiSpecId: specId,
        body: uriRequest.request.data,
        endpointId,
        parameters: uriRequest.request.metadata
      };
      for (const service of (_a = registeredServiceMap.get(specId)) !== null && _a !== void 0 ? _a : []) {
        let requestHandler = void 0;
        try {
          requestHandler = service.getRequestHandler(remoteApiRequest, uriRequest.lens);
        } catch (_b) {
          logger14.warn("Client's Remote API request handler factory threw an error.");
        }
        if (requestHandler) {
          reporter.count("lens_remote-api_handled-requests", 1, dimensions);
          let cancellationHandler = void 0;
          try {
            cancellationHandler = requestHandler((response) => {
              var _a2;
              reporter.count("lens_remote-api_responses", 1, dimensions);
              const responseCode = (_a2 = statusToResponseCodeMap[response.status]) !== null && _a2 !== void 0 ? _a2 : ResponseCode.UNRECOGNIZED;
              const uriResponse = {
                code: uriResponseOkCode,
                description: "",
                contentType: apiBinaryContentType,
                data: response.body,
                metadata: Object.assign(Object.assign({}, response.metadata), { [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString() })
              };
              uriRequest.reply(uriResponse);
            });
          } catch (error) {
            logger14.warn("Client's Remote API request handler threw an error.");
          }
          if (typeof cancellationHandler === "function") {
            requestState.cancellationHandlers.set(uriRequest.request.identifier, () => {
              try {
                cancellationHandler();
              } catch (_a2) {
                logger14.warn("Client's Remote API request cancellation handler threw an error.");
              }
            });
          }
          break;
        }
      }
    })
  );
  const uriCancelRequestEvents = uriCancelRequests.pipe(tap((uriRequest) => {
    var _a;
    const cancellationHandlers = (_a = lensRequestState.get(uriRequest.lens.id)) === null || _a === void 0 ? void 0 : _a.cancellationHandlers;
    if (cancellationHandlers) {
      callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);
    }
  }));
  merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents).pipe(
    catchError((error, sourcePipe) => {
      logger14.error(error);
      reporter.count("lens_remote-api_errors", 1);
      return sourcePipe;
    }),
    // When the pipe completes due to an error,
    // we want to resubscribe to the original pipe to keep it alive.
    retry(),
    takeUntil(sessionState.events.pipe(forActions("destroy")))
  ).subscribe({
    complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys())
  });
  return {
    uri: "app://remote-api/performApiRequest",
    handleRequest(request, reply, lens) {
      uriRequests.next({ request, reply, lens });
    },
    cancelRequest(request, lens) {
      uriCancelRequests.next({ request, lens });
    }
  };
}

// node_modules/@snap/camera-kit/lib/extensions/uriHandlersRegister.js
var logger15 = getLogger("uriHandlersRegister");
var registerUriHandlers = Injectable("registerUriHandlers", [
  lensCoreFactory.token,
  lensStateFactory.token,
  uriHandlersFactory.token,
  lensKeyboardFactory.token,
  remoteApiServicesFactory.token,
  lensRepositoryFactory.token,
  sessionStateFactory.token,
  operationalMetricReporterFactory.token
], (lensCore, lensState, userHandlers, lensKeyboard, remoteApiServices, lensRepository, sessionState, operationalMetricsReporter) => {
  if (!isUriHandlers(userHandlers)) {
    throw new Error("Expected an array of UriHandler objects");
  }
  const allHandlers = userHandlers.concat(lensKeyboard.uriHandler, getRemoteApiUriHandler(remoteApiServices, sessionState, lensState, lensRepository, operationalMetricsReporter));
  for (const { uri, handleRequest, cancelRequest } of allHandlers) {
    const uris = Array.isArray(uri) ? uri : [uri];
    for (const { scheme, route } of uris.map(extractSchemeAndRoute)) {
      lensCore.registerUriListener(scheme, route, {
        handleRequest: (request) => {
          const reply = (response) => {
            if (!isUriResponse(response)) {
              throw new Error("Expected UriResponse object");
            }
            lensCore.provideUriResponse(request.identifier, response);
          };
          const state = lensState.getState();
          if (isState(state, "noLensApplied")) {
            logger15.warn(`Got a URI request for ${request.uri}, but there is no active lens. The request will not be processed.`);
            return;
          }
          handleRequest(request, reply, state.data);
        },
        cancelRequest: (request) => {
          if (cancelRequest) {
            const state = lensState.getState();
            if (isState(state, "noLensApplied")) {
              logger15.warn(`Got a URI cancel request for ${request.uri}, but there is no active lens. The cancel request will not be processed.`);
              return;
            }
            cancelRequest(request, state.data);
          }
        }
      });
    }
  }
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportGlobalException.js
var logMethods = entries(logLevelMap).map(([level]) => level);
var maxBufferedEntries = 15;
var contextSeparator = "\n\n----------------- Context -----------------\n\n";
var methodLength = logMethods.reduce((max2, method) => Math.max(max2, method.length), 0);
function getContextString(logEntries) {
  const result = [];
  for (const { entry, count: count2, lastTime } of logEntries) {
    const time = entry.time.toISOString();
    const method = entry.level.padStart(methodLength);
    const messages = entry.messages.map((m2) => m2 + "").join(" ");
    let dupSuffix = count2 > 1 ? ` (Repeated ${count2} times with the last occurrence at ${lastTime.toISOString()})` : "";
    result.push(`${time} [${entry.module}] ${method}: ${messages}${dupSuffix}`);
  }
  return result.join("\n");
}
function reportExceptionToBlizzard(logEntries, metricsEventTarget, reporter, lensState) {
  logEntries.pipe(scan(
    ({ entries: entries2 }, newEntry) => {
      const lastEntry = entries2[entries2.length - 1];
      const isNewEntryRepeated = lastEntry && lastEntry.entry.messages.join() === newEntry.messages.join() && lastEntry.entry.level === newEntry.level;
      if (isNewEntryRepeated) {
        lastEntry.count += 1;
        lastEntry.lastTime = newEntry.time;
      } else {
        entries2.push({
          entry: newEntry,
          count: 1,
          lastTime: newEntry.time
        });
      }
      return {
        entries: entries2.slice(-maxBufferedEntries),
        recent: newEntry
      };
    },
    // Start with a dummy recent entry -- it gets overridden each time we handle a log entry.
    { entries: [], recent: { time: /* @__PURE__ */ new Date(), module: "any", level: "debug", messages: [] } }
  ), filter(({ recent }) => recent.level === "error"), map(({ entries: entries2, recent }) => ({
    context: entries2,
    error: recent.messages.find((e2) => e2 instanceof Error)
  })), filter(({ error }) => !!error)).subscribe(({ error, context: context2 }) => {
    const currentLensState = lensState === null || lensState === void 0 ? void 0 : lensState.getState();
    const lensId = currentLensState && !isState(currentLensState, "noLensApplied") ? currentLensState.data.id : "none";
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("exception", {
      name: "exception",
      lensId,
      type: error.name,
      reason: `${stringifyError(error)}${contextSeparator}${getContextString(context2)}`
    }));
    reporter.count("handled_exception", 1, /* @__PURE__ */ new Map([["type", error.name]]));
  });
}
var reportGlobalException = Injectable("reportGlobalException", [logEntriesFactory.token, metricsEventTargetFactory.token, operationalMetricReporterFactory.token], (logEntries, metricsEventTarget, reporter) => {
  const cancellationSubject = new Subject();
  reportExceptionToBlizzard(logEntries.pipe(takeUntil(cancellationSubject)), metricsEventTarget, reporter);
  return {
    attachLensContext: (lensState) => {
      cancellationSubject.next();
      reportExceptionToBlizzard(logEntries, metricsEventTarget, reporter, lensState);
    }
  };
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportSessionException.js
var reportSessionException = Injectable("reportSessionException", [reportGlobalException.token, lensStateFactory.token], (globalExceptionReporter, lensState) => {
  globalExceptionReporter.attachLensContext(lensState);
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportBenchmarks.js
var reportableBenchmarks = ["gflops"];
var reportBenchmarks = Injectable("reportBenchmarks", [metricsEventTargetFactory.token, operationalMetricReporterFactory.token, configurationToken], (metricsEventTarget, reporter, config2) => __awaiter(void 0, void 0, void 0, function* () {
  if (config2.lensPerformance === void 0)
    return;
  const lensPerformance = yield config2.lensPerformance;
  const baseBenchmark = {
    name: "benchmarkComplete",
    performanceCluster: lensPerformance.cluster,
    webglRendererInfo: lensPerformance.webglRendererInfo
  };
  const dimensions = /* @__PURE__ */ new Map([["performance_cluster", lensPerformance.cluster.toString()]]);
  for (const benchmark of lensPerformance.benchmarks) {
    if (!reportableBenchmarks.includes(benchmark.name))
      continue;
    const benchmarkComplete = Object.assign(Object.assign({}, baseBenchmark), { benchmarkName: benchmark.name, benchmarkValue: benchmark.value });
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("benchmarkComplete", benchmarkComplete));
    reporter.histogram(`benchmark.${benchmark.name}`, benchmark.value, dimensions);
  }
}));

// node_modules/@snap/camera-kit/lib/events/scan.js
var scan2 = (seedState) => (source, eventTypes, accumulator) => {
  let state = seedState;
  const sink = new TypedEventTarget();
  const listener = (event) => {
    state = accumulator(state, event);
    sink.dispatchEvent(new TypedCustomEvent("state", state));
  };
  let hasListener = false;
  sink.addEventListener = new Proxy(sink.addEventListener, {
    apply: (target, thisArg, args) => {
      if (hasListener)
        throw new Error("Cannot add another event listener. The TypedEventTarget returned by scan only supports a single listener, and one has already been added.");
      hasListener = true;
      eventTypes.forEach((eventType) => source.addEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  sink.removeEventListener = new Proxy(sink.removeEventListener, {
    apply: (target, thisArg, args) => {
      eventTypes.forEach((eventType) => source.removeEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  return sink;
};

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportLensAndAssetDownload.js
var relevantRequestTypes = ["lens_content", "asset"];
var isLensOrAssetRequest = (value) => {
  const requestType = value["requestType"];
  return typeof requestType === "string" && relevantRequestTypes.includes(requestType);
};
var reportLensAndAssetDownload = Injectable("reportLensAndAssetDownload", [
  metricsEventTargetFactory.token,
  operationalMetricReporterFactory.token,
  requestStateEventTargetFactory.token
], (metricsEventTarget, reporter, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    const { inProgress } = state;
    const { dimensions, requestId: requestId2, timeMs } = event.detail;
    if (!isLensOrAssetRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        inProgress.set(requestId2, { startTimeMs: timeMs });
        return { name: "inProgress", inProgress };
      case "completed":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const downloadTimeSec = (timeMs - completedRequest.startTimeMs) / 1e3;
        const { sizeByte } = event.detail;
        switch (dimensions.requestType) {
          case "lens_content":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("lensDownload", {
                name: "lensDownload",
                lensId: dimensions.lensId,
                automaticDownload: false,
                sizeByte,
                downloadTimeSec
              })
            };
          case "asset":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("assetDownload", {
                name: "assetDownload",
                assetId: dimensions.assetId,
                automaticDownload: false,
                sizeByte,
                downloadTimeSec
              })
            };
          default:
            assertUnreachable(dimensions);
        }
      case "errored":
        const erroredRequest = inProgress.get(requestId2);
        if (!erroredRequest)
          return state;
        inProgress.delete(requestId2);
        const error = event.detail.error;
        return {
          name: "completed",
          inProgress,
          event: new TypedCustomEvent("exception", {
            name: "exception",
            lensId: dimensions.lensId,
            type: dimensions.requestType === "lens_content" ? "lens" : "asset",
            reason: stringifyError(error)
          })
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    metricsEventTarget.dispatchEvent(state.event);
    if (state.event.detail.name === "exception") {
      reporter.count("handled_exception", 1, /* @__PURE__ */ new Map([["type", state.event.detail.type]]));
    }
  });
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportHttpMetrics.js
var getContentType = (dimensions) => {
  switch (dimensions.requestType) {
    case "lens_content":
      return "lens_content";
    case "asset":
      return dimensions.assetType;
    case COF_REQUEST_TYPE:
      return COF_REQUEST_TYPE;
    default:
      assertUnreachable(dimensions);
  }
};
var getSizeKb = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return 0;
    case "completed":
      return event.detail.sizeByte / 1024;
    default:
      assertUnreachable(event);
  }
};
var getStatus = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return "0";
    case "completed":
      return event.detail.status.toString();
    default:
      assertUnreachable(event);
  }
};
var isRelevantRequest = (value) => {
  return isLensOrAssetRequest(value) || value["requestType"] === COF_REQUEST_TYPE;
};
var reportHttpMetrics = Injectable("reportHttpMetrics", [operationalMetricReporterFactory.token, requestStateEventTargetFactory.token], (reporter, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    var _a;
    const { inProgress } = state;
    const { dimensions, requestId: requestId2, timeMs } = event.detail;
    if (!isRelevantRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        inProgress.set(requestId2, { startTimeMs: timeMs });
        return { name: "inProgress", inProgress };
      case "completed":
      case "errored":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const downloadTimeMs = timeMs - completedRequest.startTimeMs;
        const downloadSizeKb = getSizeKb(event);
        const status = getStatus(event);
        const operationalDimensions = /* @__PURE__ */ new Map([
          ["content_type", getContentType(dimensions)],
          ["network_type", (_a = getPlatformInfo().connectionType) !== null && _a !== void 0 ? _a : "unknown"],
          ["status", status]
        ]);
        return {
          name: "completed",
          inProgress: state.inProgress,
          dimensions: operationalDimensions,
          downloadSizeKb,
          downloadTimeMs
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    const { dimensions, downloadTimeMs, downloadSizeKb } = state;
    reporter.count("download_finished", 1, dimensions);
    reporter.timer("download_latency", downloadTimeMs, dimensions);
    reporter.histogram("download_size_kb", downloadSizeKb, dimensions);
  });
});

// node_modules/@snap/camera-kit/lib/generated-proto/blizzard/cameraKitEvents.js
var ServerEvent = {
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const message = createBaseServerEvent();
    message.eventName = (_a = object.eventName) !== null && _a !== void 0 ? _a : "";
    message.serverTs = (_b = object.serverTs) !== null && _b !== void 0 ? _b : 0;
    message.userId = (_c = object.userId) !== null && _c !== void 0 ? _c : "";
    message.userAgent = (_d = object.userAgent) !== null && _d !== void 0 ? _d : "";
    message.country = (_e = object.country) !== null && _e !== void 0 ? _e : "";
    message.city = (_f = object.city) !== null && _f !== void 0 ? _f : "";
    message.region = (_g = object.region) !== null && _g !== void 0 ? _g : "";
    message.eventId = (_h = object.eventId) !== null && _h !== void 0 ? _h : "";
    message.instanceId = (_j = object.instanceId) !== null && _j !== void 0 ? _j : "";
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : 0;
    message.osType = (_l = object.osType) !== null && _l !== void 0 ? _l : "";
    message.osVersion = (_m = object.osVersion) !== null && _m !== void 0 ? _m : "";
    message.appVersion = (_o = object.appVersion) !== null && _o !== void 0 ? _o : "";
    message.appBuild = (_p = object.appBuild) !== null && _p !== void 0 ? _p : "";
    message.serverUploadTs = (_q = object.serverUploadTs) !== null && _q !== void 0 ? _q : 0;
    message.eventTime = (_r = object.eventTime) !== null && _r !== void 0 ? _r : 0;
    message.serverReceiptTime = (_s = object.serverReceiptTime) !== null && _s !== void 0 ? _s : 0;
    message.maxSequenceIdOnInstance = (_t = object.maxSequenceIdOnInstance) !== null && _t !== void 0 ? _t : 0;
    message.userGuid = (_u = object.userGuid) !== null && _u !== void 0 ? _u : "";
    message.collection = (_v = object.collection) !== null && _v !== void 0 ? _v : 0;
    message.serviceId = (_w = object.serviceId) !== null && _w !== void 0 ? _w : "";
    message.appType = (_x = object.appType) !== null && _x !== void 0 ? _x : 0;
    message.spectrumInstanceId = (_y = object.spectrumInstanceId) !== null && _y !== void 0 ? _y : "";
    message.spectrumSequenceId = (_z = object.spectrumSequenceId) !== null && _z !== void 0 ? _z : 0;
    message.eventData = object.eventData !== void 0 && object.eventData !== null ? ServerEventData.fromPartial(object.eventData) : void 0;
    return message;
  }
};
var ServerEventData = {
  fromPartial(object) {
    const message = createBaseServerEventData();
    message.cameraKitException = object.cameraKitException !== void 0 && object.cameraKitException !== null ? CameraKitException.fromPartial(object.cameraKitException) : void 0;
    message.cameraKitLensSpin = object.cameraKitLensSpin !== void 0 && object.cameraKitLensSpin !== null ? CameraKitLensSpin.fromPartial(object.cameraKitLensSpin) : void 0;
    message.cameraKitAssetDownload = object.cameraKitAssetDownload !== void 0 && object.cameraKitAssetDownload !== null ? CameraKitAssetDownload.fromPartial(object.cameraKitAssetDownload) : void 0;
    message.cameraKitLensContentValidationFailed = object.cameraKitLensContentValidationFailed !== void 0 && object.cameraKitLensContentValidationFailed !== null ? CameraKitLensContentValidationFailed.fromPartial(object.cameraKitLensContentValidationFailed) : void 0;
    message.cameraKitLensDownload = object.cameraKitLensDownload !== void 0 && object.cameraKitLensDownload !== null ? CameraKitLensDownload.fromPartial(object.cameraKitLensDownload) : void 0;
    message.cameraKitAssetValidationFailed = object.cameraKitAssetValidationFailed !== void 0 && object.cameraKitAssetValidationFailed !== null ? CameraKitAssetValidationFailed.fromPartial(object.cameraKitAssetValidationFailed) : void 0;
    message.cameraKitSession = object.cameraKitSession !== void 0 && object.cameraKitSession !== null ? CameraKitSession2.fromPartial(object.cameraKitSession) : void 0;
    message.cameraKitWebLensSwipe = object.cameraKitWebLensSwipe !== void 0 && object.cameraKitWebLensSwipe !== null ? CameraKitWebLensSwipe.fromPartial(object.cameraKitWebLensSwipe) : void 0;
    message.cameraKitWebBenchmarkComplete = object.cameraKitWebBenchmarkComplete !== void 0 && object.cameraKitWebBenchmarkComplete !== null ? CameraKitWebBenchmarkComplete.fromPartial(object.cameraKitWebBenchmarkComplete) : void 0;
    message.cameraKitLegalPrompt = object.cameraKitLegalPrompt !== void 0 && object.cameraKitLegalPrompt !== null ? CameraKitLegalPrompt.fromPartial(object.cameraKitLegalPrompt) : void 0;
    return message;
  }
};
function createBaseServerEventData() {
  return {
    cameraKitException: void 0,
    cameraKitLensSpin: void 0,
    cameraKitAssetDownload: void 0,
    cameraKitLensContentValidationFailed: void 0,
    cameraKitLensDownload: void 0,
    cameraKitAssetValidationFailed: void 0,
    cameraKitSession: void 0,
    cameraKitWebLensSwipe: void 0,
    cameraKitWebBenchmarkComplete: void 0,
    cameraKitLegalPrompt: void 0
  };
}
function createBaseServerEvent() {
  return {
    eventName: "",
    serverTs: 0,
    userId: "",
    userAgent: "",
    country: "",
    city: "",
    region: "",
    eventId: "",
    instanceId: "",
    sequenceId: 0,
    osType: "",
    osVersion: "",
    appVersion: "",
    appBuild: "",
    serverUploadTs: 0,
    eventTime: 0,
    serverReceiptTime: 0,
    maxSequenceIdOnInstance: 0,
    userGuid: "",
    collection: 0,
    serviceId: "",
    appType: 0,
    spectrumInstanceId: "",
    spectrumSequenceId: 0,
    eventData: void 0
  };
}
var AppType;
(function(AppType2) {
  AppType2[AppType2["IOS_NATIVE"] = 0] = "IOS_NATIVE";
  AppType2[AppType2["IOS_WEB_DESKTOP"] = 1] = "IOS_WEB_DESKTOP";
  AppType2[AppType2["IOS_WEB_MOBILE"] = 2] = "IOS_WEB_MOBILE";
  AppType2[AppType2["ANDROID_NATIVE"] = 3] = "ANDROID_NATIVE";
  AppType2[AppType2["ANDROID_WEB_DESKTOP"] = 4] = "ANDROID_WEB_DESKTOP";
  AppType2[AppType2["ANDROID_WEB_MOBILE"] = 5] = "ANDROID_WEB_MOBILE";
  AppType2[AppType2["OSX_WEB_DESKTOP"] = 6] = "OSX_WEB_DESKTOP";
  AppType2[AppType2["OSX_WEB_MOBILE"] = 7] = "OSX_WEB_MOBILE";
  AppType2[AppType2["WINDOWS_WEB_DESKTOP"] = 8] = "WINDOWS_WEB_DESKTOP";
  AppType2[AppType2["WINDOWS_WEB_MOBILE"] = 9] = "WINDOWS_WEB_MOBILE";
  AppType2[AppType2["LINUX_WEB_DESKTOP"] = 10] = "LINUX_WEB_DESKTOP";
  AppType2[AppType2["LINUX_WEB_MOBILE"] = 11] = "LINUX_WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO"] = 12] = "LENSSTUDIO";
  AppType2[AppType2["SNAPCAMERA"] = 13] = "SNAPCAMERA";
  AppType2[AppType2["WEB_DESKTOP"] = 14] = "WEB_DESKTOP";
  AppType2[AppType2["WEB_MOBILE"] = 15] = "WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO_REMAKE"] = 16] = "LENSSTUDIO_REMAKE";
  AppType2[AppType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AppType || (AppType = {}));
var Collection;
(function(Collection2) {
  Collection2[Collection2["COLLECTION_UNUSED"] = 0] = "COLLECTION_UNUSED";
  Collection2[Collection2["GAE"] = 1] = "GAE";
  Collection2[Collection2["GCE_M"] = 2] = "GCE_M";
  Collection2[Collection2["GCE_S"] = 3] = "GCE_S";
  Collection2[Collection2["GCE_T"] = 4] = "GCE_T";
  Collection2[Collection2["GKE_M"] = 5] = "GKE_M";
  Collection2[Collection2["GKE_S"] = 6] = "GKE_S";
  Collection2[Collection2["GKE_T"] = 7] = "GKE_T";
  Collection2[Collection2["LOCAL"] = 8] = "LOCAL";
  Collection2[Collection2["GCE_ST"] = 9] = "GCE_ST";
  Collection2[Collection2["GKE_ST"] = 10] = "GKE_ST";
  Collection2[Collection2["GCE_C"] = 11] = "GCE_C";
  Collection2[Collection2["GCE_SC"] = 12] = "GCE_SC";
  Collection2[Collection2["GCE_TC"] = 13] = "GCE_TC";
  Collection2[Collection2["GCE_TSC"] = 14] = "GCE_TSC";
  Collection2[Collection2["GKE_C"] = 15] = "GKE_C";
  Collection2[Collection2["GKE_SC"] = 16] = "GKE_SC";
  Collection2[Collection2["GKE_TC"] = 17] = "GKE_TC";
  Collection2[Collection2["GKE_TSC"] = 18] = "GKE_TSC";
  Collection2[Collection2["GKE_W"] = 19] = "GKE_W";
  Collection2[Collection2["GKE_WT"] = 20] = "GKE_WT";
  Collection2[Collection2["GKE_WC"] = 21] = "GKE_WC";
  Collection2[Collection2["GKE_WSC"] = 22] = "GKE_WSC";
  Collection2[Collection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Collection || (Collection = {}));
var CameraKitLensSpin = {
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitLensSpin();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.viewTimeSec = (_b = object.viewTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.lensGroupId = (_c = object.lensGroupId) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitLensSpin() {
  return { cameraKitEventBase: void 0, lensId: "", viewTimeSec: 0, lensGroupId: "" };
}
var CameraKitWebLensSwipe = {
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const message = createBaseCameraKitWebLensSwipe();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.performanceCluster = (_a = object.performanceCluster) !== null && _a !== void 0 ? _a : 0;
    message.webglRendererInfo = (_b = object.webglRendererInfo) !== null && _b !== void 0 ? _b : "";
    message.lensId = (_c = object.lensId) !== null && _c !== void 0 ? _c : "";
    message.lensFrameProcessingTimeMsAvg = (_d = object.lensFrameProcessingTimeMsAvg) !== null && _d !== void 0 ? _d : 0;
    message.lensFrameProcessingTimeMsStd = (_e = object.lensFrameProcessingTimeMsStd) !== null && _e !== void 0 ? _e : 0;
    message.viewTimeSec = (_f = object.viewTimeSec) !== null && _f !== void 0 ? _f : 0;
    message.recordingTimeSec = (_g = object.recordingTimeSec) !== null && _g !== void 0 ? _g : 0;
    message.applyDelaySec = (_h = object.applyDelaySec) !== null && _h !== void 0 ? _h : 0;
    message.avgFps = (_j = object.avgFps) !== null && _j !== void 0 ? _j : 0;
    message.isLensFirstWithinDay = (_k = object.isLensFirstWithinDay) !== null && _k !== void 0 ? _k : false;
    message.isLensFirstWithinMonth = (_l = object.isLensFirstWithinMonth) !== null && _l !== void 0 ? _l : false;
    message.lensGroupId = (_m = object.lensGroupId) !== null && _m !== void 0 ? _m : "";
    return message;
  }
};
function createBaseCameraKitWebLensSwipe() {
  return {
    cameraKitEventBase: void 0,
    performanceCluster: 0,
    webglRendererInfo: "",
    lensId: "",
    lensFrameProcessingTimeMsAvg: 0,
    lensFrameProcessingTimeMsStd: 0,
    viewTimeSec: 0,
    recordingTimeSec: 0,
    applyDelaySec: 0,
    avgFps: 0,
    isLensFirstWithinDay: false,
    isLensFirstWithinMonth: false,
    lensGroupId: ""
  };
}
var CameraKitLensDownload = {
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitLensDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.automaticDownload = (_b = object.automaticDownload) !== null && _b !== void 0 ? _b : false;
    message.downloadTimeSec = (_c = object.downloadTimeSec) !== null && _c !== void 0 ? _c : 0;
    message.sizeByte = (_d = object.sizeByte) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};
function createBaseCameraKitLensDownload() {
  return { cameraKitEventBase: void 0, lensId: "", automaticDownload: false, downloadTimeSec: 0, sizeByte: 0 };
}
var CameraKitAssetDownload = {
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitAssetDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.automaticDownload = (_a = object.automaticDownload) !== null && _a !== void 0 ? _a : false;
    message.downloadTimeSec = (_b = object.downloadTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.sizeByte = (_c = object.sizeByte) !== null && _c !== void 0 ? _c : 0;
    message.assetId = (_d = object.assetId) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitAssetDownload() {
  return { cameraKitEventBase: void 0, automaticDownload: false, downloadTimeSec: 0, sizeByte: 0, assetId: "" };
}
var CameraKitException = {
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitException();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : "";
    message.reason = (_c = object.reason) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitException() {
  return { cameraKitEventBase: void 0, lensId: "", type: "", reason: "" };
}
var CameraKitSession2 = {
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseCameraKitSession();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.dailySessionBucket = (_a = object.dailySessionBucket) !== null && _a !== void 0 ? _a : 0;
    message.isFirstWithinMonth = (_b = object.isFirstWithinMonth) !== null && _b !== void 0 ? _b : false;
    message.day = (_c = object.day) !== null && _c !== void 0 ? _c : 0;
    message.month = (_d = object.month) !== null && _d !== void 0 ? _d : 0;
    message.year = (_e = object.year) !== null && _e !== void 0 ? _e : 0;
    return message;
  }
};
function createBaseCameraKitSession() {
  return { cameraKitEventBase: void 0, dailySessionBucket: 0, isFirstWithinMonth: false, day: 0, month: 0, year: 0 };
}
var DailySessionBucket;
(function(DailySessionBucket2) {
  DailySessionBucket2[DailySessionBucket2["NO_SESSION_BUCKET"] = 0] = "NO_SESSION_BUCKET";
  DailySessionBucket2[DailySessionBucket2["ONE_SESSION"] = 1] = "ONE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TWO_SESSION"] = 2] = "TWO_SESSION";
  DailySessionBucket2[DailySessionBucket2["THREE_SESSION"] = 3] = "THREE_SESSION";
  DailySessionBucket2[DailySessionBucket2["FOUR_SESSION"] = 4] = "FOUR_SESSION";
  DailySessionBucket2[DailySessionBucket2["FIVE_SESSION"] = 5] = "FIVE_SESSION";
  DailySessionBucket2[DailySessionBucket2["SIX_SESSION"] = 6] = "SIX_SESSION";
  DailySessionBucket2[DailySessionBucket2["SEVEN_SESSION"] = 7] = "SEVEN_SESSION";
  DailySessionBucket2[DailySessionBucket2["EIGHT_SESSION"] = 8] = "EIGHT_SESSION";
  DailySessionBucket2[DailySessionBucket2["NINE_SESSION"] = 9] = "NINE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TEN_OR_MORE_SESSION"] = 10] = "TEN_OR_MORE_SESSION";
  DailySessionBucket2[DailySessionBucket2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DailySessionBucket || (DailySessionBucket = {}));
var CameraKitLensContentValidationFailed = {
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitLensContentValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitLensContentValidationFailed() {
  return { cameraKitEventBase: void 0, lensId: "" };
}
var CameraKitAssetValidationFailed = {
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitAssetValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.assetId = (_a = object.assetId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitAssetValidationFailed() {
  return { cameraKitEventBase: void 0, assetId: "" };
}
var CameraKitWebBenchmarkComplete = {
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitWebBenchmarkComplete();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.benchmarkName = (_a = object.benchmarkName) !== null && _a !== void 0 ? _a : "";
    message.benchmarkValue = (_b = object.benchmarkValue) !== null && _b !== void 0 ? _b : 0;
    message.performanceCluster = (_c = object.performanceCluster) !== null && _c !== void 0 ? _c : 0;
    message.webglRendererInfo = (_d = object.webglRendererInfo) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitWebBenchmarkComplete() {
  return {
    cameraKitEventBase: void 0,
    benchmarkName: "",
    benchmarkValue: 0,
    performanceCluster: 0,
    webglRendererInfo: ""
  };
}
var CameraKitLegalPrompt = {
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCameraKitLegalPrompt();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.legalPromptId = (_a = object.legalPromptId) !== null && _a !== void 0 ? _a : "";
    message.legalPromptResult = (_b = object.legalPromptResult) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
var CameraKitEventBase = {
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const message = createBaseCameraKitEventBase();
    message.kitEventBase = object.kitEventBase !== void 0 && object.kitEventBase !== null ? KitEventBase.fromPartial(object.kitEventBase) : void 0;
    message.deviceCluster = (_a = object.deviceCluster) !== null && _a !== void 0 ? _a : 0;
    message.cameraKitVersion = (_b = object.cameraKitVersion) !== null && _b !== void 0 ? _b : "";
    message.lensCoreVersion = (_c = object.lensCoreVersion) !== null && _c !== void 0 ? _c : "";
    message.deviceModel = (_d = object.deviceModel) !== null && _d !== void 0 ? _d : "";
    message.cameraKitVariant = (_e = object.cameraKitVariant) !== null && _e !== void 0 ? _e : 0;
    message.cameraKitFlavor = (_f = object.cameraKitFlavor) !== null && _f !== void 0 ? _f : 0;
    message.appId = (_g = object.appId) !== null && _g !== void 0 ? _g : "";
    message.deviceConnectivity = (_h = object.deviceConnectivity) !== null && _h !== void 0 ? _h : 0;
    message.sessionId = (_j = object.sessionId) !== null && _j !== void 0 ? _j : "";
    message.appVendorUuid = (_k = object.appVendorUuid) !== null && _k !== void 0 ? _k : "";
    message.rankingRequestId = (_l = object.rankingRequestId) !== null && _l !== void 0 ? _l : "";
    message.cameraKitEnvironment = (_m = object.cameraKitEnvironment) !== null && _m !== void 0 ? _m : 0;
    message.partnerUuid = (_o = object.partnerUuid) !== null && _o !== void 0 ? _o : "";
    return message;
  }
};
var KitEventBase = {
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const message = createBaseKitEventBase();
    message.oauthClientId = (_a = object.oauthClientId) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    message.kitUserAgent = (_c = object.kitUserAgent) !== null && _c !== void 0 ? _c : "";
    message.ipAddress = (_d = object.ipAddress) !== null && _d !== void 0 ? _d : "";
    message.osMinorVersion = (_e = object.osMinorVersion) !== null && _e !== void 0 ? _e : "";
    message.kitVariant = (_f = object.kitVariant) !== null && _f !== void 0 ? _f : 0;
    message.kitVariantVersion = (_g = object.kitVariantVersion) !== null && _g !== void 0 ? _g : "";
    message.kitClientTimestampMillis = (_h = object.kitClientTimestampMillis) !== null && _h !== void 0 ? _h : 0;
    message.clientSequenceId = (_j = object.clientSequenceId) !== null && _j !== void 0 ? _j : 0;
    message.maxClientSequenceIdOnInstance = (_k = object.maxClientSequenceIdOnInstance) !== null && _k !== void 0 ? _k : 0;
    message.targetArchitecture = (_l = object.targetArchitecture) !== null && _l !== void 0 ? _l : "";
    message.runningWithDebuggerAttached = (_m = object.runningWithDebuggerAttached) !== null && _m !== void 0 ? _m : false;
    message.runningInTests = (_o = object.runningInTests) !== null && _o !== void 0 ? _o : false;
    message.runningInSimulator = (_p = object.runningInSimulator) !== null && _p !== void 0 ? _p : false;
    message.isAppPrerelease = (_q = object.isAppPrerelease) !== null && _q !== void 0 ? _q : false;
    message.kitAppId = (_r = object.kitAppId) !== null && _r !== void 0 ? _r : "";
    message.kitSessionId = (_s = object.kitSessionId) !== null && _s !== void 0 ? _s : "";
    message.kitPluginType = (_t = object.kitPluginType) !== null && _t !== void 0 ? _t : 0;
    message.isFromReactNativePlugin = (_u = object.isFromReactNativePlugin) !== null && _u !== void 0 ? _u : false;
    return message;
  }
};
function createBaseKitEventBase() {
  return {
    oauthClientId: "",
    locale: "",
    kitUserAgent: "",
    ipAddress: "",
    osMinorVersion: "",
    kitVariant: 0,
    kitVariantVersion: "",
    kitClientTimestampMillis: 0,
    clientSequenceId: 0,
    maxClientSequenceIdOnInstance: 0,
    targetArchitecture: "",
    runningWithDebuggerAttached: false,
    runningInTests: false,
    runningInSimulator: false,
    isAppPrerelease: false,
    kitAppId: "",
    kitSessionId: "",
    kitPluginType: 0,
    isFromReactNativePlugin: false
  };
}
function createBaseCameraKitEventBase() {
  return {
    kitEventBase: void 0,
    deviceCluster: 0,
    cameraKitVersion: "",
    lensCoreVersion: "",
    deviceModel: "",
    cameraKitVariant: 0,
    cameraKitFlavor: 0,
    appId: "",
    deviceConnectivity: 0,
    sessionId: "",
    appVendorUuid: "",
    rankingRequestId: "",
    cameraKitEnvironment: 0,
    partnerUuid: ""
  };
}
function createBaseCameraKitLegalPrompt() {
  return { cameraKitEventBase: void 0, legalPromptId: "", legalPromptResult: 0 };
}
var CameraKitLegalPromptResult;
(function(CameraKitLegalPromptResult2) {
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_MISSING"] = 0] = "CAMERA_KIT_LEGAL_PROMPT_MISSING";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_ACCEPTED"] = 1] = "CAMERA_KIT_LEGAL_PROMPT_ACCEPTED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_DISMISSED"] = 2] = "CAMERA_KIT_LEGAL_PROMPT_DISMISSED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitLegalPromptResult || (CameraKitLegalPromptResult = {}));
var CameraKitEnvironment2;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNKNOWN"] = 0] = "CAMERA_KIT_ENVIRONMENT_UNKNOWN";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = 1] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = 2] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3[CameraKitEnvironment3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitEnvironment2 || (CameraKitEnvironment2 = {}));
var CameraKitConnectivityType2;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN"] = 0] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = 1] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = 2] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3[CameraKitConnectivityType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitConnectivityType2 || (CameraKitConnectivityType2 = {}));
var CameraKitFlavor2;
(function(CameraKitFlavor3) {
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNKNOWN"] = 0] = "CAMERA_KIT_FLAVOR_UNKNOWN";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = 1] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = 2] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3[CameraKitFlavor3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitFlavor2 || (CameraKitFlavor2 = {}));
var CameraKitVariant;
(function(CameraKitVariant2) {
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_UNKNOWN"] = 0] = "CAMERA_KIT_VARIANT_UNKNOWN";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PARTNER"] = 1] = "CAMERA_KIT_VARIANT_PARTNER";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PUBLIC"] = 2] = "CAMERA_KIT_VARIANT_PUBLIC";
  CameraKitVariant2[CameraKitVariant2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitVariant || (CameraKitVariant = {}));
var KitPluginType;
(function(KitPluginType2) {
  KitPluginType2[KitPluginType2["NO_PLUGIN"] = 0] = "NO_PLUGIN";
  KitPluginType2[KitPluginType2["UNITY"] = 1] = "UNITY";
  KitPluginType2[KitPluginType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitPluginType || (KitPluginType = {}));
var KitType;
(function(KitType2) {
  KitType2[KitType2["UNKNOWN_KIT_TYPE"] = 0] = "UNKNOWN_KIT_TYPE";
  KitType2[KitType2["BITMOJI_KIT"] = 1] = "BITMOJI_KIT";
  KitType2[KitType2["CREATIVE_KIT"] = 2] = "CREATIVE_KIT";
  KitType2[KitType2["LOGIN_KIT"] = 3] = "LOGIN_KIT";
  KitType2[KitType2["STORY_KIT"] = 4] = "STORY_KIT";
  KitType2[KitType2["CAMERA_KIT"] = 5] = "CAMERA_KIT";
  KitType2[KitType2["SHOP_KIT"] = 6] = "SHOP_KIT";
  KitType2[KitType2["EULA_KIT"] = 7] = "EULA_KIT";
  KitType2[KitType2["PAYMENTS_KIT"] = 8] = "PAYMENTS_KIT";
  KitType2[KitType2["INVITE_KIT"] = 9] = "INVITE_KIT";
  KitType2[KitType2["CAMERA_KIT_WEB"] = 10] = "CAMERA_KIT_WEB";
  KitType2[KitType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitType || (KitType = {}));

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportLegalState.js
var reportLegalState = Injectable("reportLegalState", [legalStateFactory.token, metricsEventTargetFactory.token, operationalMetricReporterFactory.token], (legalState, metricsEventTarget, operationalMetricsReporter) => {
  legalState.events.pipe(forActions("accept", "reject"), map(([{ data, name }]) => ({
    name: "legalPrompt",
    legalPromptId: data,
    legalPromptResult: name === "accept" ? CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED : CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_DISMISSED
  }))).subscribe({
    next: (legalPromptEvent) => {
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("legalPrompt", legalPromptEvent));
      operationalMetricsReporter.count("legal_prompt_interaction", 1, /* @__PURE__ */ new Map([
        [
          "accepted",
          (legalPromptEvent.legalPromptResult === CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED).toString()
        ]
      ]));
    }
  });
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportLensValidationFailed.js
var reportLensValidationFailed = Injectable("reportLensValidationFailed", [lensStateFactory.token, metricsEventTargetFactory.token], (lensState, metricsEventTarget) => {
  lensState.events.pipe(forActions("applyLensFailed"), filter(([a2]) => a2.data.error.name === "LensContentValidationError")).subscribe({
    next: ([{ data }]) => {
      const { lens } = data;
      const lensContentValidationFailed = {
        name: "lensContentValidationFailed",
        lensId: lens.id
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensContentValidationFailed", lensContentValidationFailed));
    }
  });
});

// node_modules/@snap/camera-kit/lib/metrics/operational/Histogram.js
var Histogram = class _Histogram extends Metric {
  static level(name, level, dimsensions = {}) {
    const histogram = new _Histogram(name, dimsensions);
    histogram.add(level);
    return histogram;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.levels = [];
  }
  add(level) {
    this.levels.push(level);
  }
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    const name = `${this.name}${serializeMetricDimensions(this.dimensions)}`;
    return this.levels.map((level) => ({ name, timestamp: timestamp2, metric: { $case: "histogram", histogram: level } }));
  }
};

// node_modules/@snap/camera-kit/lib/common/date.js
var DEFAULT_TIMEZONE = "America/Los_Angeles";
var dayFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric",
  day: "numeric"
});
var monthFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric"
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportLensView.js
var viewTimeThresholdSec = 0.1;
function isFirstTimeWithinPeriods(lensId, persistence) {
  return __awaiter(this, void 0, void 0, function* () {
    let isLensFirstWithinDay = false;
    let isLensFirstWithinMonth = false;
    try {
      const lensLastViewDate = yield persistence.retrieve(lensId);
      const currentDate = /* @__PURE__ */ new Date();
      if (!lensLastViewDate) {
        isLensFirstWithinDay = true;
        isLensFirstWithinMonth = true;
      } else {
        isLensFirstWithinDay = dayFormatter.format(lensLastViewDate) !== dayFormatter.format(currentDate);
        isLensFirstWithinMonth = monthFormatter.format(lensLastViewDate) !== monthFormatter.format(currentDate);
      }
      yield persistence.store(lensId, currentDate);
    } catch (error) {
      console.error(`Error handling persistence for lensId ${lensId}: ${error}`);
      isLensFirstWithinDay = false;
      isLensFirstWithinMonth = false;
    }
    return { isLensFirstWithinDay, isLensFirstWithinMonth };
  });
}
var reportLensView = Injectable("reportLensView", [
  cameraKitSessionFactory.token,
  lensStateFactory.token,
  sessionStateFactory.token,
  metricsEventTargetFactory.token,
  operationalMetricReporterFactory.token,
  configurationToken
], (session, lensState, sessionState, metricsEventTarget, operationalMetricsReporter, configuration) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  const { cluster: performanceCluster, webglRendererInfo } = (_a = yield configuration.lensPerformance) !== null && _a !== void 0 ? _a : {
    cluster: 0,
    webglRendererInfo: "unknown"
  };
  const lensViewPersistence = new ExpiringPersistence(
    // 60 days expiration
    () => 60 * 24 * 60 * 60,
    new IndexedDBPersistence({ databaseName: "recentLensViews" })
  );
  merge(
    // Begin measuring LensCore apply time once the lens has finished downloading and we actually add the lens
    // to LensCore (LensWait measures the full download + LensCore apply time i.e. perceived UX latency).
    lensState.events.pipe(forActions("downloadComplete"), map(([a2]) => a2.data)),
    // If the session is resumed (e.g. user returns to this tab while a lens is on), we count this as a new
    // LensView (and applyDelaySec will be 0).
    lensState.events.pipe(inStates("lensApplied"), switchMap(([, s2]) => sessionState.events.pipe(forActions("resume"), takeUntil(lensState.events.pipe(forActions("removeLens"))), map(() => s2.data))))
  ).pipe(map((lens) => [getTimeMs(), lens.id, lens.groupId]), mergeMap(([applyLensStartTime, lensId, lensGroupId]) => {
    const alreadyOn = isState(lensState.getState(), "lensApplied");
    const applyDelay = alreadyOn ? of(0) : lensState.events.pipe(
      forActions("resourcesLoaded"),
      filter(([a2]) => a2.data.id === lensId),
      // Applying a new lens may happen before removing the old one, so if we kept taking events
      // we would get the lensResourcesLoaded for the next lens, too.
      take(1),
      map(() => (getTimeMs() - applyLensStartTime) / 1e3)
    );
    const viewMetrics = (alreadyOn ? of([getTimeMs(), session.metrics.beginMeasurement()]) : lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id === lensId), map(() => [getTimeMs(), session.metrics.beginMeasurement()]))).pipe(take(1), mergeMap(([lensTurnedOnTime, metricsMeasurement]) => lensState.events.pipe(
      forActions("turnedOff"),
      // Applying a new lens may happen before removing the old one, so we'll get a
      // lensTurnedOff for the prior lens (if one was applied), which we must filter out.
      filter(([a2]) => a2.data.id === lensId),
      // If the session is suspended, we'll count that as the lens turning off.
      raceWith(sessionState.events.pipe(forActions("suspend"))),
      map(() => {
        metricsMeasurement.end();
        return Object.assign({ viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1e3 }, metricsMeasurement.measure());
      })
    )));
    return applyDelay.pipe(
      combineLatestWith(viewMetrics, from(isFirstTimeWithinPeriods(lensId, lensViewPersistence))),
      // This lens should always receive the lensTurnedOff action *before* the next lens is
      // turned on. But just in case that assumption is violated, we'll clean up
      // (and not report) if another lens turns on before our lens is turned off.
      takeUntil(lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id !== lensId))),
      take(1),
      map(([applyDelaySec, viewMetrics2, isFirstTimeResults]) => Object.assign(Object.assign({
        applyDelaySec,
        lensId,
        lensGroupId
      }, viewMetrics2), isFirstTimeResults))
    );
  })).subscribe({
    next: ({ applyDelaySec, lensId, lensGroupId, viewTimeSec, avgFps, lensFrameProcessingTimeMsAvg, lensFrameProcessingTimeMsStd, lensFrameProcessingTimeMsMedian, lensFrameProcessingN, isLensFirstWithinDay, isLensFirstWithinMonth }) => __awaiter(void 0, void 0, void 0, function* () {
      if (viewTimeSec < viewTimeThresholdSec)
        return;
      const lensView = {
        name: "lensView",
        applyDelaySec,
        avgFps,
        lensId,
        lensGroupId,
        lensFrameProcessingTimeMsAvg,
        lensFrameProcessingTimeMsStd,
        // We don't support recording video, but applications may do this without our knowledge.
        recordingTimeSec: 0,
        viewTimeSec,
        isLensFirstWithinDay,
        isLensFirstWithinMonth,
        performanceCluster,
        webglRendererInfo
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensView", lensView));
      operationalMetricsReporter.report(Histogram.level("lens_view", viewTimeSec * 1e3));
      if (lensFrameProcessingN >= 30) {
        operationalMetricsReporter.report(Histogram.level("lens_view_frame-processing-time", lensFrameProcessingTimeMsMedian, {
          performance_cluster: performanceCluster.toString()
        }));
      }
    })
  });
}));

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportLensWait.js
var viewTimeThresholdSec2 = 0.1;
var reportLensWait = Injectable("reportLensWait", [lensStateFactory.token, metricsEventTargetFactory.token, operationalMetricReporterFactory.token], (lensState, metricsEventTarget, reporter) => {
  lensState.events.pipe(forActions("applyLens"), mergeMap(([a2]) => {
    const lensId = a2.data.lens.id;
    const lensGroupId = a2.data.lens.groupId;
    const applyLensStartTime = getTimeMs();
    return lensState.events.pipe(
      // We'll measure the time until either the requested lens was rendered, or a new applyLens
      // request was made (in both cases, we're done waiting for this lens).
      //
      // This does have the side-effect that if a user rapidly switches between lenses, we'll record
      // many low-duration lensWait events that are measuring user behavior instead of system latency.
      // But this is a good trade-off so that we can capture those long-duration lensWaits that are
      // terminated by the user trying a different lens.
      //
      // (This effect can be mitigated by increasing the viewtimeThresholdSec to ignore low-duration
      // waits that are likely caused by user behavior).
      forActions("firstFrameProcessed", "applyLens"),
      take(1),
      map(() => [
        (getTimeMs() - applyLensStartTime) / 1e3,
        lensId,
        lensGroupId
      ])
    );
  })).subscribe({
    next: ([viewTimeSec, lensId, lensGroupId]) => {
      if (viewTimeSec < viewTimeThresholdSec2)
        return;
      const lensWait = {
        name: "lensWait",
        lensId,
        viewTimeSec,
        lensGroupId
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensWait", lensWait));
      reporter.timer("lens.apply_lens_latency", viewTimeSec * 1e3);
    }
  });
});

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportUserSession.js
var reportUserSession = Injectable("reportUserSession", [metricsEventTargetFactory.token], (metricsEventTarget) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  const userSessionKey = "userSessionInfo";
  const db = new IndexedDBPersistence({ databaseName: "SessionHistory" });
  const date = /* @__PURE__ */ new Date();
  const formattedDate = dayFormatter.format(date);
  const formattedDateParts = dayFormatter.formatToParts(date);
  const { day, month, year } = formattedDateParts.reduce((acc, { type, value }) => Object.assign(Object.assign({}, acc), { [type]: parseInt(value) }), {});
  const userSessionInfo = yield db.retrieve(userSessionKey);
  const mostRecentSessionStartDate = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.mostRecentSessionStartDate;
  const formattedMostRecentSessionStartDate = mostRecentSessionStartDate ? dayFormatter.format(mostRecentSessionStartDate) : null;
  const dailySessionBucketMap = /* @__PURE__ */ new Map([
    [1, DailySessionBucket.ONE_SESSION],
    [2, DailySessionBucket.TWO_SESSION],
    [3, DailySessionBucket.THREE_SESSION],
    [4, DailySessionBucket.FOUR_SESSION],
    [5, DailySessionBucket.FIVE_SESSION],
    [6, DailySessionBucket.SIX_SESSION],
    [7, DailySessionBucket.SEVEN_SESSION],
    [8, DailySessionBucket.EIGHT_SESSION],
    [9, DailySessionBucket.NINE_SESSION]
  ]);
  let dailySessionBucket = (_a = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.dailySessionBucket) !== null && _a !== void 0 ? _a : DailySessionBucket.NO_SESSION_BUCKET;
  let isFirstWithinMonth = false;
  if (formattedMostRecentSessionStartDate === formattedDate) {
    dailySessionBucket = (_b = dailySessionBucketMap.get(dailySessionBucket + 1)) !== null && _b !== void 0 ? _b : DailySessionBucket.TEN_OR_MORE_SESSION;
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket
    });
  } else {
    isFirstWithinMonth = !mostRecentSessionStartDate || monthFormatter.format(mostRecentSessionStartDate) !== monthFormatter.format(date);
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket: dailySessionBucket = DailySessionBucket.ONE_SESSION
    });
  }
  const session = {
    name: "session",
    dailySessionBucket,
    isFirstWithinMonth,
    month,
    day,
    year
  };
  metricsEventTarget.dispatchEvent(new TypedCustomEvent("session", session));
}));

// node_modules/@snap/camera-kit/lib/metrics/operational/Count.js
var Count = class _Count extends Metric {
  static count(name, n2, dimensions = {}) {
    const count2 = new _Count(name, dimensions);
    count2.increment(n2);
    return count2;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.count = 0;
  }
  increment(count2) {
    this.count += count2;
    return this.count;
  }
  toOperationalMetric() {
    return [
      {
        name: `${this.name}${serializeMetricDimensions(this.dimensions)}`,
        timestamp: /* @__PURE__ */ new Date(),
        metric: { $case: "count", count: this.count }
      }
    ];
  }
};

// node_modules/@snap/camera-kit/lib/metrics/reporters/reportPlatformCapabilities.js
var reportPlatformCapabilities = Injectable("reportPlatformCapabilities", [operationalMetricReporterFactory.token], (operationalMetricsReporter) => __awaiter(void 0, void 0, void 0, function* () {
  const { webgl, wasm, webxr } = yield getPlatformCapabilities();
  operationalMetricsReporter.report(Count.count("platform_webgl", webgl.supported ? 1 : 0));
  operationalMetricsReporter.report(Count.count("platform_wasm", wasm.supported ? 1 : 0));
  operationalMetricsReporter.report(Count.count("platform_webxr", webxr.supported ? 1 : 0));
}));

// node_modules/@snap/camera-kit/lib/metrics/reporters/reporters.js
var reportGloballyScopedMetrics = new PartialContainer({}).provides(reportHttpMetrics).provides(reportBenchmarks).provides(reportLensAndAssetDownload).provides(reportLegalState).provides(reportPlatformCapabilities);
var reportSessionScopedMetrics = new PartialContainer({}).provides(reportUserSession).provides(reportLensView).provides(reportLensWait).provides(reportSessionException).provides(reportLensValidationFailed);

// node_modules/browser-fs-access/dist/index.modern.js
var e = (() => {
  if ("undefined" == typeof self)
    return false;
  if ("top" in self && self !== top)
    try {
      top;
    } catch (e2) {
      return false;
    }
  else if ("showOpenFilePicker" in self)
    return "showOpenFilePicker";
  return false;
})();
var t = e ? Promise.resolve().then(function() {
  return l;
}) : Promise.resolve().then(function() {
  return h;
});
async function n(...e2) {
  return (await t).default(...e2);
}
var r = e ? Promise.resolve().then(function() {
  return y;
}) : Promise.resolve().then(function() {
  return P;
});
var a = e ? Promise.resolve().then(function() {
  return m;
}) : Promise.resolve().then(function() {
  return k;
});
var s = async (e2) => {
  const t2 = await e2.getFile();
  return t2.handle = e2, t2;
};
var c = async (e2 = [{}]) => {
  Array.isArray(e2) || (e2 = [e2]);
  const t2 = [];
  e2.forEach((e3, n3) => {
    t2[n3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? e3.mimeTypes.map((r3) => {
      t2[n3].accept[r3] = e3.extensions || [];
    }) : t2[n3].accept["*/*"] = e3.extensions || [];
  });
  const n2 = await window.showOpenFilePicker({ id: e2[0].id, startIn: e2[0].startIn, types: t2, multiple: e2[0].multiple || false, excludeAcceptAllOption: e2[0].excludeAcceptAllOption || false }), r2 = await Promise.all(n2.map(s));
  return e2[0].multiple ? r2 : r2[0];
};
var l = { __proto__: null, default: c };
function u(e2) {
  function t2(e3) {
    if (Object(e3) !== e3)
      return Promise.reject(new TypeError(e3 + " is not an object."));
    var t3 = e3.done;
    return Promise.resolve(e3.value).then(function(e4) {
      return { value: e4, done: t3 };
    });
  }
  return u = function(e3) {
    this.s = e3, this.n = e3.next;
  }, u.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.resolve({ value: e3, done: true }) : t2(n2.apply(this.s, arguments));
  }, throw: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.reject(e3) : t2(n2.apply(this.s, arguments));
  } }, new u(e2);
}
var p = async (e2, t2, n2 = e2.name, r2) => {
  const i = [], a2 = [];
  var o, s2 = false, c2 = false;
  try {
    for (var l2, d2 = function(e3) {
      var t3, n3, r3, i2 = 2;
      for ("undefined" != typeof Symbol && (n3 = Symbol.asyncIterator, r3 = Symbol.iterator); i2--; ) {
        if (n3 && null != (t3 = e3[n3]))
          return t3.call(e3);
        if (r3 && null != (t3 = e3[r3]))
          return new u(t3.call(e3));
        n3 = "@@asyncIterator", r3 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e2.values()); s2 = !(l2 = await d2.next()).done; s2 = false) {
      const o2 = l2.value, s3 = `${n2}/${o2.name}`;
      "file" === o2.kind ? a2.push(o2.getFile().then((t3) => (t3.directoryHandle = e2, t3.handle = o2, Object.defineProperty(t3, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s3 })))) : "directory" !== o2.kind || !t2 || r2 && r2(o2) || i.push(p(o2, t2, s3, r2));
    }
  } catch (e3) {
    c2 = true, o = e3;
  } finally {
    try {
      s2 && null != d2.return && await d2.return();
    } finally {
      if (c2)
        throw o;
    }
  }
  return [...(await Promise.all(i)).flat(), ...await Promise.all(a2)];
};
var d = async (e2 = {}) => {
  e2.recursive = e2.recursive || false, e2.mode = e2.mode || "read";
  const t2 = await window.showDirectoryPicker({ id: e2.id, startIn: e2.startIn, mode: e2.mode });
  return p(t2, e2.recursive, void 0, e2.skipDirectory);
};
var y = { __proto__: null, default: d };
var f = async (e2, t2 = [{}], n2 = null, r2 = false, i = null) => {
  Array.isArray(t2) || (t2 = [t2]), t2[0].fileName = t2[0].fileName || "Untitled";
  const a2 = [];
  let o = null;
  if (e2 instanceof Blob && e2.type ? o = e2.type : e2.headers && e2.headers.get("content-type") && (o = e2.headers.get("content-type")), t2.forEach((e3, t3) => {
    a2[t3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? (0 === t3 && o && e3.mimeTypes.push(o), e3.mimeTypes.map((n3) => {
      a2[t3].accept[n3] = e3.extensions || [];
    })) : o ? a2[t3].accept[o] = e3.extensions || [] : a2[t3].accept["*/*"] = e3.extensions || [];
  }), n2)
    try {
      await n2.getFile();
    } catch (e3) {
      if (n2 = null, r2)
        throw e3;
    }
  const s2 = n2 || await window.showSaveFilePicker({ suggestedName: t2[0].fileName, id: t2[0].id, startIn: t2[0].startIn, types: a2, excludeAcceptAllOption: t2[0].excludeAcceptAllOption || false });
  !n2 && i && i(s2);
  const c2 = await s2.createWritable();
  if ("stream" in e2) {
    const t3 = e2.stream();
    return await t3.pipeTo(c2), s2;
  }
  return "body" in e2 ? (await e2.body.pipeTo(c2), s2) : (await c2.write(await e2), await c2.close(), s2);
};
var m = { __proto__: null, default: f };
var w = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file";
  const i = [...e2.map((e3) => e3.mimeTypes || []), ...e2.map((e3) => e3.extensions || [])].join();
  r2.multiple = e2[0].multiple || false, r2.accept = i || "", r2.style.display = "none", document.body.append(r2);
  const a2 = (e3) => {
    "function" == typeof o && o(), t2(e3);
  }, o = e2[0].legacySetup && e2[0].legacySetup(a2, () => o(n2), r2), s2 = () => {
    window.removeEventListener("focus", s2), r2.remove();
  };
  r2.addEventListener("click", () => {
    window.addEventListener("focus", s2);
  }), r2.addEventListener("change", () => {
    window.removeEventListener("focus", s2), r2.remove(), a2(r2.multiple ? Array.from(r2.files) : r2.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var h = { __proto__: null, default: w };
var v = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), e2[0].recursive = e2[0].recursive || false, new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file", r2.webkitdirectory = true;
  const i = (e3) => {
    "function" == typeof a2 && a2(), t2(e3);
  }, a2 = e2[0].legacySetup && e2[0].legacySetup(i, () => a2(n2), r2);
  r2.addEventListener("change", () => {
    let t3 = Array.from(r2.files);
    e2[0].recursive ? e2[0].recursive && e2[0].skipDirectory && (t3 = t3.filter((t4) => t4.webkitRelativePath.split("/").every((t5) => !e2[0].skipDirectory({ name: t5, kind: "directory" })))) : t3 = t3.filter((e3) => 2 === e3.webkitRelativePath.split("/").length), i(t3);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var P = { __proto__: null, default: v };
var b = async (e2, t2 = {}) => {
  Array.isArray(t2) && (t2 = t2[0]);
  const n2 = document.createElement("a");
  let r2 = e2;
  "body" in e2 && (r2 = await async function(e3, t3) {
    const n3 = e3.getReader(), r3 = new ReadableStream({ start: (e4) => async function t4() {
      return n3.read().then(({ done: n4, value: r4 }) => {
        if (!n4)
          return e4.enqueue(r4), t4();
        e4.close();
      });
    }() }), i2 = new Response(r3), a3 = await i2.blob();
    return n3.releaseLock(), new Blob([a3], { type: t3 });
  }(e2.body, e2.headers.get("content-type"))), n2.download = t2.fileName || "Untitled", n2.href = URL.createObjectURL(await r2);
  const i = () => {
    "function" == typeof a2 && a2();
  }, a2 = t2.legacySetup && t2.legacySetup(i, () => a2(), n2);
  return n2.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n2.href), 3e4), i();
  }), n2.click(), null;
};
var k = { __proto__: null, default: b };

// node_modules/@snap/camera-kit/lib/lens-client-interface/exif.js
var JPEG_ID = 65496;
var APP1_MARKER = 65505;
var EXIF_ID = 1165519206;
var LITTLE_ENDIAN = 18761;
var ORIENTATION_TAG_OFFSET = 274;
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["TopLeft"] = 1] = "TopLeft";
  Orientation2[Orientation2["TopRight"] = 2] = "TopRight";
  Orientation2[Orientation2["BottomRight"] = 3] = "BottomRight";
  Orientation2[Orientation2["BottomLeft"] = 4] = "BottomLeft";
  Orientation2[Orientation2["LeftTop"] = 5] = "LeftTop";
  Orientation2[Orientation2["RightTop"] = 6] = "RightTop";
  Orientation2[Orientation2["RightBottom"] = 7] = "RightBottom";
  Orientation2[Orientation2["LeftBottom"] = 8] = "LeftBottom";
})(Orientation || (Orientation = {}));
function extractJpegOrientationTag(data) {
  const view = new DataView(data);
  if (view.getUint16(0, false) !== JPEG_ID)
    return void 0;
  const length = view.byteLength;
  let offset = 2;
  while (offset < length) {
    if (view.getUint16(offset + 2, false) <= 8)
      return void 0;
    let marker = view.getUint16(offset, false);
    offset += 2;
    if (marker === APP1_MARKER) {
      if (view.getUint32(offset += 2, false) !== EXIF_ID) {
        return void 0;
      }
      let little = view.getUint16(offset += 6, false) === LITTLE_ENDIAN;
      offset += view.getUint32(offset + 4, little);
      let tags = view.getUint16(offset, little);
      offset += 2;
      for (let i = 0; i < tags; i++) {
        if (view.getUint16(offset + i * 12, little) === ORIENTATION_TAG_OFFSET) {
          return view.getUint16(offset + i * 12 + 8, little);
        }
      }
    } else if ((marker & 65280) !== 65280) {
      break;
    } else {
      offset += view.getUint16(offset, false);
    }
  }
  return void 0;
}

// node_modules/@snap/camera-kit/lib/lens-client-interface/imagePicker.js
var logger16 = getLogger("lensClientInterfaceImagePicker");
var mimeTypes = {
  image: [
    "image/avif",
    "image/bmp",
    "image/gif",
    "image/jpeg",
    "image/png",
    "image/svg+xml",
    "image/tiff",
    "image/webp"
  ],
  video: [
    "video/3gpp",
    "video/3gpp2",
    "video/mp2t",
    "video/mp4",
    "video/mpeg",
    "video/ogg",
    "video/quicktime",
    "video/webm",
    "video/x-msvideo"
  ]
};
function* enumerateSupportedVideoTypes(types) {
  const testVideoElement = typeof document !== "undefined" ? document.createElement("video") : void 0;
  for (const type of types) {
    if ((testVideoElement === null || testVideoElement === void 0 ? void 0 : testVideoElement.canPlayType(type)) || false) {
      yield type;
    }
  }
}
function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.addEventListener("load", (event) => {
      resolve(event.target.result);
    });
    reader.addEventListener("error", (event) => {
      reject(event.target.error);
    });
    reader.readAsArrayBuffer(file);
  });
}
function getMimeType({ ImageEnabled, VideoEnabled }) {
  const types = [];
  if (ImageEnabled === "1")
    types.push(...mimeTypes.image);
  if (VideoEnabled === "1")
    types.push(...enumerateSupportedVideoTypes(mimeTypes.video));
  if (types.length === 0) {
    throw new Error("Unknown media type requested.");
  }
  return types;
}
function getOrientation(data, lensCore) {
  var _a;
  const orientationMap = {
    [
      1
      /* Orientation.TopLeft */
    ]: lensCore.ExternalMediaOrientation.CW0,
    [
      2
      /* Orientation.TopRight */
    ]: lensCore.ExternalMediaOrientation.CW0,
    [
      3
      /* Orientation.BottomRight */
    ]: lensCore.ExternalMediaOrientation.CW180,
    [
      4
      /* Orientation.BottomLeft */
    ]: lensCore.ExternalMediaOrientation.CW180,
    [
      5
      /* Orientation.LeftTop */
    ]: lensCore.ExternalMediaOrientation.CW90,
    [
      6
      /* Orientation.RightTop */
    ]: lensCore.ExternalMediaOrientation.CW90,
    [
      7
      /* Orientation.RightBottom */
    ]: lensCore.ExternalMediaOrientation.CW270,
    [
      8
      /* Orientation.LeftBottom */
    ]: lensCore.ExternalMediaOrientation.CW270
  };
  try {
    return orientationMap[
      (_a = extractJpegOrientationTag(data)) !== null && _a !== void 0 ? _a : 1
      /* Orientation.TopLeft */
    ];
  } catch (error) {
    logger16.info("Error occured while reading EXIF orientation tag.", error);
    return lensCore.ExternalMediaOrientation.CW0;
  }
}
function pickClientImage(clientInterfaceData, lensCore) {
  return __awaiter(this, void 0, void 0, function* () {
    const mimeTypes2 = getMimeType(clientInterfaceData);
    logger16.debug(`Opening file dialog for MIME types: ${mimeTypes2}`);
    const file = yield n({ mimeTypes: mimeTypes2 });
    logger16.debug(`Selected file MIME type: ${file.type}`);
    const data = yield readFileAsArrayBuffer(file);
    if (file.type.startsWith("image/")) {
      lensCore.provideExternalImage({
        data,
        orientation: getOrientation(data, lensCore),
        // As per Corvyn: both iOS and Android clients have the ability to pick out individual faces
        // from an image to apply the effect on, using each of their native face detectors (not using LensCore).
        // That's what the faceRects is for. For now, we can just apply the effect to the whole image (so face rect
        // [[0,0][1,1]]). In future, in order to be able to pick out individual faces in the media picker, we could:
        // - hook up some external web face tracking library
        // - make LensCore to expose face tracker to external clients
        faceRects: [
          {
            origin: {
              x: 0,
              y: 0
            },
            size: {
              width: 1,
              height: 1
            }
          }
        ]
      });
    } else {
      lensCore.provideExternalVideo({
        data,
        orientation: lensCore.ExternalMediaOrientation.CW0
      });
    }
  });
}

// node_modules/@snap/camera-kit/lib/lens-client-interface/lensClientInterface.js
var logger17 = getLogger("lensClientInterface");
var registerLensClientInterfaceHandler = Injectable("registerLensClientInterfaceHandler", [lensCoreFactory.token], (lensCore) => {
  if (!lensCore.setClientInterfaceRequestHandler) {
    logger17.warn("Current LensCore version doesn't support lens client interface requests");
    return;
  }
  lensCore.setClientInterfaceRequestHandler(({ data, interfaceControl, interfaceAction }) => __awaiter(void 0, void 0, void 0, function* () {
    if (interfaceControl === lensCore.InterfaceControl.ImagePicker && interfaceAction === lensCore.InterfaceAction.Show) {
      yield pickClientImage(data, lensCore).catch((error) => {
        logger17.error(lensImagePickerError("Error occurred while attempting to select an image file for the lens request.", error));
      });
    }
  }));
});

// node_modules/@snap/camera-kit/lib/remote-configuration/preloadConfiguration.js
var setPreloadedConfiguration = Injectable("setPreloadedConfiguration", [lensCoreFactory.token, remoteConfigurationFactory.token], (lensCore, remoteConfiguration) => {
  remoteConfiguration.getNamespace(Namespace.LENS_CORE_CONFIG).pipe(take(1)).subscribe((configs) => {
    const inputs = configs.map(({ configId, value }) => ({ configId, value }));
    lensCore.setPreloadedConfiguration(inputs);
  });
});

// node_modules/@snap/camera-kit/lib/CameraKit.js
var logger18 = getLogger("CameraKit");
var log4 = errorLoggingDecorator(logger18);
var publicMetricsEventNames = ["lensView", "lensWait"];
var CameraKit = class {
  /** @internal */
  constructor(lensRepository, lensCore, pageVisibility, container, allMetrics) {
    this.lensRepository = lensRepository;
    this.lensCore = lensCore;
    this.pageVisibility = pageVisibility;
    this.container = container;
    this.metrics = new TypedEventTarget();
    this.sessions = [];
    this.lenses = { repository: this.lensRepository };
    publicMetricsEventNames.forEach((eventName) => {
      allMetrics.addEventListener(eventName, (e2) => this.metrics.dispatchEvent(e2));
    });
  }
  /**
   * Create a CameraKitSession.
   *
   * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access
   * to Lens rendering.
   *
   * @example
   * ```ts
   * const cameraKit = await bootstrapCameraKit(config)
   * const session = await cameraKit.createSession()
   *
   * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
   * session.applyLens(lens)
   * ```
   *
   * @param options
   */
  createSession({ liveRenderTarget, renderWhileTabHidden } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const exceptionHandler = (error) => {
        if (error.name === "LensCoreAbortError") {
          logger18.error(lensAbortError("Unrecoverable error occurred during lens execution. The CameraKitSession will be destroyed.", error));
        } else {
          logger18.error(lensExecutionError("Error occurred during lens execution. The lens cannot be rendered and will be removed from the CameraKitSession.", error));
        }
      };
      yield this.lensCore.initialize({
        canvas: liveRenderTarget,
        shouldUseWorker: !renderWhileTabHidden && this.container.get(configurationToken).shouldUseWorker,
        exceptionHandler
      });
      yield this.lensCore.setRenderLoopMode({
        mode: renderWhileTabHidden ? this.lensCore.RenderLoopMode.SetTimeout : this.lensCore.RenderLoopMode.RequestAnimationFrame
      });
      const sessionContainer = this.container.copy().provides(sessionStateFactory).provides(lensStateFactory).provides(lensKeyboardFactory).provides(cameraKitSessionFactory).run(registerLensAssetsProvider).run(registerLensClientInterfaceHandler).run(setPreloadedConfiguration).run(reportSessionScopedMetrics).run(registerUriHandlers);
      const session = sessionContainer.get(cameraKitSessionFactory.token);
      this.sessions.push(session);
      return session;
    });
  }
  /**
   * Destroys all sessions and frees all resources.
   */
  destroy() {
    return __awaiter(this, void 0, void 0, function* () {
      resetLogger();
      this.pageVisibility.destroy();
      yield Promise.all(this.sessions.map((session) => session.destroy()));
      this.sessions = [];
    });
  }
};
__decorate([
  log4,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], CameraKit.prototype, "createSession", null);
__decorate([
  log4,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", []),
  __metadata("design:returntype", Promise)
], CameraKit.prototype, "destroy", null);
var cameraKitFactory = Injectable("CameraKit", [
  lensRepositoryFactory.token,
  metricsEventTargetFactory.token,
  lensCoreFactory.token,
  pageVisibilityFactory.token,
  CONTAINER
], (lensRepository, metrics, lensCore, pageVisibility, container) => new CameraKit(lensRepository, lensCore, pageVisibility, container, metrics));

// node_modules/@snap/camera-kit/lib/platform/assertPlatformSupported.js
function assertPlatformSupported() {
  return __awaiter(this, void 0, void 0, function* () {
    const { wasm, webgl } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    if (!webgl.supported)
      throw webgl.error;
  });
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  const arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b2 = -271733879;
  let c2 = -1732584194;
  let d2 = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a2;
    const oldb = b2;
    const oldc = c2;
    const oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x[i], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x[i + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x[i + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x[i + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x[i + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x[i + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x[i + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x[i + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x[i + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x[i + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x[i + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x[i + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x[i + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x[i + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x[i], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x[i + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x[i + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x[i + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x[i + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x[i + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x[i + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x[i + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x[i + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x[i + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x[i + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x[i + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x[i + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x[i + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x[i + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x[i + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x[i + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x[i], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x[i + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x[i + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x[i + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x[i + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x[i + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x[i + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x[i], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x[i + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x[i + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x[i + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x[i + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x[i + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x[i + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x[i + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x[i + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x[i + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x[i + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b2, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x, s2, t2);
}
function md5gg(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x, s2, t2);
}
function md5hh(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x, s2, t2);
}
function md5ii(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x, s2, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x, y2, z) {
  switch (s2) {
    case 0:
      return x & y2 ^ ~x & z;
    case 1:
      return x ^ y2 ^ z;
    case 2:
      return x & y2 ^ x & z ^ y2 & z;
    case 3:
      return x ^ y2 ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N = Math.ceil(l2 / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[i][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
    }
    let a2 = H[0];
    let b2 = H[1];
    let c2 = H[2];
    let d2 = H[3];
    let e2 = H[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s2 = Math.floor(t2 / 20);
      const T = ROTL(a2, 5) + f2(s2, b2, c2, d2) + e2 + K[s2] + W[t2] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@snap/camera-kit/lib/metrics/businessEventsReporter.js
var logger19 = getLogger("BusinessEventsReporter");
var relativePath2 = "/com.snap.camerakit.v3.Metrics/metrics/business_events";
var BUSINESS_EVENT_BATCH_MAX_SIZE = 10;
var BUSINESS_EVENT_BATCH_MAX_AGE_MS = 5e3;
var connectivityTypeMapping = {
  cellular: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE,
  bluetooth: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH,
  wifi: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_WIFI,
  unknown: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN,
  none: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE
};
var vendorUuidKey = "vendorUuid";
var vendorUuidExpiry = convertDaysToSeconds(60);
var getOrGenerateVendorUuid = (persistence) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const storedUuid = yield persistence.retrieve(vendorUuidKey);
    if (storedUuid) {
      return storedUuid;
    }
    const newUuid = v4_default();
    yield persistence.store(vendorUuidKey, newUuid);
    return newUuid;
  } catch (error) {
    throw new Error("Failed to generate vendor UUID");
  }
});
function listenAndReport(metricsEventTarget, metricsHandler, pageVisibility, eventHandlers, apiHostname, appVendorAndPartnerUuid) {
  const sessionId = v4_default();
  logger19.log(`Session ID: ${sessionId}`);
  let sequenceId = 1;
  const handler = new HandlerChainBuilder(metricsHandler).map(createMappingHandler((events) => {
    const body = {
      batchEvents: {
        "@type": "com.snapchat.analytics.blizzard.ServerEventBatch",
        serverEvents: events
      }
    };
    return new Request(`https://${apiHostname}${relativePath2}`, {
      method: "POST",
      body: JSON.stringify(body),
      credentials: "include",
      // When this is true it makes fetch behave like `Navigator.sendBeacon`  that is, the request
      // will still be made even if the page terminates.
      // https://developer.mozilla.org/en-US/docs/Web/API/fetch
      keepalive: pageVisibility.isDuringVisibilityTransition("hidden")
    });
  }, pageVisibility)).map(createBatchingHandler({
    batchReduce: (previousBundle, businessEvent) => {
      const bundle = previousBundle !== null && previousBundle !== void 0 ? previousBundle : [];
      bundle.push(businessEvent);
      return bundle;
    },
    isBatchComplete: (bundle) => bundle.length >= BUSINESS_EVENT_BATCH_MAX_SIZE,
    maxBatchAge: BUSINESS_EVENT_BATCH_MAX_AGE_MS,
    pageVisibility
  })).handler;
  const makeBlizzardEvent = (event, appVendorUuid, partnerUuid) => {
    var _a;
    const { sdkShortVersion, sdkLongVersion, lensCore, locale, origin, deviceModel, connectionType } = getPlatformInfo();
    const deviceConnectivity = (_a = connectivityTypeMapping[connectionType]) !== null && _a !== void 0 ? _a : CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN;
    return Object.assign(Object.assign({}, event), { cameraKitEventBase: CameraKitEventBase.fromPartial({
      kitEventBase: KitEventBase.fromPartial({
        locale,
        kitVariant: KitType.CAMERA_KIT_WEB,
        kitVariantVersion: sdkShortVersion,
        kitClientTimestampMillis: Date.now()
      }),
      deviceCluster: 0,
      cameraKitVersion: sdkLongVersion,
      lensCoreVersion: lensCore.version,
      deviceModel,
      cameraKitVariant: CameraKitVariant.CAMERA_KIT_VARIANT_PARTNER,
      cameraKitFlavor: CameraKitFlavor2.CAMERA_KIT_FLAVOR_DEBUG,
      // We overload appId, using the origin instead because it's nice and human-readable (our backed adds
      // the true appId as oauth_client_id before forwarding events to Blizzard).
      appId: origin,
      deviceConnectivity,
      sessionId,
      appVendorUuid,
      partnerUuid
    }) });
  };
  const sendServerEvent = (eventName, eventData) => {
    const { osName: osType, osVersion } = getPlatformInfo();
    return handler(ServerEvent.fromPartial({
      eventName,
      osType,
      osVersion,
      maxSequenceIdOnInstance: 0,
      sequenceId: sequenceId++,
      eventData
    }));
  };
  const metricsEvents = entries(eventHandlers).map(([eventType, createEventData]) => fromEvent(metricsEventTarget, eventType).pipe(map((event) => ({ event, createEventData }))));
  merge(...metricsEvents).pipe(combineLatestWith(appVendorAndPartnerUuid)).subscribe(([{ event, createEventData }, { appVendorUuid, partnerUuid }]) => {
    const [eventName, eventData] = createEventData(makeBlizzardEvent(event.detail, appVendorUuid, partnerUuid));
    sendServerEvent(eventName, eventData);
  });
}
function getAppVendorAndPartnerUuid(configuration, remoteConfiguration) {
  const vendorAnalyticsPersistence = new ExpiringPersistence(() => vendorUuidExpiry, new IndexedDBPersistence({ databaseName: "SessionHistory" }));
  return remoteConfiguration.getInitializationConfig().pipe(take(1), switchMap(({ appVendorUuidOptIn }) => {
    const partnerUuid = configuration.analyticsId;
    if (appVendorUuidOptIn) {
      return from(getOrGenerateVendorUuid(vendorAnalyticsPersistence)).pipe(map((appVendorUuid) => ({ appVendorUuid, partnerUuid })));
    }
    return of({ appVendorUuid: void 0, partnerUuid });
  }), catchError((error) => {
    logger19.warn(`Failed to retrieve or generate vendor UUID.`, error);
    return of({ appVendorUuid: void 0, partnerUuid: configuration.analyticsId });
  }));
}
var businessEventsReporterFactory = Injectable("businessEventsReporter", [
  metricsEventTargetFactory.token,
  metricsHandlerFactory.token,
  pageVisibilityFactory.token,
  configurationToken,
  remoteConfigurationFactory.token
], (metricsEventTarget, metricsHandler, pageVisibility, configuration, remoteConfiguration) => {
  const appVendorAndPartnerUuid = getAppVendorAndPartnerUuid(configuration, remoteConfiguration);
  listenAndReport(metricsEventTarget, metricsHandler, pageVisibility, {
    assetDownload: (event) => [
      "CAMERA_KIT_ASSET_DOWNLOAD",
      { cameraKitAssetDownload: CameraKitAssetDownload.fromPartial(event) }
    ],
    assetValidationFailed: (event) => [
      "CAMERA_KIT_ASSET_VALIDATION_FAILED",
      {
        cameraKitAssetValidationFailed: CameraKitAssetValidationFailed.fromPartial(event)
      }
    ],
    benchmarkComplete: (event) => [
      "CAMERA_KIT_WEB_BENCHMARK_COMPLETE",
      {
        cameraKitWebBenchmarkComplete: CameraKitWebBenchmarkComplete.fromPartial(event)
      }
    ],
    exception: (event) => [
      "CAMERA_KIT_EXCEPTION",
      { cameraKitException: CameraKitException.fromPartial(event) }
    ],
    legalPrompt: (event) => [
      "CAMERA_KIT_LEGAL_PROMPT",
      { cameraKitLegalPrompt: CameraKitLegalPrompt.fromPartial(event) }
    ],
    lensDownload: (event) => [
      "CAMERA_KIT_LENS_DOWNLOAD",
      { cameraKitLensDownload: CameraKitLensDownload.fromPartial(event) }
    ],
    lensView: (event) => [
      "CAMERA_KIT_WEB_LENS_SWIPE",
      { cameraKitWebLensSwipe: CameraKitWebLensSwipe.fromPartial(event) }
    ],
    lensWait: (event) => [
      "CAMERA_KIT_LENS_SPIN",
      { cameraKitLensSpin: CameraKitLensSpin.fromPartial(event) }
    ],
    lensContentValidationFailed: (event) => [
      "CAMERA_KIT_LENS_CONTENT_VALIDATION_FAILED",
      {
        cameraKitLensContentValidationFailed: CameraKitLensContentValidationFailed.fromPartial(event)
      }
    ],
    session: (event) => [
      "CAMERA_KIT_SESSION",
      { cameraKitSession: CameraKitSession2.fromPartial(event) }
    ]
  }, configuration.apiHostname, appVendorAndPartnerUuid);
});

// node_modules/@snap/camera-kit/lib/logger/registerLogEntriesSubscriber.js
var registerLogEntriesSubscriber = Injectable("registerLogEntriesSubscriber", [configurationToken, logEntriesFactory.token], (configuration, logEntries) => {
  logEntries.pipe(filter((entry) => logLevelMap[entry.level] >= logLevelMap[configuration.logLevel])).subscribe((logEntry) => {
    switch (configuration.logger) {
      case "console":
        const messages = getPlatformInfo().browser.brand === "Chrome" ? logEntry.messages.map((message) => {
          if (!(message instanceof Error))
            return message;
          message.stack = stringifyError(message);
          return message;
        }) : logEntry.messages;
        console[logEntry.level](`[CameraKit.${logEntry.module}]`, ...messages);
        break;
    }
  });
});

// node_modules/@snap/camera-kit/lib/bootstrapCameraKit.js
var logger20 = getLogger("bootstrapCameraKit");
var nonWrappableErrors = [
  "ConfigurationError",
  "PlatformNotSupportedError"
];
function shouldWrapError(error) {
  if (error instanceof Error) {
    return !nonWrappableErrors.some((name) => error.name === name);
  }
  return true;
}
function bootstrapCameraKit(configuration, provide) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      const startTimeMs = performance.now();
      assert(isSafeString(configuration.apiToken), configurationError("Invalid or unsafe apiToken provided."));
      const configurationFactory = createCameraKitConfigurationFactory(configuration);
      const defaultPublicContainer = Container.provides(configurationFactory).provides(pageVisibilityFactory).provides(defaultFetchHandlerFactory).provides(remoteMediaAssetLoaderFactory).provides(lensSourcesFactory).provides(remoteApiServicesFactory).provides(uriHandlersFactory);
      const publicContainer = provide ? provide(defaultPublicContainer) : defaultPublicContainer;
      const telemetryContainer = Container.provides(publicContainer).provides(logEntriesFactory).run(registerLogEntriesSubscriber).provides(cameraKitServiceFetchHandlerFactory).provides(requestStateEventTargetFactory).provides(metricsEventTargetFactory).provides(metricsHandlerFactory).provides(operationalMetricReporterFactory).provides(reportGlobalException).provides(cofHandlerFactory).provides(remoteConfigurationFactory).provides(legalPromptFactory).provides(legalStateFactory).run(reportGloballyScopedMetrics).run(businessEventsReporterFactory);
      telemetryContainer.get(reportGlobalException.token);
      yield assertPlatformSupported();
      const lensCore = yield telemetryContainer.provides(lensCoreFactory).get(lensCoreFactory.token);
      const container = telemetryContainer.provides(Injectable(lensCoreFactory.token, () => lensCore)).provides(lensPersistenceStoreFactory).provides(deviceDependentAssetLoaderFactory).provides(staticAssetLoaderFactory).provides(lensAssetRepositoryFactory).provides(lensRepositoryFactory).provides(cameraKitFactory);
      const cameraKit = container.get(cameraKitFactory.token);
      const bootstrapTimeMs = performance.now() - startTimeMs;
      const reporter = container.get(operationalMetricReporterFactory.token);
      reporter.timer("bootstrap_time", bootstrapTimeMs);
      return cameraKit;
    } catch (error) {
      if (shouldWrapError(error)) {
        error = bootstrapError("Error occurred during Camera Kit bootstrapping.", error);
      }
      logger20.error(error);
      throw error;
    }
  });
}
function createExtension() {
  return new PartialContainer({});
}

// node_modules/@snap/camera-kit/lib/extensions/extensionRequestContext.js
function getExtensionRequestContext() {
  return ExtensionRequestContext.encode({
    userAgent: getCameraKitUserAgent(),
    locale: getPlatformInfo().fullLocale
  }).finish();
}
var extensionRequestContext = getExtensionRequestContext();

// node_modules/@snap/camera-kit/lib/media-sources/FunctionSource.js
var getYUVImageData = (canvas, lensCore) => __awaiter(void 0, void 0, void 0, function* () {
  const { width: width2, height: height2 } = canvas;
  const outputBuffer = new ArrayBuffer(width2 * height2 * 3 / 2);
  yield lensCore.imageToYuvBuffer({ image: canvas, width: width2, height: height2, outputBuffer });
  const pixels = new Uint8ClampedArray(outputBuffer);
  return new ImageData(pixels, width2, height2);
});
var getRGBImageData = (output, imageReader2D) => {
  if (imageReader2D === null)
    return new ImageData(0, 0);
  imageReader2D.drawImage(output, 0, 0);
  return imageReader2D.getImageData(0, 0, output.width, output.height);
};
var getImageBitmap = (imageData, format) => __awaiter(void 0, void 0, void 0, function* () {
  switch (format) {
    case "nv12":
    case "yuv":
      if (!window.VideoFrame)
        return Promise.reject(new Error(`Cannot process frame. ImageData in ${format} is not supported by this browser.`));
      const frame = new VideoFrame(imageData.data.buffer, {
        format: "NV12",
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        timestamp: 0
      });
      return createImageBitmap(frame);
    case "rgb":
      return createImageBitmap(imageData);
  }
});
var createFunctionSource = (sourceFunction, options = {}) => {
  let width2 = 0;
  let height2 = 0;
  let shouldProcessFrame = true;
  const imageReaderCanvas = document.createElement("canvas");
  const imageReader2D = imageReaderCanvas.getContext("2d");
  const subscriber = {
    onAttach: (source, lensCore, reportError) => {
      const outputs = lensCore.getOutputCanvases();
      const output = {
        live: outputs[lensCore.CanvasType.Preview.value],
        capture: outputs[lensCore.CanvasType.Capture.value]
      };
      const processFrame = (source2, lensCore2, reportError2) => requestAnimationFrame(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (!shouldProcessFrame)
          return;
        try {
          yield sourceFunction(({ format, imageData, timestampMillis }) => {
            const frameOutput = new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
              const inputFrame = yield getImageBitmap(imageData, format !== null && format !== void 0 ? format : "rgb");
              if (inputFrame.width !== width2 || inputFrame.height !== height2) {
                width2 = imageReaderCanvas.width = inputFrame.width;
                height2 = imageReaderCanvas.height = inputFrame.height;
                source2.setRenderSize(width2, height2);
              }
              lensCore2.processFrame({ inputFrame, timestampMillis }).then(() => __awaiter(void 0, void 0, void 0, function* () {
                inputFrame.close();
                switch (format !== null && format !== void 0 ? format : "rgb") {
                  case "nv12":
                  case "yuv":
                    const [live, capture] = yield Promise.all([
                      getYUVImageData(output.live, lensCore2),
                      getYUVImageData(output.capture, lensCore2)
                    ]).catch((error) => {
                      reject(error);
                      return [void 0, void 0];
                    });
                    if (!live || !capture)
                      return;
                    return resolve({ live, capture });
                  case "rgb":
                    return resolve({
                      live: getRGBImageData(output.live, imageReader2D),
                      capture: getRGBImageData(output.capture, imageReader2D)
                    });
                }
              })).catch((error) => {
                inputFrame.close();
                reject(error);
              });
            }));
            frameOutput.finally(() => processFrame(source2, lensCore2, reportError2));
            return frameOutput;
          });
        } catch (error) {
          reportError2(new Error(`Failure to process frame, which was not handled by the provided MediaSourceFunction ${(_a = sourceFunction.name) !== null && _a !== void 0 ? _a : "anonymous"}.`, { cause: error }));
        }
      }));
      processFrame(source, lensCore, reportError);
    },
    onDetach: () => {
      shouldProcessFrame = false;
    }
  };
  return new CameraKitSource({ useManualFrameProcessing: true }, subscriber, options);
};

// node_modules/@snap/camera-kit/lib/media-sources/ImageSource.js
function createImageSource(image, options = {}) {
  return new CameraKitSource({
    media: image
  }, {
    onAttach: (source) => {
      const [width2, height2] = image.width === 0 || image.height === 0 ? [image.naturalWidth, image.naturalHeight] : [image.width, image.height];
      return source.setRenderSize(width2, height2);
    }
  }, options);
}

// node_modules/@snap/camera-kit/lib/index.js
console.info(`SDK: ${environment_default.PACKAGE_VERSION} (${lensCoreWasmVersions_default.version}/${lensCoreWasmVersions_default.buildNumber})`);
export {
  Any,
  CameraKit,
  CameraKitSession,
  CameraKitSource,
  Injectable,
  LensPerformanceMeasurement,
  LensPerformanceMetrics,
  LensRepository,
  LensSources,
  PartialContainer,
  Transform2D,
  TypedCustomEvent,
  TypedEventTarget,
  benchmarkError,
  bootstrapCameraKit,
  bootstrapError,
  cacheKeyNotFoundError,
  cameraKitSessionFactory,
  cameraKitSourceError,
  configurationError,
  configurationToken,
  createExtension,
  createFunctionSource,
  createImageSource,
  createMediaStreamSource,
  createUserMediaSource,
  createVideoSource,
  estimateLensPerformance,
  extensionRequestContext,
  getCameraKitUserAgent,
  getPlatformInfo,
  getRequiredBootstrapURLs,
  legalError,
  lensAbortError,
  lensAssetError,
  lensContentValidationError,
  lensError,
  lensExecutionError,
  lensImagePickerError,
  lensSourcesFactory,
  namedError,
  persistentStoreError,
  platformNotSupportedError,
  remoteApiServicesFactory,
  remoteMediaAssetLoaderFactory,
  toPublicLens,
  uriHandlersFactory,
  webGLError
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@snap_camera-kit.js.map
